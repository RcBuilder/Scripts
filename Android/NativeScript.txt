******************************
******** Nativescript ********
******************************

==============================
- Reference
- Forum
- Install
- About
- Android Device
- Android Virtual Device (AVD)
- Nativescript CLI
- Create A New Project
- Project Files
- Run The APP
- DEBUG
- LiveSync
- App-Root
- Using Services
- NativeScript & Visual Studio
- UI Layouts
- UI Components
- User Controls 
- Custom UI Components
- Page Component
- View Class
- Find Elements
- Animations
- Dialogs
- Modals
- Popups
- Web Version
- visibility
- Events/ Gestures
- JS Modules
- Ng Directives
- Google Firebase
- Plugins
- Background Services
- Workers
- Other Services
- Working With Nativescript
- Passing Context
- Request Parameteres
- Request Context
- Navigation
- Fixed bottom Strip
- Notifications
- Debugging
- Storage
- Techniques
- Multiple Views
- Icons
- App Resources 
- systemIcon
- Font Awesome
- Platform Specific Capabilities
- CSS
- Launch Process
- Deploy(iOS)
- Deploy(android)
- Sidekick APP
- MarketPlace
- Playground
- Issues
- Code Samples
==============================

Reference
---------
https://docs.nativescript.org
https://docs.nativescript.org/api-reference/globals

Forum
-----
https://forum.nativescript.org

Install
-------
install the nativescript CLI:
>npm install -g nativescript

note! 
make sure npm (node package manager) installed on your machine, 
if not, install it (node-v8.11.4-x64.msi)

About
-----
by Telerik.
an open-source framework which uses the Javascript Engine to generate a Native Application! 
it adds a converting layer which translates javascript code into native runtime.
allows us to create a single app which then can be complied as APK package (android), IPA package (iOs) and XAP (windows).
it uses an XML to generate the UI and allows us to use regular CSS which later be translated 
into native stylish rules! (note: not ALL the CSS rules have mapped).

How it works:
the framework uses javascript with Css-like and XML to write uniform code which fits to all mobile operating-systems alike. 
it doing so by mapping each javascript Code, Css rules and XML tags to the corresponding native code of the target app.
meaning, a build for iOS will be translated into a different code than a build which Android is the target. 

Motto:
"Write Once, Run everywhere"
Share 100% code between iOs, Android and Windows.

Structure:
Javascript Engine > Javascript 2 Native runtime > Native UI + APIs

Support:
- Javascript
- TypeScript
- Angular 

Android Device
--------------
we can connect via usb an android device for debugging purposes.
in order to do so, we'll have to turn on the 'Developer options' and enable the 'USB debugging' feature.

Virtual Devices:
see 'Android Virtual Device (AVD)'

Android Virtual Device (AVD)
----------------------------
in order to debug an app on android, we have to configure a AVD on our machine 

Physical Devices:
see 'Android Device'

AVD Manager using Android Studio:
- open Android Studio
- (menu) Tools > AVD Manager

- actions:
  run - use the green 'play' button to run the emulator.
  stop - use the arrow button > stop
  clear - use the arrow button > Wipe Data
  duplicate - use the arrow button > duplicate

- note!
  behind the scene, the android studio interface runs the avd manager tool (see 'AVD Manager Tool')

- default location:
  C:\Users\[User]\.android\avd

AVD Manager Tool:
file avdmanager.bat.
use the avdmanager tool to create and manage android virtual devices (AVDs) from the command line.
this tool is provided in the android SDK. 
located within the %ANDROID_HOME%\tools\bin folder in the SDK.

Create an AVD using Android Studio:
- open Android Studio
- (menu) Tools > AVD Manager
- click on 'Create Virtual Device' button (bottom-left corner)
- choose 'Category' (TV, Phone, Tablet etc.) from the left pane
- choose pre-defined device from the list presented in the right pane > next
- select the system image
- set AVD name and some more settings (if needed) > finish

- tip: custom hardware profiles
  we can generate an AVD based on a custom hardware (instead of using the built-in suggested hardwares) by using 
  the 'New Hardware Profile' button underneath the Category section! 

Create an AVD using the CLI:
- syntax
  // using the avdmanager tool
  > avdmanager create avd -n [AVD Name] -k [options] -p [path]

- sample  
  > avdmanager create avd -n testAVD -k "system-images;android-25;google_apis;x86" -p "D:\\"

Options:
- Hardware Profile  // Profile - Nexus 5, Pixel 2 etc.
- System Image  // OS - Oreo, Lollipop, Marshmallow etc.
- Startup Orientation  // Portrait or Landscape
- Camera  // enable camera - Back-Facing/ Front-Facing Camera 
- Network: Speed  // network protocol to determine the speed of data transfer - GSM, LTE etc. 
- Network: Latency  // network Latency
- Memory and Storage: RAM  // amount of RAM on the device 
- Memory and Storage: VM Heap  // VM heap size
- Memory and Storage: Internal Storage  // amount of nonremovable memory space available on the device
- Memory and Storage: SD Card  // amount of removable memory space available to store data on the device
- Device Frame: Enable Device Frame  // enable a frame around the emulator window
- Custom Skin Definition  // the emulator's skin
- Keyboard: Enable Keyboard Input  // to use your hardware keyboard to interact with the emulator

Nativescript CLI
----------------
tns = Telerik NativeScript

commands:
> tns // help
> tns --help // help
> tns help // help (html view)
> tns /? // help (html view)

> tns create [projectName]
> tns create [projectName] --template [templateName]
> tns run [android|ios]  // run the app
> tns run [android|ios] --debug --scan --stacktrace // run the app with extra info
> tns run --device [deviceId] // run the app on specific connected device (note: use tns device command to get the device id)
> tns device  // list of connected devices (physical and virtual)
> tns device [android|ios] 
> tns plugin add [plaginName]  // add plugin
> tns plugin remove [plaginName]  // remove a plugin
> tns plugin update [plaginName]  // update a plugin
> tns plugin // installed plugin list

> tns debug [android|ios]  // debug a device (see 'Debugging')
> tns debug [android|ios] --bundle  // debug bundled app (see 'Debugging')

> tns build [android|ios] // build the app
> tns build [android|ios] --log trace // build the app + trace log

> tns platform remove [android|ios] // remove a platform 
> tns platform add [android|ios] // add a platform 

> tns resources generate icon [imagePath] // generate app icons from image

stop tns run command:
> ctrl + c

samples:
// create an HelloWorld project with blank template 
> tns create HelloWorld --template tns-template-blank  

// run the app on an android emulator 
// also see 'Android Virtual Device (AVD)'
> tns run android  

// run the app on an ios emulator 
// only available on MAC!
> tns run ios

// debug android device
> tns debug android  

// TODO 

Create A New Project
--------------------
using NPM: 
> tns create [ProjectName]
> tns create project1  // e.g

Project Files
-------------
Root
  - app
  	- App_Resources  // resources (icons etc.)
	  - Android
	  - iOS

	- app.css  // app global style
	- app.js  // app starting point

	- main-page.css  // page css (style) 
	- main-page.js   // page code (logic)
	- main-page-view-model.js   // page view-model
	- main-page.xml	 // page layout (UI)

	- package.json  // packages
    - node_modules  // npm modules
    - tns_modules  // nativescript modules

  - platforms  // the generated native code
    - android 
	- ios

note!
in NativeScript, a .js file with the same name as an XML file is known as a code-behind file.

application Id:
defined in package.json file (e.g: com.hadeliverim).
in AndroidManifest.xml file there's _PACKAGE__ variable which is replaced by the application Id.

sample:
// main-page-view-model.js
var Observable = require("data/observable").Observable;
function createViewModel() { 
    var viewModel = new Observable();	
    ...
	...
    return viewModel;
}
exports.createViewModel = createViewModel;

// main-page.js
var createViewModel = require("./main-page-view-model").createViewModel;
function onNavigatingTo(args) {    
    var page = args.object;
    page.bindingContext = createViewModel();
}
exports.onNavigatingTo = onNavigatingTo;

// main-page.xml
<Page xmlns="http://schemas.nativescript.org/tns.xsd" navigatingTo="onNavigatingTo" class="page">
	...
</Page>

Run The APP
-----------
using NPM: 
> tns run  // all connected devices/emulators
> tns run android  // target specific platform
> tns run ios  // target specific platform
> tns run ios --emulator

to connect to android device or AVD see 'Android Device'

DEBUG
-----
using devTools: 
> tns debug android

the above command generates a URL to copy from the console, 
copy it and paste it into chrome and use the devTools (F12) to start debugging!

--

using ConsoleLog:
use this command write any message to the console, similar to the web version but the messages will be written to the terminal 
console.log([message]);

another great command for debugging is console.dir([object]) which creates a dump of the object. 
very handy when we have an object and we need to log it's content (json serialization).
note that for complex types, the console.log prints [object Object] and NOT the content!

// [object Object]
console.log({ id: 1001, name: 'someName' }); 

/*
	{
        'id': '1001',
        'name': 'someName'
    }
*/
console.dir({ id: 1001, name: 'someName' });

--

notes: 
- to debug an physical device see 'Android Device'
- use the tns device command to see the list of connected devices (physical and virtual)

--

error handling:
exception will be logged to the terminal with the relevant message and the exact location.

// e.g
JS ERROR Error: Building UI from XML. @file:///app/main-page.xml:2:50
     > close tag


LiveSync
--------
note that the command 'tns run' not only starts the app, it also activates the live sync mode which monitor the code for changes! 

App-Root
--------
file:
app/app-root.xml

about:
prior nativescript 4, we couldn't share layout betwwen pages and we had to duplicate it for each page. 
in version 4+ we've got a support for shared layout using the main app-root (which previously contained ONLY a Frame). 

support: 
SideDrawer 
TabView 

set shared layout:
const application = require("application");
application.run({ moduleName: "app-root" });   

note! we can add app-root.js if needed

using TabView:
// app/app-root.xml
<TabView androidTabsPosition="bottom">
  <TabViewItem title="Home">
    <Frame defaultPage="Pages/Home/home-page"></Frame>
  </TabViewItem>
  <TabViewItem title="Login">
    <Frame defaultPage="Pages/Login/login-page"></Frame>
  </TabViewItem>
  <TabViewItem title="Search">
    <Frame defaultPage="Pages/Search/search-page"></Frame>
  </TabViewItem>
</TabView>

using SideDrawer:
<sd:RadSideDrawer id="app-drawer" xmlns:sd="nativescript-ui-sidedrawer" drawerTransition="SlideInOnTopTransition" drawerLocation="Left" drawerContentSize="150">
    <sd:RadSideDrawer.drawerContent>                                 
        <StackLayout class="drawerContent">
            <Label text="Home" />
            <Label text="About" />
            <Label text="Contact" />
            <Label text="FAQ" />                
        </StackLayout>
    </sd:RadSideDrawer.drawerContent>

    <sd:RadSideDrawer.mainContent>
        <StackLayout>                        
            <Frame defaultPage="Pages/Home/main-page"></Frame>              
        </StackLayout>
    </sd:RadSideDrawer.mainContent>
</sd:RadSideDrawer>

Using Services
--------------
we can add services as js files and consume them using the 'require' method 

steps:
1. create a new js file 
2. reference the created js file from chapter 1
3. use the service 

using:

// app/Services/serviceA.js
function serviceA(){
    return{
        sayHello: function(){
            return "Hello from service A";
        }
    };
}
exports.serviceA = serviceA; 

// app/Services/serviceB.js
function serviceB(){
    return{
        sayHello: function(){
            return "Hello from service B";
        }
    };
}
exports.serviceB = serviceB; 

// some view-model js file
var Observable = require("data/observable").Observable;
var ServiceA = require('~/Services/serviceA').serviceA();
var ServiceB = require('~/Services/serviceB').serviceB();

function createViewModel(page) { 
    var viewModel = new Observable();    
    
    viewModel.serviceResult = '';
    viewModel.useServiceA = args => {
        viewModel.set('serviceResult', ServiceA.sayHello());
    };

    viewModel.useServiceB = args => {
        viewModel.set('serviceResult', ServiceB.sayHello());
    };
    
    return viewModel;   
}
exports.createViewModel = createViewModel; 

NativeScript & Visual Studio
----------------------------

Nativescript Extension For Visual Studio Code:
- find nativescript extension at visual studio's marketplace:
  https://marketplace.visualstudio.com/items?itemName=Telerik.nativescript
- install it

reference: 
also see 'Visual Studio Code'

---

SideKick Extension For Visual Studio:
- open visual studio
- (menu) Tools > Extensions & updates
- (tab) Online 
- search for 'nativescript'
- download 'nativeScript SideKick for VS'
- run the downloaded installation file

a new 'sidekick' menu will be added to the top menu!

UI Layouts
----------
- Absolute  
  - about: 
    x,y coordinates to specify the components position within the layer

  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_layouts_absolute_layout_

  - define the layout inner components using the following properties:
    left
	top
	height
	width

  - sample:
    <AbsoluteLayout>
        <Label text="Component" class="h3 text-center" backgroundColor="#0099CC" left="10" top="10" height="50" width="100" />
        <Label text="Component" class="h3 text-center" backgroundColor="#C3C3E5" left="10" top="50" height="50" width="100" />
        <Label text="Component" class="h3 text-center" backgroundColor="#8C489F" left="90" top="20" height="50" width="100" />
    </AbsoluteLayout> 

- Dock      
  - about: 
    screen location (top, bottom, right, left, center) to specify the components position within the layer

  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_layouts_dock_layout_

  - dock property: 
    define the component position using one of the following values
    left
	right
	bottom
	top	

  - stretchLastChild property:     
    determines whether the last component will be stretched or not.	
	value can be true or false 

  - sample:
    <DockLayout stretchLastChild="true">
        <Label text="Component" class="h3 text-center" backgroundColor="#0099CC" dock="left" />
        <Label text="Component" class="h3 text-center" backgroundColor="#C3C3E5" dock="right" />
        <Label text="Component" class="h3 text-center" backgroundColor="#8C489F" dock="bottom" />
        <Label text="Component" class="h3 text-center" backgroundColor="#B3B3D7" dock="top" />
        <Label text="Component" class="h3 text-center" backgroundColor="#CCFFFF" height="50" />
    </DockLayout> 

- Grid
  - about: 
    grid/table based layer 

  - reference:
    https://docs.nativescript.org/api-reference/classes/_ui_layouts_grid_layout_.gridlayout
    https://docs.nativescript.org/api-reference/modules/_ui_layouts_grid_layout_

  - columns property:
    defines the number of columns and each size 
	use * or 'auto' for auto size

  - rows property:
    defines the number of rows and each size 
	use * for auto size

  - grid size:
    specify the grid size using the 'columns' and 'rows' properties
	e.g:
	columns="*,*,*" rows="*,*,*,*,*" // 3 columns and 4 rows equally sized 

  - rowSpan property:
    join rows. the value represents the number of rows to join
	e.g: rowSpan="2"

  - colSpan property:
    join columns. the value represents the number of columns to join
	e.g: colSpan="3" 

  - col property:
    set the component column index 

  - row property:
    set the component row index 

  - choose cell:
    use the 'col' and 'row' properties to choose the cell which be the container of the component
	e.g: row="0" col="0" represents the 1st cell (0,0), the first column in the first row
	e.g: row="1" col="2" represents the 3rd cell in the 2nd row (2,1), the third column in the second row

  - bindingContext
    <sd:RadSideDrawer id="app-drawer" xmlns:sd="nativescript-ui-sidedrawer" drawerOpening="OnDrawerOpen"> 
		... 
	</sd:RadSideDrawer>

	var drawer;
	exports.OnDrawerOpen = args => {
		drawer = args.object;        
		drawer.bindingContext = { ... };
	};
    

  - using seperator line
    <GridLayout columns="100,*,50" rows="30,30,30,30,30">            
        <Label row="0" col="0" text="A" />
        <Label row="0" col="1" text="B" />
        <Label row="0" col="2" text="C" /> 
                
        <StackLayout row="1" colSpan="3" class="hr-light" />
    
        <Label row="2" col="0" text="D" />
        <Label row="2" col="1" text="E" />
        <Label row="2" col="2" text="F" />

        <StackLayout row="3" colSpan="3" class="hr-light"  />
    
        <Label row="4" col="0" text="G" />
        <Label row="4" col="1" text="H" />
        <Label row="4" col="2" text="I" />   
    </GridLayout>
    

  - sample:
    <GridLayout columns="*,*" rows="*,*,*">
        <Button text="1" row="0" col="0"></Button>
        <Button text="2" row="0" col="1"></Button>
        <Button text="3" row="1" col="0"></Button>
        <Button text="4" row="1" col="1"></Button>
        <Button text="5" row="2" col="0"></Button>
        <Button text="6" row="2" col="1"></Button>
    </GridLayout>

	<GridLayout columns="40,*" rows="*,*,*">
        <Button text="1" row="0" col="0"></Button>
        <Button text="2" row="1" col="0"></Button>
        <Button text="3" row="2" col="0"></Button>
        <Button text="4" row="0" col="1" rowSpan="3"></Button>            
    </GridLayout>

    <GridLayout columns="*,*,*" rows="40,40,40,40,40">
        <Label text="1" row="0" col="0" backgroundColor="#0099CC"></Label>
        <Label text="2" row="0" col="1" backgroundColor="#FFFF66"></Label>
        <Label text="3" row="0" col="2" rowSpan="2" backgroundColor="#AA0078"></Label>
        <Label text="4" row="1" col="0" rowSpan="2" colSpan="2" backgroundColor="#8C489F"></Label>
        <Label text="5" row="2" col="2" backgroundColor="#CCFFFF"></Label>
        <Label text="6" row="3" col="0" colSpan="3" backgroundColor="#0099CC"></Label>
    </GridLayout>  

- Stack     
  - about: 
    one on top of the other.

  - orientation property:    
    horizontal
	vertical (default)

  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_layouts_stack_layout_

  - sample:
    <StackLayout class="p-4">
        <Button text="Component" class="text-center" backgroundColor="#0099CC" />
        <Button text="Component" class="text-center" backgroundColor="#C3C3E5" />
        <Button text="Component" class="text-center" backgroundColor="#8C489F" />       
    </StackLayout>

	<StackLayout orientation="horizontal" class="p-4">
        <Button text="Component" class="text-center" backgroundColor="#0099CC" />
        <Button text="Component" class="text-center" backgroundColor="#C3C3E5" />
        <Button text="Component" class="text-center" backgroundColor="#8C489F" />       
    </StackLayout>

- Wrap
  - about: 
    wraps elements.
	similar to the StackLayout, but it does not just stack all child elements, it wraps them if no space is left.
	can be used for galleries where the images are not the same size. 

  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_layouts_wrap_layout_

  - center:
    set horizontalAlignment property to 'center' in order to center the content 

  - sample:
    <WrapLayout>
        <Button text="1" width="150" height="100" backgroundColor="#0099CC" />
        <Button text="2" width="100" height="150" backgroundColor="#FFFF66" />
        <Button text="3" width="200" height="120" backgroundColor="#8C489F" />
        <Button text="4" width="100" height="50"  backgroundColor="#CCFFFF" />
        <Button text="5" width="250" height="100" backgroundColor="#AA0078" />
    </WrapLayout>

	<WrapLayout horizontalAlignment="center">
        <Image src="~/Pages/Layouts/logo_220.png" width="90" height="90" style="margin:5;" />
        <Image src="~/Pages/Layouts/logo_220.png" width="70" height="70" style="margin:5;" />
        <Image src="~/Pages/Layouts/logo_220.png" width="40" height="40" style="margin:5;" />            
        <Image src="~/Pages/Layouts/logo_220.png" width="80" height="80" style="margin:5;" />
        <Image src="~/Pages/Layouts/logo_220.png" width="100" height="100" style="margin:5;" />
        <Image src="~/Pages/Layouts/logo_220.png" width="100" height="100" style="margin:5;" />
        <Image src="~/Pages/Layouts/logo_220.png" width="120" height="120" style="margin:5;" />            
    </WrapLayout>

- Flexbox
  - about: 
    a single-direction layout concept. 
	either in horizontal rows or vertical columns.

  - reference:
    https://docs.nativescript.org/api-reference/classes/_ui_layouts_flexbox_layout_.flexboxlayout
	https://docs.nativescript.org/api-reference/modules/_ui_layouts_flexbox_layout_

  - flexDirection property:
    define the layout direction/ behaviour using one of the following values		
	row
	row-reverse  
	column
	column-reverse

	note! 
	when using the 'reverese' mode - the last item will be presented first and the first will be at the end.

	tip!
    in 'row' direction, setting height on a single item will affect ALL the others.

  - flexGrow property:
    determines the remaining space distribution between the items. not their ratio!!!
	e.g: 
	itemA has flexGrow 1 
	itemB has flexGrow 3
	the container size is 500px, each item takes 200px
	-
	the remaining space is 100px (500 - (200 * 2))
	each flex-grow unit is 25px (100 / (1 + 3))
	-
	itemA total size will be 225px (200 + (1 * 25))
	itemB total size will be 275px (200 + (3 * 25))

	note! 
	in 'wrap' mode (see 'flexWrap property') this property is optional! 
	without it, the remaining space will not be distributed between the items. 

  - flexWrap property: 
    by default, flex items will all try to fit onto one line. setting 'flexWrap' property changes this behaviour. 
	set it to value 'wrap' or 'wrap-reverse' to set the items as multi-line. 
	use the 'flexWrapBefore' property to decide when to start a new line (see 'flexWrapBefore property')

	note!
	when using this property, the flexGrow property is optional!
	
  - flexWrapBefore property:
    available in 'wrap' mode (see 'flexWrap property').    
	decides when to start a new line. 
	each item with flexWrapBefore set to true will open a new line and will be first in that line.

  - justifyContent property:
    available in 'wrap' mode (see 'flexWrap property'). 
	defines the alignment along the main axis.

	values:
	flex-end
	space-between
	space-around

	note!
	only works in 'wrap' mode when NO flexGrow defined!  

  - flex custom sort:
    use 'order' property on the inner items to define the sorting 
	e.g: <Label order="2" text="ComponentB" .... />

  - sample:
    <FlexboxLayout flexDirection="column">
        <Label text="Component" class="h3 text-center" backgroundColor="#0099CC" flexGrow="1" />
        <Label text="Component" class="h3 text-center" backgroundColor="#C3C3E5" flexGrow="1" />
        <Label text="Component" class="h3 text-center" backgroundColor="#8C489F" flexGrow="1" />
    </FlexboxLayout>

	<FlexboxLayout flexDirection="row">  
        <Label text="Component" class="h3 text-center" backgroundColor="#0099CC" flexGrow="1" />
        <Label text="Component" class="h3 text-center" backgroundColor="#C3C3E5" flexGrow="1" />
        <Label text="Component" class="h3 text-center" backgroundColor="#8C489F" flexGrow="1" />
    </FlexboxLayout>

	<FlexboxLayout flexWrap="wrap" alignContent="flex-start">  
        <Label text="Component" class="h3 text-center" backgroundColor="#0099CC" flexGrow="2" />
        <Label text="Component" class="h3 text-center" backgroundColor="#C3C3E5" flexGrow="1" />           
        <Label flexWrapBefore="true" text="Component" class="h3 text-center" backgroundColor="#8C489F" flexGrow="1" />
        <Label text="Component" class="h3 text-center" backgroundColor="#CCFFFF" flexGrow="1" />
        <Label text="Component" class="h3 text-center" backgroundColor="#B3B3D7" flexGrow="1" />
        <Label flexWrapBefore="true" text="Component" class="h3 text-center" backgroundColor="#A6BBC8" flexGrow="1" />
    </FlexboxLayout>

	<FlexboxLayout flexWrap="wrap" alignContent="flex-start">  
        <Label text="Component" class="h3 text-center" backgroundColor="#0099CC" />
        <Label text="Component" class="h3 text-center" backgroundColor="#C3C3E5"  />           
        <Label flexWrapBefore="true" text="Component" class="h3 text-center" backgroundColor="#8C489F" />
        <Label text="Component" class="h3 text-center" backgroundColor="#CCFFFF" />
        <Label text="Component" class="h3 text-center" backgroundColor="#B3B3D7" />
        <Label flexWrapBefore="true" text="Component" class="h3 text-center" backgroundColor="#A6BBC8" />
    </FlexboxLayout>

	<FlexboxLayout flexDirection="column">  
        <Label order="2" text="ComponentB" class="h3 text-center" backgroundColor="#0099CC" flexGrow="1" />
        <Label order="3" text="ComponentC" class="h3 text-center" backgroundColor="#C3C3E5" flexGrow="1" />
        <Label order="1" text="ComponentA" class="h3 text-center" backgroundColor="#8C489F" flexGrow="1" />
    </FlexboxLayout>
  
note! 
the power of layouts is not by the individual layout but with the collaboration of them together. 
a proper way of creating a page is by using a few/ all layouts one inside the other. 

e.g: 
a Stack layout as Root whereas in each layout (in the Stack) there's inner layout of different type (Grid etc.)

- Stack Layout
	- Grid Layout
		- Label Element 
		- TextField Element 
- Stack Layout
	- ListView Element
- Stack Layout
	- Grid Layout
		- More Elements

UI Components
-------------
important! 
we can reach all components via javascript code by importing them from the 'ui' folder 
e.g: var c = require("tns-core-modules/ui/[component-folder]");

--

for custom components see 'Custom UI Components'

--

// see 'UI Layouts'
AbsoluteLayout
DockLayout
GridLayout
StackLayout
WrapLayout
FlexboxLayout

--

- Page
  see 'Page Component'

- View 
  see 'View Class'

- ScrollView
  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_scroll_view_

  - about:
    allows us to add scroll to the page or to a specific container. 
	display a scrollable area by wrapping the content with a ScrollView tag.

  - orientation property:    
    horizontal
	vertical

  - events:    
    scroll

  - sample:
    <ScrollView orientation="vertical">
		<StackLayout class="p-20">
		   ...
		   ...
		</StackLayout>
	</ScrollView>


- ActionBar
  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_action_bar_

  - android.position:
    left 
	right 
	popup // items that will be shown under the 3 dots right menu

  - systemIcon
    see 'systemIcon'

  - ActionBar Title
    title 
	android.icon  // add an icon 
	android.iconVisibility 

  - custom title	
	<Page.actionBar>
		<ActionBar class="action-bar">
		  <StackLayout class="action-bar-title">
			<Label text="My App" class="font-weight-bold" color="blue"></Label>
		  </StackLayout>
		</ActionBar>
	</Page.actionBar>	
	
  - NavigationButton (back button)
    <ActionBar title="My App" icon="" class="action-bar">
        <NavigationButton tap="{{ onBackButton }}" android.systemIcon="ic_menu_back" />
    </ActionBar>

	viewModel.onBackButton = args => {
        let view = args.object;
        let frame = view.page.frame;
        console.log('frame: ' + frame);
        frame.goBack();
    };

  - hide the ActionBar
    use the 'actionBarHidden' page property to hide the bar

	// via code
	page.actionBarHidden = true;

	// via UI page tag
	<Page .... actionBarHidden="true">

  - sample:
    <ActionBar title="Title" android.icon="res://icon" android.iconVisibility="always">		
		<ActionItem text="Menu Item" android.position="popup"></ActionItem>        
        <ActionItem text="Menu Item" android.position="popup"></ActionItem>        

        <ActionItem text="Item"></ActionItem>
		<ActionItem ios.systemIcon="12" android.systemIcon="ic_menu_search"></ActionItem>	        				
	</ActionBar>  

- Button  
  - reference:
    https://docs.nativescript.org/api-reference/classes/_ui_button_

  - sample:
    <Button text="Button" class="btn btn-primary btn-active" tap="{{ onTap }}" />

	viewModel.onTap = function () { 
		...
	}

- Label
  - reference:    
	https://docs.nativescript.org/api-reference/classes/_ui_label_

  - sample:
    <Label text="Label" class="h3 text-center" />

- TextField
  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_text_field_

  - events:
    returnPress
	focus
	blur

  - secure property:
    convert the input text into input password

  - isEnabled property:
    <TextField isEnabled="false" />
  
  - keyboardType property:
    defines the type of keyboard which will be presented to the user. 

	values:
	datetime
	email
	number
	phone
	url

	e.g: 
	keyboardType="number" will open a numeric keyboard

  - returnKeyType property:
    represents which type of the 'completed' button to present in the keyboard 

	values:
	done
	go
	next
	search
	send

	e.g: 
	returnKeyType="done" will open a keyboard with green-circle v button!

  - autocorrect property:
    determines whether to apply the autocorrection feature or not

  - maxLength preoperty:
    defines the maximum length of the input

  - submit a value:
    To submit a value use the 'returnPress' event along with the 'returnKeyType' property

  - sample:
    <TextField hint="fill your name" returnKeyType="done" autocorrect="false" maxLength="10" /> 
	<TextField hint="fill your ade" returnKeyType="done" keyboardType="number" maxLength="3" /> 

- TextView 
  - reference:
    https://docs.nativescript.org/api-reference/classes/_ui_text_view_.textview

  - about:
    a kind-of TextArea, a TextField with multiple lines.
    usually used for read-only large text.

	note that we can use labels with textWrap instead for better UI flexibility.

  - editable property:
    determines whether the content is editable or not.
	when editable is set to false, the text is read-only and the keyboard will not open.

  - properties and events:
    the same as 'TextField' component 
	autocorrect, maxLength, returnKeyType, keyboardType etc.	

  - sample:  
    <TextView editable="false" text="some long content ...." height="80" />

- Switch
  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_switch_

  - isEnabled property:
    determine whether the component is enabled or disabled.
	true/false.

  - events:
    checkedChange

  - sample:  
    <StackLayout orientation="horizontal">
        <Switch class="m-15" checked="false" />
        <Switch class="m-15" checked="true" />
        <Switch class="m-15" checked="true" color="red" />
        <Switch class="m-15" checked="true" color="#00FF00" />                  
    </StackLayout> 

- Image
  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_image_

  - src property:
	use 'http://' prefix to load image from URL 
	use 'res://' prefix to load image from resource
	use '~/' prefix to load image from local file system
	
  - stretch property:
    use 'none' for orignal size
	use 'fill' for streching the image based on it's container
	use 'aspectFit' for stretching with aspect ratio preservation (clip image to fit destination)
	use 'aspectFill' for stretching with aspect ratio preservation 

  - resources:    
	see 'App Resources'

  - css:
    background-image: url("~/images/logo.png");
    background-repeat: no-repeat;
    height: 120;
    margin: 15;


  - javascript:
    let image = new imageModule.Image();
    image.src = "~/logo.png";
    dockLayout.addChild(image);

  - sample:
	<Image src="~/logo.png" /> 
	<Image src="http://my-domain.com/logo.png" />
	<Image src="res://logo" stretch="none" />
	<Image src="{{ base64ImageSource }}" />


- ActivityIndicator
  - reference:
    https://docs.nativescript.org/api-reference/classes/_ui_activity_indicator_.activityindicator

  - about:
    displays a progress indicator hinting the user for some background operation running (loading image etc.)

  - busy property:
    defines whether to presents a 'loading' indicator or not.
    true/false

  - events:
    busyChange

  - sample:
    <ActivityIndicator busy="true" width="70" height="70" class="activity-indicator" />

- Animations  
  see 'Animations'

- SegmentedBar
  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_segmented_bar_
	https://docs.nativescript.org/api-reference/classes/_ui_segmented_bar_.segmentedbar
	https://docs.nativescript.org/api-reference/classes/_ui_segmented_bar_.segmentedbaritem

	about:
	collection of tabbed views.

	SegmentedBar vs TabView:
	1. the position of SegmentedBar is not fixed.
	2. can place and style a SegmentedBar as needed on the page or inside additional app elements.
	3. need to handle the content shown after selection separately.

  - selectedIndex property:
    gets/ sets the index of the selected item.

  - selectedBackgroundColor property:
    gets/ sets the background color of the selected item.

  - events:
    selectedIndexChange

  - sample:
    <SegmentedBar>
        <SegmentedBarItem title="First" />
        <SegmentedBarItem title="Second" />
        <SegmentedBarItem title="Third" />
    </SegmentedBar>

- DatePicker
  - reference:
    https://docs.nativescript.org/api-reference/classes/_ui_date_picker_

  - events:
    loaded 
	dateChange
	dayChange
	monthChange
	yearChange

  - sample:
    <DatePicker maxDate="2020-01-01" minDate="2015-01-01" verticalAlignment="center"></DatePicker>

- TimePicker
  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_time_picker_

  - events:
    loaded
	timeChange

  - max and min properties:    
    maxMinute
	minMinute
	maxHour
	minHour

  - set time:
    use 'hour' property to set the hour 
	use 'minute' property to set the minute 

  - sample:
    <TimePicker hour="9" minute="45" verticalAlignment="center" />

- Span
  - reference:
    https://docs.nativescript.org/api-reference/classes/_text_span_.span

  - sample:
    <Span text="some test " fontSize="16" color="#006600" />

- FormattedString
  - reference:
    https://docs.nativescript.org/api-reference/classes/_text_formatted_string_.formattedstring

  - support:
	TextView 
    TextField 
	Label 

  - sample:
    <Label class="h3 text-center">
        <FormattedString>
        <Span text="bla " color="#006600" ></Span>
        <Span text="bla " color="#990000" fontAttributes="Bold"></Span>
        <Span text="bla " color="#ffcc00"></Span>
        <Span text="bla"></Span>
        </FormattedString>
    </Label>

- ListPicker
  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_list_picker_
	https://docs.nativescript.org/api-reference/classes/_ui_list_picker_.listpicker

  - selectedIndex property:
    select an item by it's index.
	the value represents the item index to select. 
	e.g: selectedIndex="0" for the 1st item in the list

  - events:
    loaded

  - sample:
    viewModel.colors = ['blue', 'red', 'purple', 'green', 'brown', 'black', 'yellow', 'pink'];

	<ListPicker items="{{ colors }}" selectedIndex="0" class="p-15" />


- Dialogs
  see 'Dialogs'
  
- Progress
  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_progress_

  - events:
    loaded
	valueChange

  - sample:
    viewModel.progressValue = 1;
    setInterval(() => {                 
        let progressValue = viewModel.get('progressValue');
		if(progressValue >= 100) progressValue = 0;
        viewModel.set('progressValue', progressValue + 1); 
    }, 200);

    <Progress value="{{ progressValue }}" maxValue="100" class="m-20" />

- SearchBar
  - events:
    textChange
	submit
	clear

  - clear focus:    
    function onSearchBarLoaded(args){
		args.object.android.clearFocus();
	}
	exports.onSearchBarLoaded = onSearchBarLoaded;

	<SearchBar hint="Search..." text="{{ searchPhrase }}" loaded="onSearchBarLoaded" />

  - binding:
    set the search value as model in order to get the ability to bind it into a label etc.

  - sample:
    <SearchBar hint="Search..." text="{{ searchPhrase }}" />
    <Label text="{{ searchPhrase }}" textWrap="true" class="h3 p-15 text-center" />

- Slider
  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_slider_

  - minValue property:
    specifies the minimum value allowed

  - maxValue property:
    specifies the maximum value allowed

  - isEnabled property:
    determines whether the component is enabled or disabled 

  - events:
    valueChange

  - sample:
    <GridLayout class="m-15" rows="auto auto" columns="50 * 50">
        <Label row="0" colSpan="3" class="h2 p-15" text="{{ 'selected:' + sliderValue }}" textWrap="true" />
        <Label row="1" col="0" text="0" textWrap="true" fontSize="15" />
        <Slider row="1" col="1" value="{{ sliderValue }}" minValue="0" maxValue="100" />
        <Label row="1" col="2" text="100" textWrap="true" fontSize="15" horizontalAlignment="right" />  
    </GridLayout>

- HtmlView
  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_html_view_

  - about:
    use this component to show a static HTML content. 
	for dynamic HTML content or web page use the WebView Component (see 'WebView')

  - html property:
    use this property to set an HTML content. 

  - support:    
	HTML static content

  - sample:
    <HtmlView html="<p>Paragraph</p><p>Static HTML Content</p>" />

- WebView
  - reference:
    https://docs.nativescript.org/api-reference/classes/_ui_web_view_

  - about:
	this component is used to display web content within your application.
	for static HTML content we can also use the HtmlView Component (see 'HtmlView')

  - src property:
    use this property to set the URL or local HTML File.

  - support:
    URL
	HTML file
	HTML static content

  - events:
    loadStarted
    loadFinished	

  - methods:
    goBack
	goForward

  - sample:
    <WebView src="<p>Paragraph</p><p>Static HTML Content</p>" />
    <WebView src="~/Pages/HtmlViews/1.html" />
    <WebView src="http://example.com" />

- Repeater
  see 'ListView'

- ListView
  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_list_view_
	https://docs.nativescript.org/api-reference/classes/_ui_list_view_.listview

  - ng-template:
    we can use angular ng-template instead of the nativescript itemTemplate.

	e.g:
	<ListView [items]="countries">
		<ng-template let-country="item" let-i="index" let-odd="odd" let-even="even">
			...
		</ng-template>
	</ListView>

  - array binding
    use $value to bind an array item

  - nested ListView
    not supported! use 'Repeater' instead

	e.g:
	viewModel.priceList = [
        { 
            title: 'עד 20 ק"מ', lines: [
                'מחיר בסיס ימי חול: 23 ₪',
                'מחיר בסיס סופי שבוע: 23 ₪',
                'תוספת מרחק: 5 ₪ לכל ק"מ מעל 3',
                'תוספת נתח: 0% מסך ההזמנה'
            ] 
        },
        { title: 'מ-20 ק"מ עד 50 ק"מ', lines: [ 'מחיר: 100 ₪' ] 
        },
        { title: 'מ-50 ק"מ עד 80 ק"מ', lines: [ 'מחיר: 200 ₪' ] },
        { title: 'מ-80 ק"מ עד 120 ק"מ', lines: [ 'מחיר: 350 ₪' ] },
        { title: 'מ-120 ק"מ עד 150 ק"מ', lines: [ 'מחיר: 450 ₪' ] },
        { title: 'מ-150 ק"מ עד 250 ק"מ', lines: [ 'מחיר: 550 ₪' ] },
        { title: 'מעל 250 ק"מ', lines: [ 'מחיר: 700 ₪' ] }
    ];

	<ListView items="{{ priceList }}" class="list-group">
        <ListView.itemTemplate>
            <StackLayout class="list-group-item">
                <Label text="{{ title }}" fontWeight="bold" />    
				<Repeater items="{{ lines }}">
					<Repeater.itemTemplate>
						<Label text="{{ $value }}" />
					</Repeater.itemTemplate>
				</Repeater>
            </StackLayout> 
        </ListView.itemTemplate>            
    </ListView>

  - events:
    itemTap

  - listView properties:
    rowHeight
	items

  - sample:
    viewModel.countries = [
        { id: 1, name: 'Austria' }, 
        { id: 2, name: 'Belgium' }, 
        { id: 3, name: 'Cyprus' }, 
        { id: 4, name: 'Israel' },         
        { id: 5, name: 'Spain' }, 
        { id: 6, name: 'Sweden' }
    ];   

    <ListView items="{{ countries }}" class="list-group">
		<ListView.itemTemplate>
			<StackLayout orientation="horizontal" class="list-group-item">
				<Label text="{{ '#' + id + ' > ' }}" />                  
				<Label text="{{ name }}" fontWeight="bold" />    
			</StackLayout> 
		</ListView.itemTemplate>            
	</ListView>

	--

	viewModel.items = [
        { v: 1 },
        { v: 2 },
        { v: 3 },
        { v: 4 }
    ];

	<GridLayout>
        <ListView items="{{items}}">
            <ListView.itemTemplate>
                <Label text="{{v}}" />
            </ListView.itemTemplate>
        </ListView>
    </GridLayout>
 
- Repeater
  
  - reference:
	https://docs.nativescript.org/ui/ns-ui-widgets/repeater
  
  - array binding
    use $value to bind an array item

  - get the Page parent context
    $parents['Page']
    
	e.g:
	<Repeater items="{{ addresses }}">
        <Repeater.itemTemplate>
            <Button text="{{ address }}" tap="{{ $parents['Page'].OnAddressSelected }}" value="{{ coordinates }}" />
        </Repeater.itemTemplate>
    </Repeater>       

  - sample:
    <Repeater items="{{ items }}">
        <Repeater.itemsLayout>
            <StackLayout />
        </Repeater.itemsLayout>
        <Repeater.itemTemplate>
            <Label text="{{ item }}" />
        </Repeater.itemTemplate>
    </Repeater>

- TabView

  - reference:
    https://docs.nativescript.org/api-reference/modules/_ui_tab_view_
	https://docs.nativescript.org/api-reference/classes/_ui_tab_view_.tabview
	https://docs.nativescript.org/api-reference/classes/_ui_tab_view_.tabviewitem	

  - selectedIndex property:
    choose the active tab by it's index

  - tab colors:
    use 'tabTextColor' to set the color of the tabs
	use 'selectedTabTextColor' to set the color of the active tab
	use 'tabBackgroundColor' to set the back-color

  - iconSource property:
    apply on the 'TabViewItem' tag.
	allows us to add icon to each tab.

  - events:    
	loaded
	selectedIndexChanged
	showingModally

  - sample:
    <TabView id="tabViewContainer" selectedIndex="1" tabTextColor="#d3d3d3" selectedTabTextColor="#333333">
        <TabViewItem title="Tab1" iconSource="~/Pages/TabView/browser-icon.png">       
            <Label text="content for Tab1" textWrap="true" class="m-15 h3 text-left" color="blue" />
        </TabViewItem>
        <TabViewItem title="Tab2" iconSource="~/Pages/TabView/notes-icon.png">       
            <Label text="content for Tab2" textWrap="true" class="m-15 h3 text-left" color="blue" />
        </TabViewItem>
        <TabViewItem title="Tab3" iconSource="~/Pages/TabView/wallpaper-icon.png">       
            <Label text="content for Tab3" textWrap="true" class="m-15 h3 text-left" color="blue" />
        </TabViewItem>
    </TabView> 

	--

	<TabView id="tabView1">
		<TabView.items>
			<TabViewItem title="Tab1">
			<TabViewItem.view>
				<Label text="content for Tab1" />
			</TabViewItem.view>
			</TabViewItem>
			<TabViewItem title="Tab2">
			<TabViewItem.view>
				<Label text="content for Tab2" />
			</TabViewItem.view>
			</TabViewItem>
		</TabView.items>
	</TabView>

    --

	// history-page.xml
	// note: no js requires!
	<TabView selectedIndex="1" tabTextColor="#d3d3d3" selectedTabTextColor="#333333">        
        <TabViewItem title="הודעות">       
            <Frame defaultPage="Pages/History/Messages/messages-history-page" />
        </TabViewItem>    
        <TabViewItem title="משלוחים">       
            <Frame defaultPage="Pages/History/Deliveries/deliveries-history-page" />
        </TabViewItem>
    </TabView> 

	// deliveries-history-page.xml
	<Page class="page"
    navigatingTo="onNavigatingTo"  
    xmlns="http://schemas.nativescript.org/tns.xsd"
    xmlns:lv="nativescript-ui-listview"
    xmlns:partials="Pages/History/Partial"
    actionBarHidden="true">

		<lv:RadListView id="listview1" items="{{ items }}" class="mt-20"
			pullToRefresh="true" pullToRefreshInitiated="{{ onPullToRefresh }}" swipeActions="false">
			<lv:RadListView.listViewLayout>
				<lv:ListViewLinearLayout scrollDirection="Vertical" itemInsertAnimation="Slide" />
			</lv:RadListView.listViewLayout>
			<lv:RadListView.itemTemplate>
				<partials:delivery-item />
			</lv:RadListView.itemTemplate>        
		</lv:RadListView>
	</Page>

	// delivery-item.xml (partial)
	<GridLayout columns="*,80" rows="20,60,30" tap="{{ onItemClick }}" itemId="{{ id }}">            
		<Label row="0" colSpan="2" text="{{ deliveredOn }}" class="contentTitle alignTop left mh-10" />
		<StackLayout row="1" col="0">
			<Label text="{{ name }}" class="contentValue" />
			<Label text="{{ toAddress }}" class="contentTitle" />
			<Label text="{{ '&#8362; ' + amount }}" class="contentTitle" />
		</StackLayout>                                 
		<Image rowSpan="2" col="1" src="~/Images/avatars/Male-Avatar-Bow-Tie-icon.png" class="thumb img-rounded" />

		<StackLayout row="2" colSpan="2" class="hr-light" />
	</GridLayout>

User Controls
-------------
see 'Custom UI Components/Using XML'

Custom UI Components
--------------------

[Using Code]
1. write your component logic code 
   note that it has to inherit a component!
2. export your component
3. import the namespace to the Page Component 
4. add your component to the XML

// components/my-controls.js
// step 1
var MyStackLayout = (function (_super) {
		__extends(MyControl, _super);

		function MyControl() {
			_super.call(this);

			...
			...
		}
		return MyControl;
	})(stackLayout.StackLayout);

exports.MyStackLayout = MyStackLayout; // step 2

// steps 3 + 4
<Page xmlns:customControls="components/my-controls" navigatingTo="navigatingTo" class="page">
    <customControls:MyStackLayout /> 
</Page>

--- 

[Using XML]
1. create an XML layout using the nativescript components 
2. import the namespace to the Page Component 
3. add your component to the XML

// components/myLayout.xml
// step 1
<StackLayout class="p-20" loaded="onLoaded">
    <Label text="some text..." />    
    <Label text="{{ message }}" />
	...
	...
</StackLayout>

// steps 2 + 3
<Page xmlns:customControls="components" navigatingTo="navigatingTo" class="page">
  <customControls:myLayout />
</Page>

---

[tip] custom properties:
we can add logic to a component by adding a js file, then we can use custom properties to relay data. 

// menu-strip.xml
<ActionBar loaded="onMenuLoaded">
    <Label text="{{menuTitle}}" class="bold center" fontSize="18" />          
</ActionBar>

// menu-strip-view-model.js
function MenuViewModel(menu) {
    ...
    viewModel.menuTitle = menu.title;
	...
}

// menu-strip.js
function onMenuLoaded(args) {
    let menu = args.object;    
    menu.bindingContext = new MenuViewModel(menu);
}
exports.onMenuLoaded = onMenuLoaded; 

// using 
<customControls:menu-strip title="{{someTitle}}" />

---

get parent context:
args.object.page.bindingContext

---

samples:

// app/Pages/History/history-page.xml
<Page class="page"
    navigatingTo="onNavigatingTo"  
    xmlns="http://schemas.nativescript.org/tns.xsd"
    xmlns:partials="Pages/History/Partial"
    actionBarHidden="true">

    <StackLayout>
       <partials:history-items />         
    </StackLayout>
</Page>

// app/Pages/History/Partial/history-items.xml
 <StackLayout xmlns:partials="Pages/History/Partial">
    <Label text="ITEMS" /> 
    
    <partials:history-item /> 
    <partials:history-item /> 
    <partials:history-item />     
 </StackLayout>

// app/Pages/History/Partial/history-item.xml
<Label text="ITEM" />

Page Component
--------------
- reference:
  https://docs.nativescript.org/api-reference/classes/_ui_page_.page

- events:
  navigatingTo
  loaded

- page context
  - page.bindingContext = [context];
  - e.g: 
    var createViewModel = require("./view-model").createViewModel; // view-model.js
	function onNavigatingTo(args) { 
		var page = args.object;
		page.bindingContext = createViewModel();
	}
	exports.onNavigatingTo = onNavigatingTo;

	note!
	on the UI - bind the 'navigatingTo' event

- page reference:
  var _page;

  function onLoad(args){        
	  _page = args.object;
  }
  exports.onLoad = onLoad;

  note!
  on the UI - bind the 'loaded' event

- page frame:
  page.frame returns the current page frame.

- sample:
  var _page;

  function onLoad(args){        
	  _page = args.object;
  }
  exports.onLoad = onLoad;

  function onNavigatingTo(args) { 
	  var page = args.object;
	  page.bindingContext = [context]
  }
  exports.onNavigatingTo = onNavigatingTo;

  <Page xmlns="http://schemas.nativescript.org/tns.xsd" navigatingTo="onNavigatingTo" loaded="onLoad" class="page">  
	  ...
  </Page>

View Class
----------
- reference:  
  https://docs.nativescript.org/api-reference/classes/_ui_core_view_.view

- import:
  var view = require("ui/core/view");

// TODO

- methods:

- sample:

Find Elements
-------------

1. the basic: 
  // get reference to the 'view' class and the current 'page'
  var view = require("ui/core/view");
  var _page;
  
  function onLoad(args){    
      _page = args.object;
  }
  exports.onLoad = onLoad;
  
  <Page xmlns="http://schemas.nativescript.org/tns.xsd" navigatingTo="onNavigatingTo" loaded="onLoad" class="page">
  	...
  </Page> 

2. use the 'view' class to find elements on the view 
   view.getViewById(_page, '[name]');

   e.g: 
   var label = view.getViewById(_page, 'lbl1');

   // TODO

note:
also see 'Plugins/nativescript-dom'

Animations
----------
about:
supports every native component!
apply to the component's properties.

animate:
use the 'animate' function to make the animation.

syntax:
[component].animate([options])
	.then(() => { ... })
	.catch((e) => { ... });

Chaining Animations:
[component].animate([options])
    .then(() => [component].animate([options]))
    .then(() => [component].animate([options]))
    .then(() => [component].animate([options]))
    .then(() => { ... })
    .catch((e) => { ... });

supported properties:
- opacity
  type: numeric 0-1

- backgroundColor 
  type: Color

- translate 
  type: {x, y}

- scale 
  type: {x, y}

- rotate
  type: numeric 0-360

behaviour:
- duration
- delay
- iterations 
- originX and originY 
- curve  // see 'curves'

curves:
  note! need to add enums module (see 'JS Modules/enums')

- linear
  enums.AnimationCurve.linear

- Ease-in
  enums.AnimationCurve.easeIn

- Ease-out
  enums.AnimationCurve.easeOut
 
- Ease-in-out
  enums.AnimationCurve.easeInOut

- Spring
  enums.AnimationCurve.spring

- cubicBezier
  function (x1: number, y1: number, x2: number, y2: number)
  custom curve

working with colors:
see 'JS Modules/color'

view:
can target the whole view for animation! 
view.animate([options])

css:
to apply animations via css, use @keyframes 
see 'CSS/@keyframes'

animation module:
note! need to add animation module (see 'JS Modules/animation')
allows us to play multiple animations. 
supports multiple components 

multiple Views:
use the module to play multiple definitions 
set the playSequentially to true
see 'animation module'

chain using module:
use the module to play chain animations
set the playSequentially to false
see 'animation module'

samples:
<WrapLayout class="p-4">       
    <Button tap="animate1"  id="c1"  text="Opacity" />          
    <Button tap="animate2"  id="c2"  text="Change Color" backgroundColor="red" color="white" />          
    <Button tap="animate3"  id="c3"  text="translate" />   
    <Button tap="animate4"  id="c4"  text="translate" />   
    <Button tap="animate5"  id="c5"  text="translate" />   
    <Button tap="animate6"  id="c6"  text="rotate" />   
    <Button tap="animate7"  id="c7"  text="scale" />   
    <Button tap="animate8"  id="c8"  text="scale" />   
    <Button tap="animate9"  id="c9"  text="chain" backgroundColor="red" color="white" />   
    <Button tap="animate10" id="c10" text="chain" backgroundColor="red" color="white" />   
    <Button tap="animate11" text="multi" />   
</WrapLayout>

var view = require("ui/core/view");
var enums = require("ui/enums");
var colorModule = require("color");
var animationModule = require("ui/animation");

var _page;

function onLoad(args){        
    _page = args.object;
}
exports.onLoad = onLoad;

exports.animate1 = function(){    
    var component = view.getViewById(_page, 'c1');
    component.animate({
        opacity: 0.2,        
        duration: 1000
    });
}

exports.animate2 = function(){    
    var component = view.getViewById(_page, 'c2');
    component.animate({
        backgroundColor: new colorModule.Color("Purple"),         
        duration: 1000        
    });
}  

exports.animate3 = function(){    
    var component = view.getViewById(_page, 'c3');
    component.animate({
        translate: { x:120, y:0 },        
        duration: 1000,
        curve: enums.AnimationCurve.bounce 
    });
} 

exports.animate4 = function(){    
    var component = view.getViewById(_page, 'c4');
    component.animate({
        translate: { x: 0, y: -120 },        
        duration: 1000    
    });
}

exports.animate5 = function(){      
    var component = view.getViewById(_page, 'c5');
    component.animate({
        translate: { x: 0, y: 120 },        
        duration: 1000        
    });
}

exports.animate6 = function(){      
    var component = view.getViewById(_page, 'c6');
    component.animate({
        rotate: 360,        
        duration: 1000        
    });
}

exports.animate7 = function(){      
    var component = view.getViewById(_page, 'c7');
    component.animate({
        scale: { x: 0.5, y: 0.5 },        
        duration: 1000        
    });
}

exports.animate8 = function(){      
    var component = view.getViewById(_page, 'c8');
    component.animate({
        scale: { x: 2, y: 2 },        
        duration: 1000        
    });
}

exports.animate9 = function(){      
    var component = view.getViewById(_page, 'c9');

    var optionSet1 = {
        scale: { x: 0.5, y: 0.5 },        
        duration: 1000        
    };

    var optionSet2 = {
        backgroundColor: new colorModule.Color("Purple"),     
        duration: 1000        
    };

    component.animate(optionSet1)
        .then(() => component.animate(optionSet2));
}

exports.animate10 = function(){      
    var component = view.getViewById(_page, 'c10');

    var definitions = [];
    definitions.push({
        target: component,
        scale: { x: 0.5, y: 0.5 },        
        duration: 1000        
    });

    definitions.push({
        target: component,
        backgroundColor: new colorModule.Color("Purple"),     
        duration: 1000        
    });

    var animationSet = new animationModule.Animation(definitions, true);
    animationSet.play();
}

exports.animate11 = function(){      
    var component1 = view.getViewById(_page, 'c1');
    var component2 = view.getViewById(_page, 'c2');
    var component3 = view.getViewById(_page, 'c3');

    var definitions = [];
    definitions.push({
        target: component1,
        scale: { x: 0.5, y: 0.5 },        
        duration: 1000        
    });

    definitions.push({
        target: component2,
        backgroundColor: new colorModule.Color("Purple"),     
        translate: { x: 0, y: 120 },    
        duration: 1000        
    });

    definitions.push({
        target: component3,
        rotate: 360,        
        duration: 1000       
    });

    var animationSet = new animationModule.Animation(definitions, false);
    animationSet.play();
}  

Dialogs
-------
also see 'Modals'

- path
  'ui/dialogs'

  const dialogs = require('ui/dialogs');
  dialogs.<type>

- Types:
  Action
  Alert
  Confirm
  Login
  Prompt

- Action Dialog
    
  sample:
	let options = {
	  	title: "Age Range",
	  	message: "Choose your age",
	  	cancelButtonText: "Cancel",
	  	actions: ["0-18", "19-30", "31-55", "Above 56"]
	};
	  
	action(options).then((result) => {
	  	console.log('action result:' + result);
	});

- Alert Dialog

  sample:
	let options = {
	  	title: "Alert",
	  	message: "Some message ..",
	  	okButtonText: "OK"		
	};
	  
	alert(options).then(() => {
	  	console.log('alert');
	});

- Confirm Dialog

  sample:
	let options = {
	  	title: "Confirm",
	  	message: "Are you sure?",
        okButtonText: "YES",
        cancelButtonText: "NO",
        neutralButtonText: "Cancel"		
	};
	  
	confirm(options).then((result) => {
	  	console.log('confirm result:' + result);
	});  


- Login Dialog

  sample:
	let options = {
	  	title: "Login",
	  	message: "Login",        
        okButtonText: "Ok",
        cancelButtonText: "Cancel"
	};
	  
	login(options).then((loginResult) => {
	  	console.log('login result:' + loginResult.result);
	});

- Prompt Dialog

  sample:
	let options = {
	  	title: "Prompt",
        message: "Enter your name",
        defaultText: "",               
        okButtonText: "Ok",
        cancelButtonText: "Cancel",
        cancelable: true
	};
	  
	prompt(options).then((result) => {
	  	console.log('prompt result:' + result.text);
	});


Modals
------
also see 'Dialogs'

source:
https://docs.nativescript.org/ui/modal-view

methods:
showModal([view], [context: object], [closeCallback: function], [fullscreen: bool]?, [animated: bool]?, [stretched: bool]?)
showModal([moduleName: string], [context: object], [closeCallback: function], [fullscreen: bool]?, [animated: bool]?, [stretched: bool]?)
closeModal([context])

events:
shownModally  // when a modal is shown

implementation:
1. (parent) create a main view (parent)
2. (parent) add a button to open the modal view (popup)
3. (parent) generate a custom context to pass to the popup view
4. (parent) use the 'showModal' method to open the popup view with the above context and a 'closeCallback' callback function
5. (popup) create a popup view and register to the 'shownModally' event
6. (popup) add a button to close the popup
7. (popup) add a reference to the 'closeCallback' function received from the parent 
8. (popup) get the passed context and expand it with local model
9. (popup) execute the 'closeCallback' function once the user clicked on the close popup button from chapter 6

using:

[parent] 
<Button text="Open modal" (tap)="openModal" />  // step 2

exports.openModal = function(args){
	let parentView = args.object;
    let context = { p1:'value1', p2:'value2' }; // step 3
    
    parentView.showModal("./popup-view", context, (result) => {  // step 4
        console.log('result: ' + result);        
    });
};

[popup]
// step 5
<Page xmlns="http://www.nativescript.org/tns.xsd" shownModally="onShownModally">
    <StackLayout>
        ...
		...
        <Button text="Send" tap="onSendButtonTap" />  // step 6
    </StackLayout>
</Page>

let PageViewModel = require("./popup-view-model");
var observableModule = require("data/observable");
var closeCallback;  // step 7 

exports.onShownModally = function(args){
	// step 8
	let context = args.context;  // get the context from the opener 
    context.model = new PageViewModel();  // expand the context with a local model  

    closeCallback = args.closeCallback;

    let page = args.object;
    page.bindingContext = observableModule.fromObject(context);
};

// step 9
exports.onLoginButtonTap = function(args){
	let page = args.object.page;
    let bindingContext = page.bindingContext;    
    closeCallback('success!');
};

close model:
closeModal();

// e.g
<Image src="~/Images/x2.jpg" class="center" width="20" tap="onCloseModally" />

function onCloseModally(args){
    let page = args.object.page;
    page.closeModal();
}
exports.onCloseModally = onCloseModally;

--

example:
// popup.js
let observableModule = require("data/observable");

function onShownModally(args) {
    let context = args.context;  // get the context

    let page = args.object;
    page.bindingContext = observableModule.fromObject(context);
}
exports.onShownModally = onShownModally;

function onCloseModally(args){
    let page = args.object.page;
    page.closeModal();
}
exports.onCloseModally = onCloseModally;

// popup.xml
<Page class="popup"
    shownModally="onShownModally"
    xmlns="http://schemas.nativescript.org/tns.xsd"
    actionBarHidden="false">

    <StackLayout>        
        <GridLayout columns="40,*,40" rows="auto" class="header header-blue">
            <Label row="0" col="1" text="אודותינו" class="center" />       
            <Image row="0" col="2" src="~/Images/x2.jpg" class="center" width="20" tap="onCloseModally" />
        </GridLayout>    

        <ScrollView orientation="vertical">
            <StackLayout class="small-text mh-10">            
                <Label text="מי אנחנו – הדילברים" class="popupTitle mt-10" />
                <Label textWrap="true" text="אפליקציה חברתית של משלוחים עד הבית." />                

                <Label text="החזון" class="popupTitle mt-10" />
                <Label textWrap="true" textAlignment="left" text="...." />            
                <Label textWrap="true" textAlignment="left" text="...." />

                <Label text="המוצר שלנו" class="popupTitle mt-10" />   
                <Label textWrap="true" textAlignment="left" text="...." />
                <Label textWrap="true" textAlignment="left" text="...." />                                    
                <Label textWrap="true" textAlignment="left" class="mt-10 mb-10" text="...." />                            
            </StackLayout>         
        </ScrollView>
    </StackLayout>
</Page>

visibility
----------
use this attribute on any Nativescript control you want to set as visible/hidden. 
supports context binding variables

values:
- collapse  // hidden and doesn't take place in the layout 
- hidden
- visible

sample:

<sd:RadSideDrawer.drawerContent>  
	<StackLayout class="drawerContent">
        
		<StackLayout visibility="{{ type == 1 ? 'visible' : 'collapsed' }}">
			Menu For Restaurant
		</StackLayout>

		<StackLayout visibility="{{ type == 4 ? 'visible' : 'collapsed' }}">
			Menu For PackagesProvider
		</StackLayout>

		<!-- employee -->
		<StackLayout visibility="{{ type == 2 ? 'visible' : 'collapsed' }}">
			Menu For Employee  
		</StackLayout>

	</StackLayout>        
</sd:RadSideDrawer.drawerContent>

exports.onDrawerOpen = args => {
    drawer = args.object;      
        
    drawer.bindingContext = { 
        type: 2
    };
};

Popups
------
see 'Modals' and 'Dialogs'

Web Version
-----------
// TODO 

Events/ Gestures
----------------
[Gestures]
- require:
  path 'tns-core-modules/ui/gestures'

- enum:
  gestures.GestureTypes.[gesture]

  e.g:
  gestures.GestureTypes.tap
  gestures.GestureTypes.doubleTap

- syntax (code):
  on([type: number], [callback])
  on([name: string], [callback])
  on([names: Comma separated String], [callback])

  off([type: number], [callback])
  off([name: string], [callback])
  off([names: Comma separated String], [callback])

- syntax (UI):
  ([gestureName])="[functionName]"

  e.g:
  (doubleTap)="onDoubleTap($event)"


- Tap
  a single tap on the screen

- Double Tap
  two quick taps

- Long Press
  press the screen for a few moments

- Swipe
  slide the screen aside

- Pan
  press down and immediately start moving it around

- Pinch
  pinch the screen 

- Rotation
  rotate two fingers simultaneously left or right

- Touch
  any touch on the screen

- samples (code):
  var gestures = require("tns-core-modules/ui/gestures");    
  ...
  ... 
  label.on(gestures.GestureTypes.tap, function (args) {
    console.log("Tap");
  });

  label.on("loaded, tap, doubleTap, longPress", function (args) {
    console.log("Event: " + args.eventName + ", sender: " + args.object);
  });

- samples (UI):
  <GridLayout width="200" height="200" (longPress)="onLongPress($event)">
  ...
  </GridLayout>

  exports.onLongPress = function(args) {
	console.log("LongPress");
  };

- using:
  <Button text="playground" class="text-center" height="400" 
            tap="{{ onTap }}"
            doubleTap="{{ onDoubleTap }}" 
            longPress="{{ onLongPress }}"
            swipe="{{ onSwipe }}"
            pan="{{ onPan }}"
            pinch="{{ onPinch }}"
            rotation="{{ onRotation }}"
            touch="{{ onTouch }}"
        />

  var viewModel = new Observable();         
  viewModel.onTap = (args) =>{
  	console.log('onTap');
  };
  
  viewModel.onDoubleTap = (args) =>{
  	console.log('onDoubleTap');
  };
  
  viewModel.onLongPress = (args) =>{
  	console.log('onLongPress');
  };
  
  viewModel.onSwipe = (args) =>{
  	console.log('onSwipe ' + (args.direction == 1 ? 'right': 'left'));
  };
  
  viewModel.onPan = (args) =>{
  	console.log('onPan [' + args.deltaX + ',' + args.deltaY + ']');
  };
  
  viewModel.onPinch = (args) =>{
  	console.log('onPinch ' + args.scale);
  };
  
  viewModel.onRotation = (args) =>{
  	console.log('onRotation ' + args.rotation);
  };
  
  viewModel.onTouch = (args) =>{
  	console.log('onTouch [' + args.getX() + ',' + args.getY() + ']');
  };

[Events]
- navigatingTo

JS Modules
----------
- Gestures
  see 'Events/ Gestures'

- Observable
  path: 'data/observable'

  about:
  // TODO  

  MVVM pattern:
  var Observable = require("data/observable").Observable;

  function createViewModel(){
	var viewModel = new Observable();
	...
	...
	return viewModel;
  }
  exports.createViewModel = createViewModel;

  sub-classes:
  1.Observable
    const Observable = require("tns-core-modules/data/observable").Observable;	

  2.fromObject
    const fromObject = require("tns-core-modules/data/observable").fromObject;

	e.g:
	var newViewModel = fromObject({ 'p1': 'someValue' });

	// equal to:	
	///let newViewModel = new Observable();
	///newViewModel.set('p1', 'someValue');	

  3.fromObjectRecursive
    const fromObjectRecursive = require("tns-core-modules/data/observable").fromObjectRecursive; 

	e.g:
	var newViewModel = fromObject({ 
		'p1': 'someValue', 
		'p2': { 'p3': 'someOtherValue' }
	});

	// equal to:	
	///let newViewModel = new Observable();
	///newViewModel.set('p1', 'someValue');
	///newViewModel.set('p2', fromObject({ 'p3': 'someOtherValue' }));

  get and set functions:
  allow us to set/ get a value to/ from an Observable object

  e.g: 
  var viewModel = new Observable(); 
  viewModel.p = 1;
  var p = viewModel.get('p');
  viewModel.set('p');

  viewModel.locations = new ObservableArray();
  var locations = viewModel.get('locations');
  locations.push(location); 

  setInterval:
  can use setInterval to define a background worker. a great example is a Progress bar (see 'UI Components/Progress') 
  
  e.g:
  viewModel.progressValue = 1;
	setInterval(() => {         
		let progressValue = viewModel.get('progressValue');
		viewModel.set('progressValue', progressValue+1); 
  }, 300);

  sample:
  var Observable = require("data/observable").Observable;

  function createViewModel(){
	var viewModel = new Observable();
	viewModel.param1 = 'A';  
	viewModel.param2 = 'B';
	viewModel.param3 = new ObservableArray();

	return viewModel;
  }
  exports.createViewModel = createViewModel;


- Observable Array
  path: 'data/observable-array'

  sub-classes:
  ObservableArray    
  const ObservableArray  = require("tns-core-modules/data/observable-array").ObservableArray;

  $value:
  when binding an observable array, use the $value keyword to get the item data.
  useful when we have an array of primitive objects (string, int etc.)

  methods:
  getItem([index: number]) // returns an item by its index
  setItem([index: number], [item: object])  // add an item in a specific index
  push([item: object])  // add item
  push([items: array])  // add items
  reverse() // reverse the items
  shift()  // remove the 1st element
  sort()  // sort the array
  indexOf([item: object]) // returns the item index, -1 of not exists

  events:
  on([event], [function]);

  e.g
  arr.on(ObservableArray.changeEvent, (args) => {
    console.log(args.index); // Index of the changed item
    console.log(args.action); // Action
    console.log(args.addedCount); // Number of added items
    console.log(args.removed); // Array of removed items
  });

  using:
  // with lenght
  var arr1 = new ObservableArray([length]);

  // from array
  var arr2 = new ObservableArray([Array]);

  // from arguments
  var arr3 = new ObservableArray([arg1, arg2 ....]);

  e.g:
  // with lenght
  var arr1 = new ObservableArray(10);

  // from array
  var arr2 = new ObservableArray([0, 1, 1, 2, 3, 5, 8, 13, 21, 34]);

  // from arguments
  var arr3 = new ObservableArray(1, 2, 3, 5, 8, 13, 21, 33, 55, 89);

  sample:
  const Observable = require("data/observable").Observable;
  const ObservableArray  = require("tns-core-modules/data/observable-array").ObservableArray;

  function createViewModel(){
	var viewModel = new Observable();	

	var arr = new ObservableArray([0, 1, 1, 2, 3, 5, 8, 13, 21, 34]);
	viewModel.param1 = arr;

	var firstItem = arr.getItem(0);
	var secondItem = arr.getItem(1);

	return viewModel;
  }
  exports.createViewModel = createViewModel;

  sample:
  viewModel.logs = new ObservableArray();
  logs.push('A');
  logs.push('B');
  logs.push('C');

  <ListView items="{{ logs }}" class="list-group">
       <ListView.itemTemplate>
           <Label text="{{ $value }}" />                  
       </ListView.itemTemplate>            
   </ListView>  

- virtual array
  path: 'virtual-array'

  source:
  https://docs.nativescript.org/api-reference/modules/_data_virtual_array_

  // TODO

- utils
  path: 'utils/utils'

  source:
  https://docs.nativescript.org/api-reference/modules/_utils_utils_

  methods:
  openUrl([url: string]);

- file system
  path: 'file-system'

  source:
  https://docs.nativescript.org/api-reference/modules/_file_system_

  supports:
  Create/ Update (see 'writeText function' and 'fromPath static function')
  Delete (see 'remove function')
  Read (see 'readText function' and 'read as binary data')
  Rename (see 'change name')
  Paths (see 'path class')
  clear (see 'clear function')

  knownFolders class:
  use the module knownFolders to get the known folders (documents, temp, currentApp)    
  [module].knownFolders

  // syntax
  let documents = fileSystemModule.knownFolders.documents();

  getFolder function:
  [folder].getFolder([folderName: string]);  // returns a folder

  getFile function:
  [folder].getFile([fileName: string]);  // returns a file

  writeText function:
  [file].writeText([string])
	.then([onSuccess])
	.catch([onError]);

  readText function:
  [file].readText()
	.then([onSuccess])
	.catch([onError]);

  remove function:
  supports file and folder 

  [file].remove()
	.then([onSuccess])
	.catch([onError]);

  [folder].remove()
	.then([onSuccess])
	.catch([onError]);

  clear function:  
  [folder].clear()
	.then([onSuccess])
	.catch([onError]);

  path class:
  provides us with path utilities such as separator, join, normalize...
  [module].path

  // <documents>/myFiles/test.txt
  documents = fileSystemModule.knownFolders.documents();
  var filePath = fileSystemModule.path.join(documents.path, 'myFiles', 'test.txt');

  fromPath static function:
  get or create a file/ folder from path
  [module].File.fromPath([path: string]); // returns a file
  [module].Folder.fromPath([path: string]); // returns a file
  
  var documents = fileSystemModule.knownFolders.documents();

  var folderPath = fileSystemModule.path.join(documents.path, 'myFiles');
  var folder = fileSystemModule.Folder.fromPath(folderPath);  

  var filePath = fileSystemModule.path.join(documents.path, 'myFiles', 'test.txt');
  var file = fileSystemModule.File.fromPath(filePath);  

  readSync function:
  [file].readSync([onError]); // returns binary

  writeSync function:
  [file].writeSync([binary], [onError]);

  read as binary data:
  also see 'readSync function'

  // sample
  var image = imageSourceModule.fromResource("icon");
  var documents = fileSystemModule.knownFolders.documents();
  var path = fileSystemModule.path.join(documents.path, "1.png");
  var saved = image.saveToFile(path, "png");

  if (saved) {
    let imageFile = fileSystemModule.File.fromPath(path);
    let binarySource = imageFile.readSync(ex => { });    
  }

  write binary data:
  also see 'writeSync function'

  // sample
  imageFile.writeSync(binarySource, ex => { });

  getEntities function:
  returns array of entity (see 'entity class')
  [folder].getEntities()
	.then(entities => {
		entities.forEach(entity => { ... });
	})
    .catch(ex => { ... });   

  exists static function:  
  check if exists
  [module].File.exists([path: string]); // returns bool
  [module].Folder.exists([path: string]); // returns bool

  change name:  
  rename a folder or a file 
  [file].rename([newName: string])
	.then([onSuccess])
	.catch([onError]);

  [folder].rename([newName: string])
	.then([onSuccess])
	.catch([onError]);

  folder class:
  https://docs.nativescript.org/api-reference/classes/_file_system_.folder

  file class:
  https://docs.nativescript.org/api-reference/classes/_file_system_.file

  entity class:
  - name: string
  - path: string 
  - lastModified: date
  - parent: folder

  sample:
  let documents = fileSystemModule.knownFolders.documents();

  let folder = documents.getFolder('myFiles');
  let file = folder.getFile('myFile.txt');

  // create
  file.writeText('hello world')
    .then(result => { })
	.catch(ex => {
        console.log(ex);
    });

  // read
  file.readText()
    .then(result => { });
	.catch(ex => {
        console.log(ex);
    }

  // remove
  file.remove()
    .then(result => { })
	.catch(ex => {
        console.log(ex);
    });
  
  // get file path
  var filePath = fileSystemModule.path.join(documents.path, 'myFiles', 'myFile.txt'); 

- trace
  path: 'timer'

  source:
  https://docs.nativescript.org/api-reference/modules/_trace_

  about:
  for debugging purposes, a diagnostic information log about the application in runtime 

- xml parser
  path: 'xml'

  source:
  https://docs.nativescript.org/api-reference/modules/_xml_

  about:
  allows us to parse data from an XML content

  parser:
  XmlParser([onSuccess], [onError])

  methods (parser):
  parse([sXML: string])

  using:
  const xmlModule = require("tns-core-modules/xml");

  var xmlParser = new xmlModule.XmlParser(event => { }, ex => { });

  xmlParser.parse('
  	<root>
  		<Node1 attr1="" attr2="">...</Node1>
  		<Node2>...</Node2>			
  	</root>
  ');

  
- timer
  path: 'timer'

  source:
  https://docs.nativescript.org/api-reference/modules/_timer_

  about:
  the nativescript's implementation of the javascript functionality 
 
  methods:
  setTimeout([function], [interval])  
  setInterval([function], [interval])  // returns a timer id
  clearInterval([id: int])  

  interval parameter:
  in milliseconds, 1000 equals to 1 second

  sample:
  const timerModule = require("tns-core-modules/timer");

  viewModel.rndNumber = 0;
  var timerId = timerModule.setInterval(() => {
  	var num = Math.floor(Math.random() * 10000);
    	viewModel.set('rndNumber', num);
  }, 1000);
  
  viewModel.status = 'working.......';
  timerModule.setTimeout(() => {
  	viewModel.set('status', 'done!');
  	timerModule.clearInterval(timerId); 
  }, 5000);

- frame
  path: 'ui/frame'

  about:
  allows us to navigate between frames and use UI frames

  methods:
  <frame> frameModule.topmost() 
  <frame> frameModule.getFrameById(id: string)

  <frame>.navigate(options: object);
  <frame>.navigate(moduleName: string);
  <frame>.goBack();

  options:
  moduleName // the page to redirect to
  context    // the request context

  note! 
  to get the context use the page.navigationContext property 
  see 'Page/navigatingTo event'

  utilities.goToPage:
  var frame = frameName ? frameModule.getFrameById(frameName) : frameModule.topmost();
  frame.navigate(path);

  e.g: // redirect to about-page
  var frameModule = require("ui/frame");
  var options={
    moduleName:'Pages/About/about-page',
    context:{param1: 'value1', param2: 'value2' }
  }
  frameModule.topmost().navigate(options); 

  UI:
  <Page xmlns="http://schemas.nativescript.org/tns.xsd" navigatingTo="onNavigatingTo" class="page">  
    <Page.actionBar>
        <ActionBar title="Frames" icon="" class="action-bar" />        
    </Page.actionBar>
    
    <GridLayout columns="*,*" rows="*,*">
        <Frame defaultPage="Pages/FanApp/fan-page" row="0" col="0"></Frame>
        <Frame defaultPage="Pages/Calendar/calendar-page" row="0" col="1"></Frame>
        <Frame defaultPage="Pages/Fonts/fonts-page" row="1" colSpan="2"></Frame>
    </GridLayout>         
  </Page>

- color:
  path: 'color'

  source:
  https://docs.nativescript.org/api-reference/classes/_color_.color

  constructor:
  Color([colorName]);   // e.g: Color('Blue');
  Color([colorCode]);   // e.g: Color('#FF0000');
  Color([colorCode]);   // e.g: Color('#F80');
  Color([alpha], [red], [green], [blue]);   // [ARGB] e.g: Color(100, 255, 100, 100);  
  
  equals:
  let red = new Color("#FF0000");
  let isRed = red.equals(new Color("red"));  

  sample:
  var colorModule = require("color");
  var blueColor = new colorModule.Color("Blue");

- enums
  path: 'ui/enums'

  sample:
  var enums = require("ui/enums");

  component.animate({
        translate: { x:120, y:0 },        
        duration: 1000,
        curve: enums.AnimationCurve.bounce       
    }); 

- animation:
  path: 'ui/animation'

  Animation function:
  Animation([definitions: array], [playSequentially: bool])

  playSequentially parameter:
  determines whether to play the definitions one after the other or all at once.

  sample:
  var animationModule = require("ui/animation");

  var component1 = view.getViewById(_page, 'c1');
  var component2 = view.getViewById(_page, 'c2');
  var component3 = view.getViewById(_page, 'c3');
  
  var definitions = [];
  definitions.push({
  	target: component1,
  	scale: { x: 0.5, y: 0.5 },        
  	duration: 1000        
  });
  
  definitions.push({
  	target: component2,
  	backgroundColor: new colorModule.Color("Purple"),     
  	translate: { x: 0, y: 120 },    
  	duration: 1000        
  });
  
  definitions.push({
  	target: component3,
  	rotate: 360,        
  	duration: 1000       
  });
  
  var animationSet = new animationModule.Animation(definitions);
  animationSet.play();

- fetch
  path: 'fetch'

  about:
  allows GET and POST requests to a remote server
  also see 'http'

  reference:
  https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API

  syntax:
  fetch([url]).then(response => ...).catch(e => ... )  
  fetch([url], [options]).then(response => ...).catch(e => ... )

  note! 
  can add an extra processing layer by adding another 'then' clause

  using:
  // GET as string
  fetch("https://example.com")
  .then(response => response.text())
  .then(responseText => { ... })
  .catch((e) => { });

  // GET as json
  fetch("https://example.com")
  .then(response => response.json())
  .then(responseJson => { ... })
  .catch((e) => { });

  // GET as form data
  fetch("https://example.com")
  .then(response => response.formData())
  .then(responseData => { ... })
  .catch((e) => { });

  // GET as image
  fetch("https://example.com")
  .then(response => response.blob())
  .then(responseData => { ... })
  .catch((e) => { });

  // check status
  fetch("https://example.com")
  .then(response => response.status)
  .then(responseStatus => { ... })
  .catch((e) => { });

  // POST
  var options = {
    method: "POST",
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
		p1: 'value1',
		p2: 'value2'
	})
  }

  fetch("https://example.com", options)
  .then(response => { ...})  
  .catch((e) => { });

  sample:
  var params = [];
  params.push('origin='+fromAddress);
  params.push('destination='+toAddress);
  params.push('mode='+'driving');
  params.push('key='+'AIzaSyBhVm2XXfP9BWKX6oTaBmMEig1Jw1J0m5U');
  
  var query = '?' + params.join('&');
  var endpoint = 'https://maps.googleapis.com/maps/api/directions/json' + query;
  
  fetch(endpoint)
  .then(response => response.json())
  .then(response => {
      console.log(response);
  }).catch(ex => { 
      console.log('ex: ' + ex.message);
  });

- platform
  path: 'platform'
  
  source: 
  https://docs.nativescript.org/api-reference/modules/_platform_

  about:
  allows us to get information about the device 

  properties:
  isAndroid  
  isIOS
  device  // get a Device object represents the connected device   
  screen  // get a Screen object represents the connected device screen  

  device.model
  device.deviceType
  device.os
  device.osVersion
  device.sdkVersion  
  device.language
  device.manufacturer
  device.uuid

  screen.mainScreen.heightDIPs
  screen.mainScreen.heightPixels)
  screen.mainScreen.scale
  screen.mainScreen.widthDIPs
  screen.mainScreen.widthPixels

  sample:
  var platform  = require("tns-core-modules/platform");
  console.log('isAndroid: ' + platform.isAndroid);
  console.log('sdkVersion: ' + platform.device.sdkVersion);

- http
  path: 'http'

  source:
  https://docs.nativescript.org/ns-framework-modules/http
  https://docs.nativescript.org/api-reference/modules/_http_

  about:
  allows GET and POST requests to a remote server
  also see 'JS Modules/fetch'

  methods:
  getString([url]).then([onSuccess], [onError])
  getJSON([url]).then([onSuccess], [onError])
  getImage([url]).then([onSuccess], [onError])
  getFile([url]).then([onSuccess], [onError])
  request([options]).then([onSuccess], [onError])


  using:
  const httpModule = require("http");

  // GET string
  httpModule.getString("http://domain.com").then(response => {
    console.log(response);
  }, (ex) => {
	console.log('ex: ' + ex.message);
  });

  // GET Json
  httpModule.getJSON("http://domain.com/json").then(response => {
    console.log(response);
  }, (ex) => {
	console.log('ex: ' + ex.message);
  });

  // GET an Image
  httpModule.getImage("http://domain.com/test.jpeg").then(response => {
    console.log(response);
  }, (ex) => {
	console.log('ex: ' + ex.message);
  });

  // create a GET request
  var options = {
    url: "http://domain.com",
    method: "GET"
  };

  httpModule.request(options).then(response => {
    console.log(response);
  }, (ex) => {
	console.log('ex: ' + ex.message);
  });

  // create a POST request
  var options = {
    url: "https://httpbin.org/post",
    method: "POST",
    headers: { "Content-Type": "application/json" },
    content: JSON.stringify({
        username: 'user',
        password: 'password'
    })
  };

  httpModule.request(options).then(response => {
    console.log(response);
  }, (ex) => {
	console.log('ex: ' + ex.message);
  });

- image source
  path: 'image-source'

  source:
  https://docs.nativescript.org/api-reference/classes/_image_source_.imagesource

  methods (module):
  fromResource([name: string]) // returns an image
  fromFile([path: string])  // returns an image
  fromBase64([source: string])  // returns an image
  ImageSource() // returns an empty image

  methods (image):
  saveToFile([path: string], [imageType: string], [quality: number])  // returns bool
  saveToFile([path: string], [imageType: string])  // returns bool
  toBase64String([imageType: string])
  fromAsset([asset]).then([callback])  // async load from an asset

  imageTypes:
  png
  jpeg 
  jpg

  using:
  const imageSourceModule = require("tns-core-modules/image-source");

  // load a resource
  var resource = imageSourceModule.fromResource("icon");

  // load a local image file
  let folder = fileSystemModule.knownFolders.currentApp();
  let path = fileSystemModule.path.join(folder.path, "images/logo.png");
  let image = imageSourceModule.fromFile(path);

  // save an image  
  let folder = fileSystemModule.knownFolders.documents();
  let path = fileSystemModule.path.join(folder.path, "1.png");
  let saved = img.saveToFile(path, "png");

- application
  path: 'application'
  
  source:
  https://docs.nativescript.org/api-reference/modules/_application_

  about:
  a reference to the current application

  properties:
  android  // get an Android object
  ios  // get an iOS object

  methods:
  setCssFileName([filePath])  // apply a css file on the application
  getCssFileName // get the application css file 
  getRootView() // return the root view 

  events:
  launchEvent
  suspendEvent
  resumeEvent
  exitEvent
  displayedEvent
  lowMemoryEvent
  orientationChangedEvent
  uncaughtErrorEvent

  register application events:
  on([event], [callback]) // returns listener object
  off([event], [listener])

  register android events:
  android.registerBroadcastReceiver([action], [callback]) // returns a receiver object
  android.unregisterBroadcastReceiver([receiver])

  using:
  var application = require("tns-core-modules/application");
  console.log(application.android);

  samples:

  // check platform
  if (application.android)
    console.log("We are running on Android device!");
  else if (application.ios)
	console.log("We are running on iOS device");   

  ---

  // application event - orientation changed
  orientationChangedListener = applicationModule.on(applicationModule.orientationChangedEvent, (args) => {
    // args.newValue: 'portrait', 'landscape', 'unknown'
    viewModel.set("orientation", args.newValue);
  });

  ---

  // some-page.xml
  const application = require("application");

  var rootView = application.getRootView();
  viewModel.drawer = rootView.getViewById('app-drawer');

  // app-root.xml
  <sd:RadSideDrawer id="app-drawer">
	....
	<Frame defaultPage="some-page.xml"></Frame>
  </sd:RadSideDrawer>

  ---

  // android event - battery changed 
  if (application.android) {    
    receiver = applicationModule.android.registerBroadcastReceiver(android.content.Intent.ACTION_BATTERY_CHANGED, (context, intent) => {
        const level = intent.getIntExtra(android.os.BatteryManager.EXTRA_LEVEL, -1);
        const scale = intent.getIntExtra(android.os.BatteryManager.EXTRA_SCALE, -1);
        const percent = (level / scale) * 100.0;
        viewModel.set("batteryLife", percent.toString());
    });
  }

- application-settings
  path: 'application-settings'
  
  source:
  https://docs.nativescript.org/api-reference/modules/_application_settings_

  about:
  allows us to store and retrieve data from the  device’s local storage.  

  methods:
  setBoolean(string key, bool value)
  getBoolean(string key, bool default)

  setString(string key, string value)  
  getString(string key, bool default)
  getString(string key)

  setNumber(string key, float value)
  getNumber(string key)

  hasKey(string key) // returns true/false whether the ket exists or not
  remove(string key) // removes a key from the storage 
  clear()  // delete all values from the storage 

  using:
  var appSettings = require("application-settings");

  appSettings.setString("username", "roby");
  var username = appSettings.getString("username");

- connectivity
  path: 'connectivity'
  
  source:
  https://docs.nativescript.org/api-reference/modules/_connectivity_

  about:
  allows us to get information about the device connectivity

  connectionType enum:
  none
  wifi
  mobile
  bluetooth
  ethernet

  methods:
  getConnectionType() // returns the connectionType 
  startMonitoring([callback]) // monitor connection changes
  stopMonitoring();

  permissions:
  app/App_Resources/Android/AndroidManifest/xml
  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>

  using:
  const connectivityModule = require("tns-core-modules/connectivity");
  let connectionType = connectivityModule.getConnectionType();
  
  switch (connectionType) {
    case connectivityModule.connectionType.none:        
        console.log("No connection");
        break;
    case connectivityModule.connectionType.wifi:        
        console.log("WiFi connection");
        break;
    case connectivityModule.connectionType.mobile:        
        console.log("Mobile connection");
        break;
    case connectivityModule.connectionType.ethernet:        
        console.log("Ethernet connection");
        break;    
    default:
        break;
  }

  connectivityModule.startMonitoring(newConnectionType => { ... });



- builder
  path: 'ui/builder'
  
  about:
  used to dynamic loading of custom components (also see 'Custom UI Components')

  methods:
  load([options])

  options:
  path: string
  name: string
  attributes: { bindingContext.. }

  sample:
  let builder = require("tns-core-modules/ui/builder");
  let myComponentInstance = builder.load({
        path: "~/components/myControl",
        name: "MyControl",
		attributes: {
            bindingContext: myBindingModel
        }
  });

note!
use the 'require' to import modules (see 'require' chapter in 'Working With Nativescript')

Ng Directives
-------------
//TODO
// https://docs.nativescript.org/angular/ui/ng-ui-widgets/ng-directives

Google Firebase
---------------
about:
// TODO
  
source:
https://github.com/EddyVerbruggen/nativescript-plugin-firebase  	
https://github.com/EddyVerbruggen/nativescript-plugin-firebase-demo
  
blog:
https://firebase.googleblog.com/

firebase console:
https://console.firebase.google.com
  
install:
> tns plugin add nativescript-plugin-firebase
  
configuration:
1. go to firebase console > create an account 
2. Add Project > choose the Project type from the provided list (Auth, Database, Cloud Messaging etc.)
3. Add App (android and/or iOS) > set your app package name (e.g: com.hadeliverim.employee) > Register app
4. download the generated config file/s 
   for ios - file 'GoogleService-Info.plist' > copy it to 'app/App_Resources/iOS/'
   for android - file 'google-services.json' > copy it to 'app/App_Resources/Android/'
5. configure the plugin: 'firebase.nativescript.json' file
   note! defined during the installation process, to re-configure it - delete the file and re-install the plugin OR run an 'npm run config' from within the module (node_modules/nativescript-plugin-firebase)
6. set-up the 'build.gradle' file to use the desired services (located in platforms/android)
   - add 'classpath "com.google.gms:google-services:4.2.0"' as a dependency (buildscript/dependencies)
7. make sure the applicationId is correct in the 'app.gradle' file (located in App_Resources/Android)
8. bootstrap firebase in the 'app.js' before the 'application.run' (see 'bootstrap firebase')   
   
supported services:
AdMob
Analytics
Authentication
Cloud Firestore
Cloud Functions
Cloud Messaging / Non-Firebase Push Messaging
Crash Reporting / Crashlytics
Invites and Dynamic Links
ML Kit
Performance Monitoring
Realtime Database
Remote Config
Storage
  
analytics:
once installed, we'll have analytics about the service and its usage.
note! apply for ANY installed service by firebase!

reference:
see 'firebase Authentication'
see 'firebase Cloud Messaging'
see 'firebase Invites'
see 'firebase Storage'
// TODO

add firebase app:
see 'configuration' steps 3-4

bootstrap firebase:
// app.js
const application = require("application");
const firebase = require("nativescript-plugin-firebase");

firebase.init().then(instance => {
      console.log("firebase.init done");
    },
    error => {
      console.log("firebase.init error: " + error);
    }
);

application.run({ moduleName: "app-root" });

--

- firebase Authentication:

  about:

  videos:
  https://www.youtube.com/watch?list=PLl-K7zZEsYLmOF_07IayrTntevxtbUxDL&time_continue=34&v=8sGY55yxicA

  enable/disable providers:
  in the firebase console > Authentication > Sign-in method > enable/disable provider

  add authorised domain:
  in the firebase console > Authentication > Sign-in method > authorised domains

  // TODO

--

- firebase Cloud Messaging (FCM):

  about:
  allows us to send messages to the users via a backend server, 
  supports individuals users, groups and topics. 

  videos:
  https://www.youtube.com/watch?time_continue=10&v=sioEY4tWmLI

  method:
  Promise getCurrentPushToken() 
  Promise subscribeToTopic(<topicName: string>)
  Promise unsubscribeFromTopic(<topicName: string>)

  events:
  onMessageReceivedCallback(<callback: message>); // app init
  addOnMessageReceivedCallback(<callback: message>) // firebase objet

  onPushTokenReceivedCallback(<callback: token>) // app init
  addOnPushTokenReceivedCallback(<callback: token>) // firebase objet

  properties:
  showNotifications: bool
  showNotificationsWhenInForeground: bool

  require:
  const firebase = require("nativescript-plugin-firebase");

  device token:
  each device gets a unique token generated by the firebase service. use that token to identify that device.  
  we can add a mapping table in our storage with user-token values.
  note that if a device serves more then one user - we'll still get the same token (which refers to the device+app) so we'll need an extra logic to support that case.
  
  a token refreshes in the following cases
  1. app deletes instanceId
  2. app is restored on a new device 
  3. user install/ uninstall the app
  4. user clear app data

  use 'getCurrentPushToken' method to get the device token.

  // sample token 
  fG_FDIHUR70:APA91bF2B5ItgWZqaStDYYlLHhMlD5VYFbQ9saSjjIVWfmNzR6yX5NRYcMmyQElC6x-G0yGBHlzXFNWsHSahJSLaWqKa1PB_-IF6pWGL6flG3BLWWuQ1CCwMVQ6cR0iq9qG2P3Ei_y5q

  topics:
  // TODO about + how to create + register device to topic

  groups:
  // TODO about + how to create + register device to topic

  on message received:
  when a new message arrives: 
  if the app is in the foreground - firebase will ONLY execute the onMessageReceivedCallback.
  if it in the background - firebase will show a tray notification which will route the user to our app and perform the onMessageReceivedCallback once he click on it! 
  in addition, a property named 'foreground' (which represents the app state) will be added to the payload. 
  tip: when app in foreground, we can use local notifications.

  init:
  // app.js 
  // hook-up to the MessageReceived event
  firebase.init({
    onMessageReceivedCallback: message => {
        console.log(message);      	
    }}).then(() => {
      console.log("firebase.init done");
    },
    error => {
      console.log("firebase.init error: " + error);
    }
  );

  // get device token
  firebase.getCurrentPushToken().then(token => {
    console.log(token);
  });

  send notification from firebase console:
  can be used for testing, remarketing, reminders promotion etc.

  (steps)
  1. open firebase console > (tab) cloud messaging 
  2. new notification 
  3. set notification data > next
     note! can choose a specific device by it's token
  4. set target app/ topic > next 
  5. schedule it > next 
  6. review > send 

  tip! 
  an FCM benchmark is available to track all your defined messages metrics (sends, opens, conversions and more ...)

  tests:
  use the firebase console to send test messages.
  see 'send notification from firebase console' 

  api: 
  to send messages to the server, we need to use firebase REST service. 

  reference
  https://firebase.google.com/docs/cloud-messaging/http-server-ref
  https://firebase.google.com/docs/cloud-messaging/send-message

  ServerKey:
  firebase console > Project Settings > (tab) Cloud Messaging > Server key

  properties:
  - to: string  // a device-token, a group key or a single topic (prefixed with /topics/)
  - registration_ids: [string]  // device-token list for sending message to multiple devices at once
  - condition: string  // condition to determine the message target/s (e.g: topicA && topicB) 
  - priority: string  // normal or high
  - dry_run: bool  // test mode - create a request without delivering the message
  - data: object  // a custom key-value pair object to include within the payload ( e.g: { "p1":"v1", "p2":"v2" })
  - notification: object  // see 'notification object'

  notification object:
  - title: string  
  - body: string
  - sound: string  // the sound of the notification (supports: default)
  - icon: string  // icon file name
  - click_action: string  // action name
  - color: string  // icon color (#rrggbb format)
  - tag: string  // use it to update an existing notification with the same tag

  using:
  POST https://fcm.googleapis.com/fcm/send
  Content-type: application/json
  Authorization: key=<ServerKey>
  <body>

  // sample payload (body)
  { 
      "notification": {
			"title": "My title", 
			"text": "My text", 
			"badge": "1", 
			"sound": "default"
       }, 
       "data":{
			"p1":"v1",
			"p2":"v2"
        }, 
       "priority": "High", 
       "to": "fG_FDIHUR70:APA91bF2B5ItgWZqaS.."
	}

-- 

- firebase Invites

  about:
  an easy way to share content from our app. 
  it also supports referral codes (refer a friend).

  videos:
  https://www.youtube.com/watch?v=LkaIJCZ_HyM&list=PLl-K7zZEsYLmOF_07IayrTntevxtbUxDL

--

- firebase Storage

  about:
  // TODO


Plugins
-------

- nativescript-explosionfield

  about:
  makes things explode

  source: 
  https://market.nativescript.org/plugins/nativescript-explosionfield

  install:
  tns plugin add nativescript-explosionfield

  methods:
  explode(<view>);  // a view can be button, label etc.

  using:
  <Button text="Boom" tap="onBoomTap" />

  var explosion = require("nativescript-explosionfield");
  viewModel.onBoomTap = args => {        
    explosion.explode(args.object);
  }

- nativescript-insomnia

  about:
  keep the device awake.

  source: 
  https://github.com/EddyVerbruggen/nativescript-insomnia

  install:
  tns plugin add nativescript-insomnia

  methods:
  keepAwake
  allowSleepAgain

  using:
  var insomnia = require("nativescript-insomnia");

  insomnia.keepAwake().then(() => { ... })

- nativescript-fancyalert
  
  about: 
  fancy alerts 

  source:
  https://github.com/NathanWalker/nativescript-fancyalert

  install:
  tns plugin add nativescript-fancyalert


- nativescript-phone
  
  about:
  use the device phone and SMS

  source:
  https://github.com/msywensky/nativescript-phone

  install:
  tns plugin add nativescript-phone

  permissions:
  // android > AndroidManifest.xml
  <uses-permission android:name="android.permission.CALL_PHONE" />

  // iOS > Info.plist
  <key>LSApplicationQueriesSchemes</key>
  <array>
     <string>tel</string>
     <string>telprompt</string>
  </array>

  methods:
  dial(telNum: string, prompt: bool) 
  sms(telNum: string], messageText: string)  // (promise) single number
  sms(telNums: [string], messageText: string)  // (promise) multiple numbers
  requestCallPermission(message: string) // (promise)

  prompt argument: 
  specifies if a confirmation prompt is required

  request permissions:  
  // structure
  requestCallPermission(message: string)
	.then(success: function)
	.catch(error: function);

  // e.g
  phoneModule.requestCallPermission('need permissions')
      .then(() => phoneModule.dial(number, false))
      .catch(() => console.log('no permissions!'));

  using:
  <Button text="Call" class="text-center" number="054-5614020" tap="{{ onCall }}" flexGrow="1" />           
  <Button text="SMS" class="text-center" number="054-5614020" tap="{{ onSMS }}" flexGrow="1" />

  viewModel.onCall = args => {
        var number = args.object.number;
        console.log('calling ' + number);
        phoneModule.dial(number,false);
    };

    viewModel.onSMS = args => {
        var number = args.object.number;
        console.log('SMSing ' + number);
        phoneModule.sms(number,'Hello World!').then(
            response => { console.log('message sent'); }, 
            err => {}
        );
    };

- google-firebase
  see 'Google Firebase'
  
- nativescript-filter-select

  about:
  listview widget to select AND filter items.

  source:
  https://github.com/moayadnajd/nativescript-filter-select
  https://www.nsplugins.com/plugin/nativescript-filter-select

  install:
  > tns plugin add nativescript-filter-select

  implementation:
  1. add namespace to the Page tag
     <Page xmlns:FS="nativescript-filter-select">

  2. create an instance of the component 
     <FS:FilterSelect ..... />

  3. import the css 
     @import 'nativescript-filter-select/styles.css';

  options:
  render: string ('tags', 'label', 'drop')  // items render mode
  multiple: bool   
  search_param: string  // item-text
  primary_key: string  // item-value
  item_template: string  // sXML template   
  modal_title: string
  hint: string 
  items: []  
  selected: []   // items to mark as selected
  disabled: bool
  allowSearch: bool
  searchHint: string
  xbtn: string // text for the remove-tag action
  closeText: string 
  doneText: string 
  clearText: string 
  selectText: string 
    
  events:
  change // on Change/ Select 
  close  // on Modal Closed	

  methods:
  open  // open modal
  refresh // to refresh the item

  using:  
  <FS:FilterSelect class="m-20"
        items="{{ countries }}" 
        change="{{ onCountriesSelected }}"
        hint="select countries" 
        modal_title="Countries" 
        search_param="name" 
        primary_key="id" 
        item_template="{{ countryItemTemplate }}"
    />
  
  viewModel.countries = [
        { id: 1, name: 'Austria' }, 
        { id: 2, name: 'Belgium' }, 
        { id: 3, name: 'Cyprus' }, 
        { id: 4, name: 'Israel' },         
        { id: 5, name: 'Spain' }, 
        { id: 6, name: 'Sweden' }
  ];  

  viewModel.onCountriesSelected = (args) => {
        console.log('onCountriesSelected');
  };
  viewModel.countryItemTemplate = "<Label text=\"{{ name }}\" />";

- nativescript-drop-down

  source:
  https://github.com/PeterStaev/NativeScript-Drop-Down
  https://www.npmjs.com/package/nativescript-drop-down

  install:
  > tns plugin add nativescript-drop-down

  namespace:
  xmlns:DDL="nativescript-drop-down"

  implementation:
  1. add namespace to the Page tag
     <Page xmlns:DDL="nativescript-drop-down">

  2. create an instance of the component 
     <DDL:DropDown ..... />

  options:
  items: [string] OR ValueList
  selectedIndex: number 
  hint: string  
  isEnabled: bool 

  events:
  opened
  closed
  selectedIndexChanged

  selectedIndexChanged args:
  newIndex
  oldIndex

  methods:
  open
  close

  classes:
  ValueList([{value, display}]);
  ValueList(); 

  note!
  * array-type object, use push to add items, use length to get the items quantity.
  * use getIndex([value]) or getValue([index]) or getItem([index]) to pull data from it.
  * use selectedIndex = null for reset.
	
  using:
  <DDL:DropDown class="m-20"                 
		items="{{ colors }}" 
		selectedIndexChanged="{{ onColorSelected }}"
		selectedIndex="{{ selectedIndex }}"
   />

   viewModel.colors = ['blue', 'red', 'purple', 'green', 'brown', 'black', 'yellow', 'pink'];
   viewModel.onColorSelected = (args) => {
        console.log('onColorSelected');
   };

   --

   // using key-value pair
   var DropDown = require('nativescript-drop-down');

   viewModel.colors = new DropDown.ValueList([
	 { display: 'blue', value: '1' },
	 { display: 'red', value: '2' },
	 { display: 'purple', value: '3' },
	 { display: 'green', value: '4' },
	 { display: 'brown', value: '5' },
	 { display: 'black', value: '6' },
	 { display: 'yellow', value: '7' }
   ]);


- RadAutoCompleteTextView 

  source:  
  http://docs.telerik.com/devtools/nativescript-ui/Controls/NativeScript/AutoCompleteTextView/overview
  https://www.nativescript.org/blog/a-deep-dive-into-telerik-ui-for-nativescripts-autocompletetextview
  https://github.com/rdlauer/ui-for-nativescript-autocompletetextview

  install:
  tns plugin add nativescript-ui-autocomplete

  namespace:
  xmlns:au="nativescript-ui-autocomplete"

  structure:
  - RadAutoCompleteTextView
	- RadAutoCompleteTextView.suggestionView  // a placeholder for autocomplete suggestions
		- SuggestionView

  select an item:
  use the 'space' key to select an item

  options:
  suggestMode  // see 'suggest Modes'
  displayMode  // see 'display Modes'
  noResultsText // text for no result

  suggest Modes:
  Append		  // inline display
  Suggest         // drop-down list of options
  SuggestAppend   // combines both Append and Suggest

  display Modes:
  Plain    // single selection
  Tokens   // multiple selections

  TokenModel class:
  used for adding items to the autocomplete list.
  TokenModel(text: string, image: string)

  // e.g
  var TokenModel = require("nativescript-ui-autocomplete").TokenModel;
  var colors = new ObservableArray();
  colors.push(new TokenModel('blue'));
  colors.push(new TokenModel('purple'));
  ...

  using:

  // view-model
  var ObservableArray = require("data/observable-array").ObservableArray;
  var TokenModel = require("nativescript-ui-autocomplete").TokenModel;

  viewModel.colors = ['blue', 'red', 'purple', 'green', 'brown', 'black', 'yellow', 'pink'];

  viewModel.colorsForAutoComplete = new ObservableArray();
  viewModel.colors.forEach(color => {
      viewModel.colorsForAutoComplete.push(new TokenModel(color));     
  });

  // UI
  <AC:RadAutoCompleteTextView items="{{ colorsForAutoComplete }}" suggestMode="Append" displayMode="Token">
        <AC:RadAutoCompleteTextView.suggestionView>
            <AC:SuggestionView suggestionViewHeight="200">
                <AC:SuggestionView.suggestionItemTemplate>
                    <StackLayout>
                        <Label text="{{ text }}" />
                    </StackLayout>
                </AC:SuggestionView.suggestionItemTemplate> 
            </AC:SuggestionView>
        </AC:RadAutoCompleteTextView.suggestionView>
   </AC:RadAutoCompleteTextView>



- RadDataForm 

  about:
  convert any object to a UI form!

  source:  
  http://docs.telerik.com/devtools/nativescript-ui/Controls/NativeScript/DataForm/dataform-overview
  https://www.nativescript.org/blog/a-deep-dive-into-telerik-ui-for-nativescripts-dataform
  https://github.com/rdlauer/ui-for-nativescript-dataform
  https://github.com/telerik/nativescript-ui-samples

  install:
  tns plugin add nativescript-ui-dataform

  namespace:
  xmlns:df="nativescript-ui-dataform"

  structure:
  - RadDataForm 
	- groups  // see 'Grouping'
	  - PropertyGroup
		- properties
		  - EntityProperty
			- editor
			  - PropertyEditor  // see 'PropertyEditor'
				- params
				  - PropertyEditorParams  // see 'PropertyEditorParams class'
			- validators
			  - [validator] // see 'validator types'


  options:	
  source: object

  events:
  propertyCommit
  propertyCommitted
  propertyValidate
  propertyValidated

  EntityProperty class:
  name: string			// the object property name
  displayName: string   // a new name to display
  index: int			// the index to show in the form  
  readOnly: bool	    // set the property readonly state
  hintText: string		// html5 placeholder
  required: bool		// validations, set the property is-required state
  validators			// validators
  hidden: bool			// hidden field

  PropertyEditor:
  optional
  if needed we can change the default property editor, 
  replace the textbox mode with slider for numeric range etc.

  structure
  <df:EntityProperty name="[propertyName]" displayName="[displayName]" index="[presentedIndex]">
    <df:EntityProperty.editor>
        <df:PropertyEditor type="[editorType]">  // see 'PropertyEditor types'
			<df:PropertyEditor.params>
                <df:PropertyEditorParams [properties] />
            </df:PropertyEditor.params>
		</df:PropertyEditor>
    </df:EntityProperty.editor>
  </df:EntityProperty>

  // textbox to slider 
  // change the 'someRangeProperty' object property to use a slider from 0 to 10
  <df:EntityProperty name="someRangeProperty" displayName="My Range" index="3">
    <df:EntityProperty.editor>
        <df:PropertyEditor type="Slider">
            <df:PropertyEditor.params>
                <df:PropertyEditorParams minimum="0" maximum="10" />
            </df:PropertyEditor.params>
        </df:PropertyEditor>
    </df:EntityProperty.editor>
  </df:EntityProperty>

  // textbox to numeric control
  // change the 'someNumericProperty' object property to use a numeric control
  <df:EntityProperty name="someNumericProperty" displayName="Year" index="4">
    <df:EntityProperty.editor>
        <df:PropertyEditor type="Number" />
    </df:EntityProperty.editor>
  </df:EntityProperty>

  PropertyEditorParams class:
  maximum
  minimum
  step

  PropertyEditor types:
  http://docs.telerik.com/devtools/nativescript-ui/Controls/NativeScript/DataForm/Editors/dataform-editors-list#complete-list
  https://docs.telerik.com/devtools/nativescript-ui/api/enums/editortype.html
  https://docs.nativescript.org/ui/professional-ui-components/DataForm/Editors/dataform-editors-list
  https://docs.nativescript.org/ui/professional-ui-components/DataForm/Editors/dataform-editors-providers  
  https://github.com/NativeScript/nativescript-ui-samples/tree/master/dataform/app/examples
  https://github.com/NativeScript/nativescript-ui-samples/tree/master/dataform/app/examples/layouts

  Text
  MultilineText
  Email
  Password
  Phone
  Number
  Decimal
  Switch
  Stepper				// choosing a number by tapping on buttons to increase or decrease it.
  Slider
  Picker				// picking a value from a predefined list (drop-down list). 
  SegmentedEditor		// picking a value from a predefined list (horizontal list).
  List					// picking a value from a predefined list (vertical list).
  DatePicker			// picking a date from a calendar.
  TimePicker			// picking a time from a clock.
  AutoCompleteInline	// picking single or multiple items from a suggestion list.
  Label
  Custom				// use 'editorNeedsView', 'editorHasToApplyValue' and 'editorHasToApplyValue' events to create your own custom editor

  Validators:
  use this feature to validate the properties input, use the property required flag to mark it for validation
  and choose the validator type to apply (see 'validator types')

  options
  validationMode: string  // see 'validation modes'

  validator types:
  NonEmptyValidatorco
  RangeValidator: { minimum, maximum ... }
  MinimumLengthValidator: { length ... }
  MaximumLengthValidator: { length ... }
  EmailValidator:
  PhoneValidator:
  IsTrueValidator:
  RegExValidator: { regEx ... }
  Custom

  validation modes:
  Immediate
  OnLostFocus
  Manual

  form functions:
  hasValidationErrors();
  validateAll()
  notifyValidated(<fieldName: string>, <state: bool>);
  commitAll();

  complex objects:
  not supported in complex objects, we have to normalize inner objects 
  { id, name, subItem: { id, name } } => { id, name, subItem_id, subItem_name }

  multiple forms trick:
  // TODO ->> wrap with StackLayout and set visibility property


  structure
  <df:EntityProperty name="[propertyName]" .....>
    <df:EntityProperty.validators>
        [validator]
		....
    </df:EntityProperty.validators>
  </df:EntityProperty>

  // text length validators
  <df:EntityProperty name="year" displayName="Release Year" index="2">
    <df:EntityProperty.validators>
        <df:MinimumLengthValidator 
            errorMessage="Year must be at least 4 digits!" 
            length="4" />
        <df:MaximumLengthValidator 
            errorMessage="Year cannot be more than 4 digits!" 
            length="4" /> 
    </df:EntityProperty.validators>
  </df:EntityProperty>

  Grouping:
  optional
  use this feature if a needed to group some form elements (similar to a collapsible content),
  useful for reducing presented length of long forms.

  PropertyGroup options
  collapsed: bool
  collapsible: bool
  hidden: bool
  name: string
  titleHidden: bool
  titleStyle: GroupTitleStyle  // collapsible title style
  properties: [EntityProperty]

  structure
  <df:RadDataForm.groups>
        <df:PropertyGroup collapsible="[bool]" name="[groupTitle]">
            <df:PropertyGroup.properties>
                [EntityProperty]
				[EntityProperty]
				...
            </df:PropertyGroup.properties>
        </df:PropertyGroup>
        ...
		...
  </df:RadDataForm.groups>

  Group Layouts
  1. Stack (default)
  2. Grid

  Groups Sort
  RadForm uses the elements 'index' property to locate them in the screen, use the 'EntityProperty' index property 
  to define the elements order.
  note that when using groups, we still have to set the elements index accordingly. 
  tip - use bigger index per group (e.g: groupA will use indexes 1-10, groupB indexes 10-20 etc.)

  update a model:
  to update a rad-form model, we have to use the viewmodel.set method on the updated model and then reload the form. 
  
  //example
  const temp = { ...viewModel.formModel, title: 'Hi there' };
  viewModel.set('formModel', temp);
  viewModel.dataForm.reload();

  note
  to get the edited-model we can use the 'editedObject' property of the rad-form

  // example
  let temp = JSON.parse(viewModel.formModel.editedObject);
  viewModel.set('formModel', temp);

  using:
    
  viewModel.album = {
        bandName: "Pink Floyd",
        albumName: "The Dark Side of the Moon",
        year: "1973",
        owned: true,
        myRating: 9
  };

  // basic
  <df:RadDataForm source="{{ album }}" />

  --

  // with properties
  <df:RadDataForm id="myDataForm" source="{{ album }}">
        <df:RadDataForm.properties>
            <df:EntityProperty name="albumName" displayName="Name of Album" index="0" />
            <df:EntityProperty name="bandName" displayName="Name of Band" index="1" />

            <df:EntityProperty name="year" displayName="Release Year" index="2">
                <df:EntityProperty.editor>
                    <df:PropertyEditor type="Number" />
                </df:EntityProperty.editor>
            </df:EntityProperty>    

            <df:EntityProperty name="myRating" displayName="My Rating" index="3">
                <df:EntityProperty.editor>
                    <df:PropertyEditor type="Slider">
                        <df:PropertyEditor.params>
                            <df:PropertyEditorParams minimum="0" maximum="10" />
                        </df:PropertyEditor.params>
                    </df:PropertyEditor>
                </df:EntityProperty.editor>
            </df:EntityProperty>
            
            <df:EntityProperty name="owned" displayName="Do I Own This?" index="4" />
        </df:RadDataForm.properties>
    </df:RadDataForm>

	--

	// using grouping
	<df:RadDataForm id="myDataForm" source="{{ album }}">
        <df:RadDataForm.groups>

            <df:PropertyGroup collapsible="false" name="basic details">
                <df:RadDataForm.properties>
                    <df:EntityProperty name="albumName" displayName="Name of Album" index="0" />
                    <df:EntityProperty name="bandName" displayName="Name of Band" index="1" />                
                </df:RadDataForm.properties>
            </df:PropertyGroup>

            <df:PropertyGroup collapsible="true" name="extra details" collapsed="true">
                <df:RadDataForm.properties>
                    <df:EntityProperty name="year" displayName="Release Year" index="2">
                        <df:EntityProperty.editor>
                            <df:PropertyEditor type="Number" />
                        </df:EntityProperty.editor>
                    </df:EntityProperty>    

                    <df:EntityProperty name="myRating" displayName="My Rating" index="3">
                        <df:EntityProperty.editor>
                            <df:PropertyEditor type="Slider">
                                <df:PropertyEditor.params>
                                    <df:PropertyEditorParams minimum="0" maximum="10" />
                                </df:PropertyEditor.params>
                            </df:PropertyEditor>
                        </df:EntityProperty.editor>
                    </df:EntityProperty>
                    
                    <df:EntityProperty name="owned" displayName="Do I Own This?" index="4" />
                </df:RadDataForm.properties>
            </df:PropertyGroup>

        </df:RadDataForm.groups>
    </df:RadDataForm>

	-- 

	// with validators
	<df:RadDataForm id="myDataForm" source="{{ album }}">
        <df:RadDataForm.groups>

            <df:PropertyGroup collapsible="false" name="basic details">
                <df:RadDataForm.properties>
                    <df:EntityProperty name="albumName" displayName="Name of Album" index="0">
                        <df:EntityProperty.validators>                            
                            <df:NonEmptyValidator errorMessage="required" />
                        </df:EntityProperty.validators>
                    </df:EntityProperty>
                    <df:EntityProperty name="bandName" displayName="Name of Band" index="1">
                        <df:EntityProperty.validators>
                            <df:MinimumLengthValidator length="3" errorMessage="invalid length"  />
                        </df:EntityProperty.validators>
                    </df:EntityProperty>                
                </df:RadDataForm.properties>
            </df:PropertyGroup> 

            <df:PropertyGroup collapsible="true" name="extra details" collapsed="true">
                <df:RadDataForm.properties>
                    <df:EntityProperty name="year" displayName="Release Year" index="2">
                        <df:EntityProperty.editor>
                            <df:PropertyEditor type="Number" />
                        </df:EntityProperty.editor>
                        <df:EntityProperty.validators>                            
                            <df:RangeValidator minimum="1970" maximum="2020" errorMessage="invalid year" />
                        </df:EntityProperty.validators>
                    </df:EntityProperty>    

                    <df:EntityProperty name="myRating" displayName="My Rating" index="3">
                        <df:EntityProperty.editor>
                            <df:PropertyEditor type="Slider">
                                <df:PropertyEditor.params>
                                    <df:PropertyEditorParams minimum="0" maximum="10" />
                                </df:PropertyEditor.params>
                            </df:PropertyEditor>
                        </df:EntityProperty.editor>
                    </df:EntityProperty>
                    
                    <df:EntityProperty name="owned" displayName="Do I Own This?" index="4" />
                </df:RadDataForm.properties>
            </df:PropertyGroup>

        </df:RadDataForm.groups>
    </df:RadDataForm>

	-- 

	// with pickers
	<df:EntityProperty name="expiryYear" displayName="תוקף (שנה)" index="1" valuesProvider="2019, 2020, 2021, 2022, 2023, 2024, 2025">
        <df:EntityProperty.validators>
            <df:NonEmptyValidator errorMessage="שדה חובה" />                                             
        </df:EntityProperty.validators>
        <df:EntityProperty.editor>
            <df:PropertyEditor type="Picker" />
        </df:EntityProperty.editor>
    </df:EntityProperty>

    <df:EntityProperty name="expiryMonth" displayName="תוקף (חודש)" index="2" valuesProvider="01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12">
        <df:EntityProperty.validators>
            <df:NonEmptyValidator errorMessage="שדה חובה" />                     
        </df:EntityProperty.validators>
        <df:EntityProperty.editor>
            <df:PropertyEditor type="Picker" />
        </df:EntityProperty.editor>
    </df:EntityProperty>

	--

	// with vm provider
	viewModel.citiesProvider = new Map([
		[1121, "Shanghai"],
		[3651, "Lagos"],
		[5213, "Moscow"],		
		[6985, "Sydney"]
	]);

	<df:EntityProperty name="expiryYear" displayName="עיר" valuesProvider="{{ citiesProvider }}">       
        <df:EntityProperty.editor>
            <df:PropertyEditor type="Picker" />
        </df:EntityProperty.editor>
    </df:EntityProperty>

	--

	// custom editor
	viewModel.onGetEditorView = args => {
        // fromClient, toClient
        let target = console.log(args.object.target); 
        const editorView = new android.widget.Button(args.context);
        editorView.setText('מצא כתובת');
        editorView.setOnClickListener(new android.view.View.OnClickListener({
            onClick(view) { ... }
        }));
        args.view = editorView;
    }

	<df:EntityProperty name="fromClient_address" displayName="כתובת איסוף" index="2" columnIndex="1">
        <df:EntityProperty.editor>
            <df:CustomPropertyEditor editorNeedsView="{{ onGetEditorView }}" target="fromClient" />
        </df:EntityProperty.editor>
    </df:EntityProperty>

	-- 

	// group style 
	<df:PropertyGroup collapsible="true" collapsed="false" name="פרטי נמען">
        <df:PropertyGroup.titleStyle>
            <df:GroupTitleStyle fillColor="#00695c" labelTextSize="15" ios:labelFontName="Times New Roman" android:labelFontName="sans-serif" labelFontStyle="Bold" labelTextColor="White"/>
        </df:PropertyGroup.titleStyle>
		...
		...
	</df:PropertyGroup>

	--

	// update form data
	viewModel.onPropertyCommitted = args => {
        /// console.log(args.propertyName);        
		/// console.log(args.entityProperty.editor.type); 

        ///viewModel.set('deliveryModel', JSON.parse(args.object.editedObject));        

        let temp = JSON.parse(viewModel.deliveryForm.editedObject);
        viewModel.set('deliveryModel', temp);
    };

	<df:RadDataForm id="deliveryForm" source="{{ deliveryModel }}" propertyCommitted="{{ onPropertyCommitted }}">
		...
		...
	</df:RadDataForm>

	important!
	to update the form content from outside the form we need to follow those steps:
	1. update the 'editedObject' form object 
	2. update the source object using the updated 'editedObject' form object

	e.g:
	let deliveryForm = view.getViewById(page, 'deliveryForm');

	let temp = JSON.parse(deliveryForm.editedObject);
	temp.fromClient_address = result.address;
	temp.fromClient_coordinates = result.coordinates;      
    viewModel.set('deliveryModel', temp);  

- RadListView
 
  source:  
  http://docs.telerik.com/devtools/nativescript-ui/Controls/NativeScript/ListView/overview
  https://github.com/rdlauer/ui-for-nativescript-listview
  https://www.nativescript.org/blog/a-deep-dive-into-telerik-ui-for-nativescripts-listview
  https://github.com/telerik/nativescript-ui-samples/tree/master/listview/app/examples

  install:
  > tns plugin add nativescript-ui-listview

  namespace:
  xmlns:lv="nativescript-ui-listview"

  structure:
  - RadListView 
	  - listViewLayout
		- ListViewGridLayoutitemTemplate
		- ListViewStaggeredLayout
		- ListViewLinearLayout
	  - itemTemplate
	  - itemSwipeTemplate
	  - headerItemTemplate
	  - footerItemTemplate

  options (ListViewLayout):
  scrollDirection: string // Vertical or Horizontal 
  itemHeight: int
  spanCount: int
  itemInsertAnimation: string // animation type - see 'animations'

  options (RadListView):
  items: [object]  // ANY object!! 
  pullToRefresh: bool  // determine whether or not to enable the pull-to-refresh feature
  pullToRefreshInitiated: function // function to execute once pulled to refresh
  swipeActions: bool  // determine whether or not to enable swipe actions
  itemSwipeTemplate: template  // template which will be presented once the user swipe a list item

  swipe:
  set swipeActions to 'true' and define the itemSwipeTemplate to show once an item is swiped 
  use the tap event for 'onLeftSwipe' and 'onRightSwipe' events

  <lv:RadListView items="{{ items }}" swipeActions="true">
	  <lv:RadListView.itemSwipeTemplate>
		...
		...
	  </lv:RadListView.itemSwipeTemplate>
  </lv:RadListView>

  pull to refresh:
  set pullToRefresh to 'true' and set the pullToRefreshInitiated to the function to call once a user pulled-down to refresh
  we must call the 'notifyPullToRefreshFinished' listview function to signal the view that the refreash process is completed 

  <lv:RadListView items="{{ items }}" pullToRefresh="true" pullToRefreshInitiated="{{ onPullToRefresh }}">
		...
		...
  </lv:RadListView>

  animations:
  Default 
  Fade
  Scale
  Slide

  using structure:

  // UI
  <Page class="page"
		navigatingTo="onNavigatingTo"  
		xmlns="http://schemas.nativescript.org/tns.xsd"
		xmlns:lv="nativescript-ui-listview"	
		actionBarHidden="true">

		<lv:RadListView id="listview1" items="{{ items }}" class="mt-20"
			pullToRefresh="true" pullToRefreshInitiated="{{ onPullToRefresh }}" swipeActions="false">
			<lv:RadListView.listViewLayout>
				<lv:ListViewLinearLayout scrollDirection="Vertical" itemInsertAnimation="Slide" />
			</lv:RadListView.listViewLayout>
			<lv:RadListView.itemTemplate>
				...
			</lv:RadListView.itemTemplate>        
		</lv:RadListView>
  </Page>

  // JS
  function onNavigatingTo(args) {
    let page = args.object;    
    page.bindingContext = new PageViewModel(page);
  }
  exports.onNavigatingTo = onNavigatingTo;

  // JS view-model
  var Observable = require("data/observable").Observable;
  var ObservableArray  = require("data/observable-array").ObservableArray;
  var utilities = require("~/Services/utilities");
  var view = require("ui/core/view");

  function PageViewModel(page) {
    var viewModel = new Observable();   

    viewModel.listview = view.getViewById(page, 'listview1');
    viewModel.items = new ObservableArray(loadItems()); 

    viewModel.onPullToRefresh = args => {                  
        viewModel.set('items',loadItems()); 

        let listview = viewModel.get('listview');
        listview.notifyPullToRefreshFinished();    
    };

    return viewModel;
  }
  module.exports = PageViewModel;
  
  function loadItems(){ ... }

  --

  using:

  // UI
  <Page xmlns="http://schemas.nativescript.org/tns.xsd" xmlns:lv="nativescript-ui-listview" navigatingTo="onNavigatingTo" class="page">  
    <Page.actionBar>
        <ActionBar title="ListView" icon="" class="action-bar"></ActionBar>
    </Page.actionBar>
            
    <lv:RadListView id="listview1" items="{{ items }}" 
        pullToRefresh="true" pullToRefreshInitiated="{{ onPullToRefresh }}" swipeActions="false">
        <lv:RadListView.listViewLayout>
            <lv:ListViewLinearLayout scrollDirection="Vertical" itemHeight="100" itemInsertAnimation="Slide" />
        </lv:RadListView.listViewLayout>
        <lv:RadListView.itemTemplate>
            <GridLayout rows="auto" columns="auto, *">
                <Image row="0" col="0" src="{{ itemImage }}" class="thumb img-rounded" />
                <StackLayout row="0" col="1" >
                    <Label text="{{ itemName }}" />
                    <Label text="{{ itemDesc }}" />
                </StackLayout> 
            </GridLayout>
        </lv:RadListView.itemTemplate>        
    </lv:RadListView>
  </Page>

  // view-model
  var Observable = require("data/observable").Observable;
  var ObservableArray = require("data/observable-array").ObservableArray;
  var view = require("ui/core/view");

  function createViewModel(page) { 
    var viewModel = new Observable();         
    viewModel.listview = view.getViewById(page, 'listview1');
    viewModel.items = new ObservableArray([        
        { itemName: "brazil", itemDesc: "bla bla bla", itemImage: "~/Pages/ListView/brazil-flag-icon.png" },
        { itemName: "cameroon", itemDesc: "bla bla bla", itemImage: "~/Pages/ListView/cameroon-flag-icon.png" },
        { itemName: "israel", itemDesc: "bla bla bla", itemImage: "~/Pages/ListView/israel-flag-icon.png" },
        { itemName: "cuba", itemDesc: "bla bla bla", itemImage: "~/Pages/ListView/cuba-flag-icon.png" }
    ]);

    viewModel.onPullToRefresh = args => {
        console.log('onPullToRefresh');  

        let temp =  viewModel.get('items');
        temp.push({ itemName: "united-kingdom", itemDesc: "bla bla bla", itemImage: "~/Pages/ListView/united-kingdom-flag-icon.png" })
        viewModel.set('items', temp);

        let listview = viewModel.get('listview');
        listview.notifyPullToRefreshFinished();
    };

    return viewModel;     
  }

  
- RadCharts
  
  source:
  http://docs.telerik.com/devtools/nativescript-ui/Controls/NativeScript/Chart/overview
  https://www.nativescript.org/blog/a-deep-dive-into-telerik-ui-for-nativescript-s-charts

  samples:
  https://github.com/telerik/nativescript-ui-samples/tree/master/chart/app/examples

  install:
  > tns plugin add nativescript-ui-chart

  namespace:
  xmlns:chart="nativescript-ui-chart"

  structure:
  - ChartType  // see 'chartTypes'
	- series   // note! supports multiple!
		- AxisSeries  // see 'axesSeries (RadCartesianChart)'
			- horizontalAxis // Y Axis
				- AxisType   // see 'axisTypes'
			- verticalAxis   // X Axis 
				- AxisType   // see 'axisTypes'

		- AxisSeries (Pie) // see 'axesSeries (RadPieChart)'
	- legend		
		- LegendViews  // see 'legendViews'

  chartTypes:
  - RadCartesianChart  // x,y points based		
  - RadPieChart  // data points based    

  axesSeries:
  see 'axesSeries (RadCartesianChart)'
  see 'axesSeries (RadPieChart)' 

  axesSeries (RadCartesianChart):  
  - AreaSeries
  - BarSeries
  - LineSeries
  - SplineSeries
  - SplineAreaSeries  
  - RangeBarSeries
  - BubbleSeries
  - ScatterBubbleSeries
  - ScatterSeries
  - CandlestickSeries
  - OhlcSeries

  axesSeries (RadPieChart):
  - PieSeries
  - DonutSeries

  axisTypes:
  - CategoricalAxis  // displays the 'category' property value as text 
  - DateTimeCategoricalAxis  // displays the 'category' property value as date 
  - DateTimeContinuousAxis // a hybrid between a categorical and a linear axis
  - LinearAxis  // displays the 'value' property value as data point
  - LogarithmicAxis

  legendViews:
  - RadLegendView

  options (axesSeries): 
  items: [{ object }]   
  valueProperty: string  // item-value
  showLabels: bool
  categoryProperty: string  // item-text
  selectionMode: string // DataPoint|DataPointMultiple|None|NotSet|Series
  outerRadiusFactor: float  // (PieSeries) pie-size (0.8 for 80% etc.)
  legendLabel: string
  bubbleScale: int // (BubbleSeries) the scale of the bubbles
  bubbleSizeProperty: string // the item-property indicates of the bubble relative size

  options (axisTypes): 
  labelFitMode: string   // Multiline|None|Rotate
  labelLayoutMode: string  // Inner|Outer 

  option (RadLegendView):
  position: string // Right|Left|Bottom|Top|Floating
  width: int 

  horizontalAxis & verticalAxis:
  those properties control of the rendered view by specify which 
  axis mode to render on x and y axes. 
  so if we switch between the defined axisType of the horizontalAxis and verticalAxis - we'll get the opposite view!

  // e.g
  <chart:BarSeries.horizontalAxis>
      <chart:CategoricalAxis />
  </chart:BarSeries.horizontalAxis>
  <chart:BarSeries.verticalAxis>
      <chart:LinearAxis />
  </chart:BarSeries.verticalAxis>

  VS

  <chart:BarSeries.horizontalAxis>
      <chart:LinearAxis />  // switched  
  </chart:BarSeries.horizontalAxis>
  <chart:BarSeries.verticalAxis>
      <chart:CategoricalAxis /> // switched 
  </chart:BarSeries.verticalAxis>

  using:

  viewModel.data = [         
        { key: "2017", value: 112, impact: 1 },
        { key: "2016", value: 240, impact: 8 },
        { key: "2015", value: 290, impact: 4 },
        { key: "2014", value: 109, impact: 2 },
        { key: "2013", value: 98, impact: 1 },
        { key: "2012", value: 301, impact: 8 },
        { key: "2011", value: 196, impact: 7 },
        { key: "2010", value: 221, impact: 3 }
    ];

  <chart:RadCartesianChart class="m-t-10" height="350">
        <chart:RadCartesianChart.series>
            <chart:LineSeries items="{{ data }}" categoryProperty="key" valueProperty="value">                
                <chart:LineSeries.horizontalAxis>
                    <chart:CategoricalAxis labelFitMode="Rotate" />
                </chart:LineSeries.horizontalAxis>

                <chart:LineSeries.verticalAxis>
                    <chart:LinearAxis labelLayoutMode="Outer" />
                </chart:LineSeries.verticalAxis>    
            </chart:LineSeries>
        </chart:RadCartesianChart.series>
    </chart:RadCartesianChart>     

    <chart:RadCartesianChart class="m-t-10" height="350">
        <chart:RadCartesianChart.series>
            <chart:BarSeries items="{{ data }}" categoryProperty="key" valueProperty="value">                
                <chart:BarSeries.horizontalAxis>
                    <chart:CategoricalAxis />
                </chart:BarSeries.horizontalAxis>

                <chart:BarSeries.verticalAxis>
                    <chart:LinearAxis />
                </chart:BarSeries.verticalAxis>     
            </chart:BarSeries>
        </chart:RadCartesianChart.series>
    </chart:RadCartesianChart>  

    <chart:RadCartesianChart class="m-t-10" height="350">
        <chart:RadCartesianChart.series>
            <chart:BarSeries items="{{ data }}" categoryProperty="key" valueProperty="value">                
                <chart:BarSeries.horizontalAxis>
                    <chart:LinearAxis />
                </chart:BarSeries.horizontalAxis>

                <chart:BarSeries.verticalAxis>
                    <chart:CategoricalAxis />
                </chart:BarSeries.verticalAxis>     
            </chart:BarSeries>
        </chart:RadCartesianChart.series>
    </chart:RadCartesianChart>  

    <chart:RadPieChart class="m-t-10" height="350">
        <chart:RadPieChart.series>
            <chart:PieSeries items="{{ data }}" categoryProperty="key" valueProperty="value" showLabels="true" outerRadiusFactor="0.8" />
            <chart:RadPieChart.legend>
                <chart:RadLegendView position="Right" width="110" />
            </chart:RadPieChart.legend>
        </chart:RadPieChart.series>
    </chart:RadPieChart>  
            
    <chart:RadCartesianChart class="m-t-10" height="350">
        <chart:RadCartesianChart.series>
            <chart:AreaSeries items="{{ data }}" categoryProperty="key" valueProperty="value">                
                <chart:LineSeries.horizontalAxis>
                    <chart:CategoricalAxis labelFitMode="Rotate" />
                </chart:LineSeries.horizontalAxis>

                <chart:LineSeries.verticalAxis>
                    <chart:LinearAxis labelLayoutMode="Outer" />
                </chart:LineSeries.verticalAxis>    
            </chart:AreaSeries>                    
        </chart:RadCartesianChart.series>
    </chart:RadCartesianChart>             

    <chart:RadCartesianChart class="m-t-10" height="350">
        <chart:RadCartesianChart.series>
            <chart:SplineAreaSeries items="{{ data }}" categoryProperty="key" valueProperty="value">                
                <chart:LineSeries.horizontalAxis>
                    <chart:CategoricalAxis labelFitMode="Rotate" />
                </chart:LineSeries.horizontalAxis>

                <chart:LineSeries.verticalAxis>
                    <chart:LinearAxis labelLayoutMode="Inner" />
                </chart:LineSeries.verticalAxis>    
            </chart:SplineAreaSeries>                    
        </chart:RadCartesianChart.series>
    </chart:RadCartesianChart> 

    <chart:RadCartesianChart class="m-t-10" height="350">
        <chart:RadCartesianChart.series>
            <chart:BubbleSeries items="{{ data }}" categoryProperty="key" valueProperty="value" bubbleScale="10" bubbleSizeProperty="impact">                
                <chart:LineSeries.horizontalAxis>
                    <chart:CategoricalAxis labelFitMode="Rotate" />
                </chart:LineSeries.horizontalAxis>

                <chart:LineSeries.verticalAxis>
                    <chart:LinearAxis labelLayoutMode="Outer" />
                </chart:LineSeries.verticalAxis>    
            </chart:BubbleSeries>                    
        </chart:RadCartesianChart.series>
    </chart:RadCartesianChart> 

- RadSideDrawer
  
  source:
  http://docs.telerik.com/devtools/nativescript-ui/Controls/NativeScript/SideDrawer/overview  
  https://github.com/rdlauer/ui-for-nativescript-sidedrawer
  http://docs.telerik.com/devtools/nativescript-ui/api/classes/radsidedrawer.html
  https://www.nativescript.org/blog/a-deep-dive-into-telerik-ui-for-nativescripts-sidedrawer

  install:
  > tns plugin add nativescript-ui-sidedrawer

  namespace:
  xmlns:sd="nativescript-ui-sidedrawer"

  structure:
  - RadSideDrawer 
	- drawerContent
	- mainContent

  options:
  drawerLocation: string // see 'drawerLocations'
  drawerTransition: string // see 'transitions'
  drawerContentSize: int // the drawer width

  methods:
  toggleDrawerState();
  closeDrawer();

  events:
  drawerPan
  drawerClosed
  drawerClosing
  drawerOpened
  drawerOpening

  drawerLocations:
  Top
  Bottom
  Left
  Right

  transitions:
  FadeTransition
  PushTransition
  RevealTransition
  ReverseSlideOutTransition
  ScaleDownPusherTransition
  ScaleUpTransition
  SlideAlongTransition
  SlideInOnTopTransition

  share drawer:
  use custom components to create a shared xml content and put that UC within the drawerContent
  see 'Custom UI Components'

  open from actionBar:
  <ActionBar title="SideDrawer" icon="" class="action-bar">
      <ActionItem tap="{{ toggleDrawer }}" ios.systemIcon="4" android.systemIcon="ic_menu_btn_add" ios.position="left" />
  </ActionBar>

  full screen:
  DO NOT wrap the drawer element with StackLayout! it'll cause it to take a partial height (based on the content height)
  the default height of the Drawer grid is 100%!

  using:

  // UI
  <Page xmlns="http://schemas.nativescript.org/tns.xsd" 
      xmlns:sd="nativescript-ui-sidedrawer" 
      navigatingTo="onNavigatingTo" class="page">  
    <Page.actionBar>
        <ActionBar title="SideDrawer" icon="" class="action-bar">
            <ActionItem tap="{{ toggleDrawer }}" ios.systemIcon="4" android.systemIcon="ic_menu_btn_add" ios.position="left" />
        </ActionBar>
    </Page.actionBar>

    <sd:RadSideDrawer id="drawer1" drawerTransition="SlideInOnTopTransition" drawerLocation="{{ drawerLocation }}" drawerContentSize="150">
        <sd:RadSideDrawer.drawerContent>                                 
            <StackLayout class="drawerContent">
                <Label text="Home" />
                <Label text="About" />
                <Label text="Contact" />
                <Label text="FAQ" />                
            </StackLayout>
        </sd:RadSideDrawer.drawerContent>

        <sd:RadSideDrawer.mainContent>
            <StackLayout>
                <Button text="Toggle Drawer" class="btn btn-primary" tap="{{ toggleDrawer }}" />
                <StackLayout orientation="horizontal" horizontalAlignment="center">
                    <Button text="Top" class="text-center" tap="{{ setDrawerLocation }}" />
                    <Button text="Bottom" class="text-center" tap="{{ setDrawerLocation }}" />
                    <Button text="Left" class="text-center" tap="{{ setDrawerLocation }}"  />
                    <Button text="Right" class="text-center" tap="{{ setDrawerLocation }}"  />
                </StackLayout>                
            </StackLayout>
        </sd:RadSideDrawer.mainContent>
    </sd:RadSideDrawer>  
  </Page>          

  // CSS   
  StackLayout.drawerContent{
    background-color:#888;
    color: #fff;         
  }

  StackLayout.drawerContent Label{
    padding: 12;
  }

  // JS
  var Observable = require("data/observable").Observable;
  var view = require("ui/core/view");

  function createViewModel(page) { 
    var viewModel = new Observable();  

    viewModel.page = page;
    viewModel.drawer = view.getViewById(page, 'drawer1');
    viewModel.drawerLocation = "Left";

    viewModel.toggleDrawer = args => {
        viewModel.drawer.toggleDrawerState();
    };

    viewModel.setDrawerLocation = args => {
        var value = args.object.text;
        console.log(value);
        viewModel.set('drawerLocation', value);
    };

    return viewModel;   
  }
  exports.createViewModel = createViewModel;        

- RadCalendar

  source:
  http://docs.telerik.com/devtools/nativescript-ui/Controls/NativeScript/Calendar/overview
  https://github.com/rdlauer/ui-for-nativescript-calendar
  https://github.com/telerik/nativescript-ui-samples/tree/master/calendar/app

  install:
  > tns plugin add nativescript-ui-calendar

  namespace:
  xmlns:calendar="nativescript-ui-calendar"

  options:
  eventSource: [CalendarEvent]
  eventsViewMode: string // how to show the event data - see 'eventViewMode property'
  viewMode: string // view type - see 'viewMode property'
  transitionMode: string // transitions - see 'transitionMode property'

  eventsViewMode property:
  Inline
  Popover
  none

  viewMode property:
  Day 
  Week
  Month
  MonthNames
  Year

  transitionMode property:
  None
  Slide
  Stack
  Flip     // iOS
  Fold     // iOS
  Float    // iOS
  Rotate   // iOS
  Plain    // Android
  Free	   // Android
  Combo    // Android
  Overlap  // Android

  CalendarEvent:
  eventTitle: string 
  startDate: date
  endDate: date

  events:
  pageLoaded
  loaded

  using:
  <Page xmlns:calendar="nativescript-ui-calendar">
    <calendar:RadCalendar eventSource="{{ events }}" eventsViewMode="Inline" viewMode="{{ viewMode }}" />
  </Page>

  var calendarModule = require("nativescript-ui-calendar");

  var now = new Date();    
  viewModel.viewMode = "Month";
  viewModel.events = [        
        new calendarModule.CalendarEvent('eventA', now, now),
        new calendarModule.CalendarEvent('eventB', now, now),
        new calendarModule.CalendarEvent('eventC', now, now),
  ];

- nativescript-speech

  source:
  https://market.nativescript.org/plugins/nativescript-speech-recognition
  https://developer.android.com/reference/android/speech/SpeechRecognizer

  install:
  > tns plugin add nativescript-speech-recognition

  methods:
  available  // determines whether or not the speech recognition supported 
  requestPermission // request permissions
  startListening([options])
  stopListening

  options:
  locale: string
  returnPartialResults: bool
  onResult: function
  onError: function

  onResult callback:
  returns transcription object
  
  transcription object:
  text			// the recording value 
  finished		// determines whether the recording is completed or not 

  onError callback:
  returns string representation for iOS 
  returns statusCode for android (see 'statusCodes')

  statusCodes:
  audio recording error = 3
  insufficient permissions = 9
  other client side errors = 5
  other network related errors = 2
  network operation timed out = 1
  no recognition result matched = 7
  recognitionService busy = 8
  server sends error status = 4
  no speech input = 6

  available:
  available()
	.then((available) => { })
	.catch(ex => {  });


  requestPermission:
  requestPermission()
	.then((granted) => { })
	.catch(ex => {  });

  using: 
  var Speech = require("nativescript-speech-recognition").SpeechRecognition;

  var speech = new Speech();
 
  // is available
  speech.available()
    .then(available => {
        console.log(available ? "YES!" : "NO");
    })
    .catch(ex => {
        console.log(ex.message);
    });

  // request permissions
  speech.requestPermission()
    .then(granted => {
        console.log(granted ? "granted" : "NO permissions!");
    })
    .catch(ex => {
        console.log(ex.message);
    });

  // start listening
  var options = {
    locale: 'en-US',            
    returnPartialResults: true,            
    onResult: (transcription) => {
        console.log('result: ' + transcription.text); 
        console.log('status: ' + transcription.finished);
    },
    onError: (error) => { 
        console.log('error: ' + error);
    }
  };

  speech.startListening(options)
    .then(() => {
        console.log('start listening...');  
    })
    .catch(ex => {
        console.log('[startListening] ' + ex.message);
    })


  // stop listening
  speech.stopListening();

- nativescript-sound

  source:
  https://www.npmjs.com/package/nativescript-sound

  install:
  > tns plugin add nativescript-sound

  methods:
  create([filePath])  // returns sound object

  sound object methods:
  play
  stop
  reset

  note! 
  best practice is to preload the audio file before playing it due to a delay during the audio creation.

  using: 
  var soundModule = require("nativescript-sound");
  var tada = soundModule.create("~/sounds/tada.mp3");
  tada.play();

  -- 

  sounds = {
    'Tada': soundModule.create("~/sounds/tada.mp3"),
    'Boo': soundModule.create("~/sounds/boo.mp3"),    
  };

  sounds['Boo'].play();


- nativescript-camera

  about:
  allows us to take a picture and optionally save it to device storage

  source:
  https://github.com/NativeScript/nativescript-camera#nativescript-camera-

  install:
  > tns plugin add nativescript-camera

  methods:
  takePicture([options])  // take a photo
  requestPermissions	  // check required permissions 
  isAvailable			  // check if camera available to use, returns true/false 

  options:
  width						  // set the photo width 
  height					  // set the photo height
  keepAspectRatio([bool])	  // keep the aspect ratio during picture resizing 
  saveToGallery([bool])		  // save the photo to the gallery
  cameraFacing([rear|front])  // set the camera to use, front or rear			

  takePicture method:
  takePicture([options])
	.then([function])
	.catch([function])

  using: 
  var camera = require("nativescript-camera");
  var imageModule = require("ui/image");

  var hasCamera = camera.isAvailable();
  if(!hasCamera) return;

  /// camera.requestPermissions();

  var options = { 
	width: 300, 
	height: 300, 
	keepAspectRatio: false, 
	saveToGallery: true 
  };

  camera.takePicture(options)   
    .then(function (imageAsset) {        
        var image = new imageModule.Image();
        image.src = imageAsset;
    }).catch(function(ex) {
        console.log(ex.message);
    });

- nativescript-social-share

  about:
  share capabilities.

  source:
  https://github.com/tjvantoll/nativescript-social-share

  install:
  > tns plugin add nativescript-social-share

  methods:
  shareImage([image: imageSource], [subject: string])
  shareText([text: string], [subject: string])
  shareUrl([url: string], [text: string], [subject: string])

  using:
  var socialShareModule = require("nativescript-social-share");
  var imageSourceModule = require("image-source");

  SocialShare.shareImage(imageSourceModule.fromFile("~/myImage.jpg"));
  SocialShare.shareText("text to share...");
  SocialShare.shareUrl("http://example.com/", "example site");

- nativescript-dom
  
  about:
  html dom helper

  source:
  https://www.npmjs.com/package/nativescript-dom

  install:
  > tns plugin add nativescript-dom

  methods:
  [view].getElementById([id: string])
  [view].getElementsByClassName([className: string])
  [view].getElementsByTagName([tagName: string])

  [view].classList.add([className: string], [className: string] ...)
  [view].classList.insert([className: string], [className: string] ...)
  [view].classList.remove([className: string], [className: string] ...)

  [view].classList.toggle([className: string])
  [view].classList.item([index: int])
  [view].classList.contains([className: string])

  using:
  require("nativescript-dom");

  var component = _page.getElementById('c1');
  var components = _page.getElementsByClassName('class1');  

- nativescript-geolocation
  
  about:
  work with geolocation

  source:
  https://github.com/NativeScript/nativescript-geolocation
  https://docs.nativescript.org/hardware/location
  
  install:
  > tns plugin add nativescript-geolocation

  methods:
  getCurrentLocation([options])  
  watchLocation([onSuccess: function], [onError: function], [options])	
  clearWatch([watchId: number])
  enableLocationRequest() // promise
  isEnabled() // promise 
  distance([location], [location])

  options:
  - desiredAccuracy
    number 1-3  // Accuracy.high for 3 meter accuracy, Accuracy.any for 300
	accuracy  level 

  - updateDistance
    number (in meters) 
	how often to update the location - distance based

  - updateTime
    number (in milliseconds)
	interval between location updates

  - minimumUpdateTime
    number (in milliseconds)  
	minimum time interval between location updates

  - timeout
    number (in milliseconds)

  - iosAllowsBackgroundLocationUpdates
    bool

  - iosPausesLocationUpdatesAutomatically
    bool
  
  location class: 
  {
      latitude: number;
      longitude: number;
      altitude: number;
      horizontalAccuracy: number;
      verticalAccuracy: number;
      speed: number;
      direction: number;
      timestamp: Date;
  }

  background mode:
  once the app is in background, the monitor stops! use background service to solve this
  see 'Background Services'

  viewModel.set:
  note that when using a viewModel we MUST use the 'set' method instead of a direct access to it's properties

  viewModel.latitude = 32.0853;   
  viewModel.longitude = 34.7818;

  geolocation.watchLocation(function(location) {
  	if (!location) return;
  
  	console.log(location.latitude + ' ' + location.longitude);  
  	viewModel.set('latitude', location.latitude); 
  	viewModel.set('longitude', location.longitude);           	
  },function(ex){ }, options);

  using:
  var geolocation = require("nativescript-geolocation");
   
  // check for permissions, ask the user if needed
  geolocation.isEnabled().then(function (isEnabled) {
  	console.log(isEnabled);
  	if (!isEnabled) {
  		geolocation.enableLocationRequest().then(function () {}, function (ex) {
  			console.log('ex: ' + ex.message);
  		});
  	}
  }, function (ex) {
  	console.log('ex: ' + ex.message);
  });

  // watch location  
  var options = {       
    desiredAccuracy: 3, 
    updateTime: 5000,     
    timeout: 2000  
  };

  watchId = geolocation.watchLocation(function(location) {
	  if (!location) return;            
	  console.log(location.latitude + ' ' + location.longitude);  
  },function(ex){  
      console.log('ex: ' + ex.message);
  }, options);

  // clear watch
  geolocation.clearWatch(watchId);

  // get current position
  geolocation.getCurrentLocation(options).then(function(location) {
      if (!location) return;
	  console.log(locations.latitude + ' ' + locations.longitude);
  }, function(ex){  
      console.log('ex: ' + ex.message);
  });


- nativescript-google-maps-sdk
  
  about:
  google Maps api

  source:
  https://github.com/dapriett/nativescript-google-maps-sdk
  https://www.npmjs.com/package/nativescript-google-maps-sdk
  https://developers.google.com/android/reference/com/google/android/gms/maps/GoogleMap
  https://developers.google.com/maps/documentation/
  https://developers.google.com/maps/documentation/android-sdk/intro

  install:
  > tns plugin add nativescript-google-maps-sdk

  setup:
  1. copy the keys from 'node_modules/nativescript-google-maps-sdk/platforms/android/res/values/nativescript_google_maps_api.xml' 
	 to 'app/App_Resources/Android/src/main/res/values/'

  2. set the api key
     <resources>
        <string name="nativescript_google_maps_api_key">[key]</string>nativescript-geolocation
     </resources>  

  3. add new tag to the 'AndroidManifest.xml' file 
     located in 'app/App_Resources/Android/src/main'

	<application>
		...
		<meta-data android:name="com.google.android.geo.API_KEY" android:value="@string/nativescript_google_maps_api_key" />
		...
	</application>
		
  [optional]
  4. add permissions to the 'AndroidManifest.xml' file  
     located in 'app/App_Resources/Android/src/main'
     ...
	 ...
     <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
	 <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>	

  5. make sure we have the following defined within the app.gradle file (location: '/app/App_Resources/Android/app.gradle')
     project.ext {
		googlePlayServicesVersion = "+"
	 }  

  google maps reference:
  important!
  we can reach all of the google maps features by using the package namespace in our code
  'com.google.android.gms.maps'

  // using alias
  let LatLngBounds = com.google.android.gms.maps.model.LatLngBounds;
  let LatLng = com.google.android.gms.maps.model.LatLng;
  
  var bounds = new LatLngBounds.Builder();
  bounds.include(new LatLng(northeast.latitude, northeast.longitude));
  bounds.include(new LatLng(southwest.latitude, southwest.longitude));

  // example
  _gMap.animateCamera(com.google.android.gms.maps.CameraUpdateFactory.zoomIn());
  
  zoom:
  _mapView.zoom = [zoomLevel: int];

  // sample
  _mapView.zoom = 12;

  // animateCamera to a specific zoom level
  let CameraUpdateFactory = com.google.android.gms.maps.CameraUpdateFactory;
  _gMap.animateCamera(CameraUpdateFactory.zoomTo(16));
 
  add map-view:
  1. add namespace to the 'Page' component holding the 'mapView' component
     xmlns:maps="nativescript-google-maps-sdk"

	 <Page xmlns="http://schemas.nativescript.org/tns.xsd" xmlns:maps="nativescript-google-maps-sdk" navigatingTo="onNavigatingTo" class="page">...</Page>

  2. add 'mapView' component 
     <maps:mapView latitude="{{ latitude }}" longitude="{{ longitude }}" />

  properties:
  latitude
  longitude
  zoom  
  bearing
  tilt
  padding
  mapAnimationsEnabled

  events:
  mapReady
  coordinateTapped
  coordinateLongPress
  markerSelect
  markerBeginDragging
  markerDrag
  markerEndDragging
  markerInfoWindowTapped
  cameraChanged
  cameraMove

  methods:
  Position() // returns a position object (aka coordinates) 
  Polyline()  // returns a polyline object
  Marker()  // returns a marker object

  static methods:
  Position.positionFromLatLng([lat: number], [lng: number]);  // returns a position object

  mapView methods:
  addMarker([marker])
  addPolyline([polyline])

  polyline methods:
  addPoints([position[]]);
  addPoint([position]);

  draw a route: 
  in order to draw a route between 2 points we need to do as follow
  1. use 'google direction api' to get the directions between those 2 locations. 
     see 'Other Services/google Directions API'
  2. draw a Polyline using the points received from chapter 1.

  add a marker:
  var marker = new mapsModule.Marker();
  marker.position = mapsModule.Position.positionFromLatLng(latitude, longitude);
  marker.title = "title";
  marker.snippet = "some description";
  marker.userData = { };
  _mapView.addMarker(marker);

  add a polyline:
  var points = [];
  points.push(mapsModule.Position.positionFromLatLng(latitude, longitude));
  points.push(mapsModule.Position.positionFromLatLng(latitude, longitude));
  points.push(mapsModule.Position.positionFromLatLng(latitude, longitude));              
  polyline.addPoints(points);
  polyline.width = 8;
  polyline.geodesic = true;
  polyline.color = new colorModule.Color("Purple");                             
  _mapView.addPolyline(polyline);

  create bounds:
  let LatLngBounds = com.google.android.gms.maps.model.LatLngBounds;
  let LatLng = com.google.android.gms.maps.model.LatLng;
  
  var bounds = new LatLngBounds.Builder();
  bounds.include(new LatLng(northeast.latitude, northeast.longitude));
  bounds.include(new LatLng(southwest.latitude, southwest.longitude));

  setMyLocationEnabled property:
  enable/ disable my location icon
  gMap.setMyLocationEnabled([bool]);

  mapView reference technique:

  var _mapView;    
  var _gMap;

  onMapReady = args => {
      _mapView = mapView;
      _gMap = mapView.gMap;       
  };

  <maps:mapView latitude="{{ latitude }}" longitude="{{ longitude }}" mapReady="{{ onMapReady }}" />

  animateCamera:
  _gMap.animateCamera([cameraUpdateFactory])

  // example
  _gMap.animateCamera(com.google.android.gms.maps.CameraUpdateFactory.zoomIn());

  cameraUpdateFactory:
  - source
    https://developers.google.com/android/reference/com/google/android/gms/maps/CameraUpdateFactory

  - newCameraPosition([CameraPosition])
  - newLatLng([LatLng])
  - newLatLngBounds([LatLngBounds], [int])
  - newLatLngZoom([LatLng], [zoom])
  - scrollBy([float], [float])
  - zoomBy([float])
  - zoomIn()
  - zoomOut()
  - zoomTo([float])
  
  UI Settings:
  - mapToolbarEnabled
  - rotateGesturesEnabled
  - scrollGesturesEnabled
  - tiltGesturesEnabled
  - zoomControlsEnabled
  - zoomGesturesEnabled
  - compassEnabled
  - indoorLevelPickerEnabled

  enable my Location:
  _mapView.myLocationEnabled = true; // enable my location
  _mapView.settings.myLocationButtonEnabled = true; // show my location buttton

  add marker icon:
  let imageModule = require('ui/image');
  let imageSource = require('image-source');

  let icon = new imageModule.Image();
  icon.imageSource = imageSource.fromFile(iconURL);
  marker.icon = icon;

  using:
  // basic 
  viewModel.latitude = 32.0853;
  viewModel.longitude = 34.7818;
  viewModel.zoom = 12;

  <Page xmlns="http://schemas.nativescript.org/tns.xsd" xmlns:maps="nativescript-google-maps-sdk" navigatingTo="onNavigatingTo" class="page">  
    <Page.actionBar>        
        <StackLayout>     
            <maps:mapView latitude="{{ latitude }}" longitude="{{ longitude }}" />
        </StackLayout>
    </Page.actionBar>        
  </Page>

  // advanced 
  let mapsModule = require("nativescript-google-maps-sdk");
  let imageModule = require('ui/image');
  let imageSource = require('image-source');

  viewModel.latitude = 32.0853;   
  viewModel.longitude = 34.7818;
  viewModel.zoom = 12;
    
  viewModel.onMapReady = function(args) {    
    var mapView = args.object;
    var gMap = mapView.gMap;
	
    var marker = new mapsModule.Marker();
    marker.position = mapsModule.Position.positionFromLatLng(viewModel.latitude, viewModel.longitude);
    marker.title = "some title";
    marker.snippet = "some description";
    marker.userData = { };

	if(iconURL) {
        let icon = new imageModule.Image();
        icon.imageSource = imageSource.fromFile(iconURL);
        marker.icon = icon;
    }

    mapView.addMarker(marker);
          
	_mapView.zoom = 12; // set the zoom level
    _mapView.settings.zoomGesturesEnabled = false; // disabling zoom gestures
	_mapView.settings.zoomControlsEnabled = true; // enabling zoom control

	_mapView.myLocationEnabled = true; // enable my location
	_mapView.settings.myLocationButtonEnabled = true; // show my location buttton
  }
      
  viewModel.onMarkerSelect = function(args) {
    console.log(args.marker.title);
  }

  <Page xmlns="http://schemas.nativescript.org/tns.xsd" xmlns:maps="nativescript-google-maps-sdk" navigatingTo="onNavigatingTo" class="page">  
    <Page.actionBar>       
        <StackLayout>                 
            <maps:mapView latitude="{{ latitude }}" longitude="{{ longitude }}"  
                    mapReady="{{ onMapReady }}" 
                    markerInfoWindowTapped="{{ onMarkerSelect }}" />
        </StackLayout>
    </Page.actionBar>        
  </Page> 

- android-maps-utils

  about:
  an open-source library contains utilities for the Google Maps Android API

  source:
  https://github.com/googlemaps/android-maps-utils
  http://googlemaps.github.io/android-maps-utils/javadoc/

- google-maps-ios-utils

  about:
  an open-source library contains utilities for the Google Maps Android API

  source:
  https://github.com/googlemaps/google-maps-ios-utils
  https://developers.google.com/maps/documentation/ios-sdk/intro

- nativescript-google-maps-utils
  
  about:
  allows us to create an Heatmap based on position set 
  and a cluster based on marker set

  dependencies:
  ios util (see 'google-maps-ios-utils')
  android utils (see 'android-maps-utils')

  supported:
  android

  source:
  https://market.nativescript.org/plugins/nativescript-google-maps-utils

  install:
  > tns plugin add nativescript-google-maps-utils

  methods:
  setupHeatmap
  setupMarkerCluster

  sample:
  var mapsUtils = require('nativescript-google-maps-utils');

  mapsUtils.setupHeatmap(_mapView, positions);
  mapsUtils.setupMarkerCluster(_mapView, markers);

- nativescript-directions
  
  about:
  get directions and navigation plan from google api. 
  open the naitive maps app and show directions.

  important:
  this extension opens the google Maps-app and NOT draws the route on an internal mapView item!!

  source:
  https://github.com/EddyVerbruggen/nativescript-directions

  install:
  > tns plugin add nativescript-directions

  setup:
  properties:
  events:

  navigate function:  
  navigate([options]).then([onSuccess], [onError]);

  navigate options:
  // TODO

  using:
  var directionsModule = require("nativescript-directions").Directions;

  var directions = new directionsModule();
  directions.navigate({
	  from: {
		lat: 52.215987,
		lng: 5.282764
	  },
	  to: { 
		address: "Hof der Kolommen 34, Amersfoort, Netherlands"
	  }  
  }).then(function(){ ... }, function(e){ ... });


note!
find more plugins in the market (see 'MarketPlace')

Background Services
-------------------
also see 'Workers'

https://github.com/NativeScript/sample-android-background-services

// TODO

Workers
-------

// TODO 

// ToDocument - sample below

// caller 
var worker = new Worker("~/Services/background-services");
viewModel.onStartWorkerTap = args => {      
    let counter = 0;

    worker.postMessage('Hello from main!');
    worker.postMessage('start');
    worker.onmessage = function(msg) {
        console.log("received from worker thread: " + msg.data);
		counter++;

        if(counter == 10)
            worker.postMessage('stop'); /// worker.terminate()
    }
};

// worker 
let timer;
let intervalInSec = 2;

this.start = () => {
  timer = setInterval(() => {
    postMessage(new Date().getTime());
  }, intervalInSec * 1000);
};

this.stop = () => {
  clearInterval(timer);
};

onmessage = (msg) => {
  console.log("received from main thread: " + msg.data);  

  switch(msg.data){
    case 'start': this.start();
      break;
    case 'stop': this.stop();
        break;
    case 'close': this.close(); // terminate the worker
  }
};

onerror = (e) => { 
  console.log('ERROR: '+ e);  
};


Other Services
--------------
- open google maps 
  
  source:
  https://developers.google.com/maps/documentation/urls/guide  

  how to:
  use the 'openUrl' method of the 'utils' class (see 'JS Modules/utils')

  url:
  https://www.google.com/maps/search/?api=1&query=<query>

  e.g:
  // address: Alenbi 40 Tel Aviv, Israel
  utils.openUrl("https://www.google.com/maps/search/?api=1&query=Alenbi+40+Tel+Aviv%2C+Israel");

  // coordinates: 32.34058,34.86032
  utils.openUrl("https://www.google.com/maps/search/?api=1&query=Alenbi+40+Tel+Aviv%2C+Israel");

- open waze maps 
  
  source:
  https://developers.google.com/waze/deeplinks/

  how to:
  use the 'openUrl' method of the 'utils' class (see 'JS Modules/utils')

  url:
  https://waze.com/ul?<query>

  parameters:
  z			// zoom level (e.g: z=8)
  q			// address
  ll		// lat long (e.g: ll=45.6906304,-120.810983)
  favorite  // favorite name (e.g: favorite=work)
  navigate  // start natigation (e.g: navigate=yes)


  e.g:
  // coordinates: 32.1093,34.8555
  utils.openUrl("https://waze.com/ul?ll=32.1093,34.8555&z=10");

- google distance API
  
  about:
  get the distance between 2 locations

  source:
  https://developers.google.com/maps/documentation/distance-matrix/start
  https://developers.google.com/maps/documentation/distance-matrix/intro#DistanceMatrixRequests

  1. go to the developer console 
  2. enable the direction api 
  3. create api-key
  
  parameters:
  - units 
    - metric
	- imperial 
  - origins // use | for multiple
    - address 
	- coordinates (comma seperated)
	- place (place_id:)
  - destinations
    - see 'origin'
  - key // api key
  - mode
    - see 'transportation modes'  

  transportation modes:  
  - driving
  - walking
  - cycling
  - transit (see 'transit mode')
  - texi (see 'texi mode')

  transit mode:
  when choosing this mode, we get the ability to set some extra optional parameters to refine the result
  - departure_time
  - arrival_time
  - transit_mode
    - bus
	- subway
	- train
	- tram
	- rail
  - transit_routing_preference
    - less_walking
	- fewer_transfers

  texi mode:
  use the following combination
  - mode=transit
  - transit_routing_preference=less_walking

  avoid options:
  - tolls
  - highways
  - ferries
  - indoor

  query:
  - origins: string
  - destinations: string
  - mode: string (see 'transportation modes')
  - key: string
  - alternatives: bool
  - avoid: string (see 'avoid options')
  - language: string (see 'supported languages')

  syntax:  
  fetch([server] + [query])
  .then(response => response.json())
  .then(response => { ... })
  .catch(ex => { ... }); 

  sample:
  var params = [];
  params.push('origin=' + fromAddress);
  params.push('destination=' + toAddress);
  params.push('mode=' + 'driving');
  params.push('key=' + 'xxxxxxxxxxxxxxxx');
  
  var query = '?' + params.join('&');
  var endpoint = 'https://maps.googleapis.com/maps/api/distancematrix/json' + query;
  
  fetch(endpoint)
  .then(response => response.json())
  .then(response => {
      console.log(response);
  }).catch(ex => { 
      console.log('ex: ' + ex.message);
  });


- google Directions API
  
  about:
  get the directions between 2 or more locations. 
  supports coordinates or address
  supports direction modes (driving etc.)

  security tip:
  proxying the web service via your server when you're using the API in a mobile app, to protect your API key!

  source:
  https://developers.google.com/maps/documentation/directions/start

  setup:
  same as 'google distance API'

  parameters:
  - origin 
    - address 
	- coordinates (comma seperated)
	- place (place_id:)
  - destination
    - see 'origin'
  - key // api key
  - mode
    - see 'transportation modes'  

  how to encode a decoded polyline?
  > npm install polyline
  var polyline = require('polyline');
  var polylineData = polyline.decode(route.overview_polyline.points);

  supported languages:
  https://developers.google.com/maps/faq#languagesupport

  server:
  'https://maps.googleapis.com/maps/api/directions/json'

  query:
  - origin: string
  - destination: string
  - mode: string (see 'transportation modes')
  - key: string
  - alternatives: bool
  - avoid: string (see 'avoid options')
  - language: string (see 'supported languages')

  syntax:  
  fetch([server] + [query])
  .then(response => response.json())
  .then(response => { ... })
  .catch(ex => { ... }); 

  sample:
  var params = [];
  params.push('origin=' + fromAddress);
  params.push('destination=' + toAddress);
  params.push('mode=' + 'driving');
  params.push('key=' + 'xxxxxxxxxxxxxxxx');
  
  var query = '?' + params.join('&');
  var endpoint = 'https://maps.googleapis.com/maps/api/directions/json' + query;
  
  fetch(endpoint)
  .then(response => response.json())
  .then(response => {
      console.log(response);
  }).catch(ex => { 
      console.log('ex: ' + ex.message);
  }); 

Page Structure
--------------
- app
--- app.js
--- app.css
--- app-root.xml
--- Pages
------ Page
--------- page.xml
--------- page.js
--------- view-model.js
--------- page.css
	- Page
--------- Tab
----------- tab.xml
----------- tab.js
----------- view-model.js
----------- tab.css
--------- Tab
----------- tab.xml
----------- tab.js
----------- view-model.js	  
----------- tab.css
--------- page.xml	  
	- Page
--------- Partial	    
----------- item.xml		
--------- page.xml
--------- page.js
--------- view-model.js
--------- page.css

samples:
// TODO



Working With Nativescript
-------------------------

- get reference to the current page:
    
  1. passing the 'page' object using 'onNavigatingTo' event to the model
  2. import it from 'ui/page' module    

  using:

  // page-js
  function onNavigatingTo(args) { 
    var page = args.object;
    page.bindingContext = createViewModel(page);
  }

  // view-model-js
  function createViewModel(page) { }

  --

  // import
  const page = require("ui/page");
  ...

- passing Parameters:
  see 'Passing Context'

- bindingContext:

  .js
  [object].bindingContext = [object] 
  
  .xml 
  use {{ .. }} to bind a value from the binded context

  e.g:
  Page.bindingContext = { name: 'John Joe', id: 1234 }

  <Label text="{{id}}" />
  <Label text="{{name}}" />

- &quot;
  used to escape " sign

  // e.g
  <Label text="{{ sumDistance + ' ק&quot;מ' }}" />  
  

- global variables:
  // TODO 

  app.js
  var application = require("application");
  ...
  global.myVariable = 'some value';
  ...

- module.exports vs exports:
// TODO

- inheritance:

  // base-services.js
  function baseServices(){
    var that = this; // reference
    
    // public methods
    this.funAA = funAA;

    // initialization
    (function () { })();

    function funAA(){
        console.log('funAA');        
    }  
  }
  exports.baseServices = baseServices;

  // employee-services.js
  let baseServices = require('./base-services').baseServices;

  function employeeServices(){
    var that = this; // reference

    // properties
    // public methods
    this.fun = fun;

    // initialization
    (function () { })();

    function fun(){ 
        console.log('fun');
        that.funAA();
    }     
  }
  employeeServices.prototype = new baseServices(); // inheritance
  exports.employeeServices = employeeServices; 

  // using 
  let employeeServices = require('~/Services/employee-services').employeeServices;
  var service = new employeeServices();    
  service.fun();

- constant values: 
  
  steps:
  1. create a js file for the constants values
     use exports to expose those values.
  2. require the file    

  // option1 - using  Object.freeze
  module.exports = Object.freeze({  
    API_ENDPOINT: 'http://delivit-shared.com'    
  });

  // option2 - direct exposure
  exports.API_ENDPOINT: 'http://delivit-shared.com';
  
  // using
  let Constants  = require('~/Services/config');
  console.log(Constants.API_ENDPOINT);

- using API:
  see 'fetch'

- run the application:
  add those code lines to the app.js file
  the 'pageName' represents the starting point (the home page)

  var application = require("application");
  application.run({ moduleName: "[pageName]" });

  note! DO NOT add more code after the 'run' method! it will not be executed on iOS

- set as start page:
  see 'run the application' 

- foreach:
  [array].forEach(item => {
        // code ...
  });

- bindings
  - use double curly brackets syntax.
  - syntax:
    {{ p }}

  - combination of text and property:
    {{ 'p=' + p }}

  - $value:
    use this keyword to bind a list item value   
	{{ $value }}

  - $parent and $parents
    use those keywords to access the parent/ parents bindingContext object

  - tip:
    avoid accessing components by ID. It is recommended to use bindings to specify component properties.

  - e.g:
    // xml
    <Page  navigatingTo="navigatingTo">
		<Label text="{{ myTitle }}" />
		<Button tap="{{ onTap }}" />

		<ListView items="{{ myItems }}">
			<ListView.itemTemplate>
				...
			</ListView.itemTemplate>
		</ListView>
    </Page>

	// code 
	function navigatingTo(args) {
		const page = args.object;
		page.bindingContext = { 
			myTitle: "Some content...",
			onTap: () => { ... },
			myItems: [
				{ name: "Name1" }, 
				{ name: "Name2" }, 
				{ name: "Name3" }
			]
		};
	}
	exports.navigatingTo = navigatingTo;

- exports:  
  - the 'exports' object allows us to expose ANY js function so it'll be accessible from the project files.   
  - syntax:
    exports.[Name] = [Function];
	module.exports = [Class];

   - export a class 
	class <className> {
		constructor() {
			....
		};
	}
	exports = <className>;

  - e.g: 
    <Button text="tapMe" tap="fun1" class="btn btn-primary" />
    exports.fun1 = function() { 
	  ... 
    } 

- console
  
  log operations:  
  info
  log
  warn
  error
  dir

  stopwatch:
  time([key])
  timeEnd([key])

  using:
  console.time('key1');
  ...
  ...
  console.timeEnd('key1');

- require
  - import modules or js files (see 'require js files')
  - syntax:
    var [variableName] = require("[modulePath]");
  - use the npm to import the module from the web to the node_modules local folder! (see 'npm install')  
  - use . for relative path (to the current folder)
  - use ~ for relative path (to the app folder)
  - default path - nodes_modules/ tns_modules

  - e.g:
    // import the observable module (in node_modules folder)
    var Observable = require("data/observable").Observable;	

	// import the myModule function in my-view-model.js file (in the same folder)
	var myModule = require("./my-view-model").myModule;

	// import the my-shared-view-model.js file
	var myView = require("../shared/my-shared-view-model"); 

- require js files:
  - create reference to a local js file
  - syntax:
    var [variableName] = require("[jsPath]");

  - e.g:
    // fileA 
    var srv = require("./fileB.js").myService();
    
    function fun() { 
      srv.run();
    }
    
    // fileB.js
    function myService(){
      return{
          run: function(){
              ...
          }
       }
    }
    exports.myService = myService;


- npm install 
  - syntax:
    > npm install [packageName] --save

- images sources:
  from URL > 'http://' prefix
  from Resource > 'res://' prefix
  from File system > '~/' prefix

- resources location:
  App_Resources\Android\src\main\res
  drawable-XXX folders

- relative location:
  use './' for relative location 

  e.g: // page-view-model.js located in the same level as the caller
  var createViewModel = require("./page-view-model").createViewModel;

- application:
  to get a reference to the current application:    
  see 'JS Modules/application'  

- multiple views
  see 'Multiple Views'

- terminal:
  we can use the VS Code terminal to perform the CLI commands as well as the npm commands 

- event object:
  args.object returns the object which triggered the event. 

  tip:
  use custom attributes to pass data to an event through the object (button etc.) which triggered it!

  sample:
  <Button text="Vista" soundType="vista" tap="{{ onSoundTap }}" />

  viewModel.onSoundTap = (args) => {         
        var button = args.object;   // buttton
        var soundToPlay = button.soundType;  // custom attribute 
        console.log('play ' + soundToPlay);                       
    }

- passing arguments to a binded function:
  <Button text="Btn" p1="value1" tap="{{ myTapFunc }}" />

  viewModel.myTapFunc = args => {        
      let button = args.object;
	  console.log(button.p1);
  };

- get reference to a component:

  // UI
  <lv:RadListView id="listview1" items="{{ items }}">
	.....
  </lv:RadListView>

  // page-js
  function onNavigatingTo(args) { 
    var page = args.object;
    page.bindingContext = createViewModel(page);
  }

  // view-model-js
  var view = require("ui/core/view");

  function createViewModel(page) { 
    var viewModel = new Observable();         
    viewModel.listview = view.getViewById(page, 'listview1');
    ...
	...
  }

- templates:
  
  source:
  https://docs.nativescript.org/app-and-screen-templates/app-templates

  more templates:
  https://plugins.nativescript.rocks/templates

  create an app using a template: 
  > tns create [appName] --template [templateName]

  e.g
  >  tns create my-app-name --template tns-template-name

  tip: 
  we can also use sideKick to create an app using a template 

  source:cd
  each template has its own repo in github 

  list:
  - blank
    tns-template-blank   // built-in

  - hello world 
    tns-template-hello-world  // built-in

  - master detail 
    tns-template-master-detail  // built-in

  - tabbed app 
    tns-template-tab-navigation  // built-in

  - drawer
	tns-template-drawer-navigation

  - tabs
    tns-template-tab-navigation

  - master detail with firebase
	tns-template-master-detail

  - master detail with kinvey
    tns-template-master-detail-kinvey

  - whatsapp 
    nativescript-whatsapp-template

	install
	npm i nativescript-whatsapp-template

  note:
  we can create our own templates (see 'create a template')

- values-v21
  app/App_Resources/Android/src/main/res

  app config key such as strings, integers, and colors for themes supported only on API Level 21+

- AndroidManifest.xml
  app/App_Resources/Android/src/main/res

  provides information about your app to the Android system. 
  use it to change the app icon, app name etc. 

- create a template:
  a nativescript template is nothing more than an app folder of a nativescript app!
  
  steps:
  1. create an nativescript app and set all the content you need for the template 

  2. copy the app content + the package.json from the root.
     note: DO NOT copy the app folder but its content!

  3. create a new folder for the template, named it using the following convention 
     nativescript-template-[templateName]

	 e.g:
	 nativescript-template-rcbuilder-foo

  4. place the copied content from chapter 3 within the template folder

     notes: 
	 * the 'App_Resources' folder is optional, the engine will generate a default one if not exists.
	 * the 'package.json' should be the one that was copied from the root.

     structure sample:
	 - nativescript-template-rcbuilder-foo
	   - App_Resources  // optional
	   - app-root.xml
	   - app.css
	   - app.js
	   - package.json  // copied from the root

   5. upload the new template to githab (or any other server)        

   6. use the tempalte path to refer to it
      note: you can also refer a local template (for debugging)
      
      e.g:
	  tns create my-app-name --template https://github.com/rcbuilder/nativescript-template-rcbuilder-foo
	  tns create my-app-name --template ~/Desktop/nativescript-template-rcbuilder-foo   // local 

- performance:  
  enable webpack and usign bundle and uglify to achieve a better app. 
  in addition, for images, use the src property instead of ImageSource, set the loadMode to be async, set a decodeWidth and decodeHeight and use the useCache property.

  source:
  https://docs.nativescript.org/performance-optimizations/bundling-with-webpack
  https://docs.nativescript.org/performance-optimizations/startup-times
  https://docs.nativescript.org/performance-optimizations/images-optimisations

- splash Screen:
  
  drawable-X folders
  app/App_Resources/Android/src/main/res/

  splash_screen.xml
  app/App_Resources/Android/src/main/res/drawable-hdpi

  <layer-list xmlns:android="http://schemas.android.com/apk/res/android" android:gravity="fill">
    <item>
        <bitmap android:gravity="fill" android:src="@drawable/background" />
    </item>
    <item>
        <bitmap android:gravity="center" android:src="@drawable/splashscreenlogo" />
    </item>
  </layer-list> 

Passing Context
---------------
see 'Request Context'

Request Parameteres
-------------------
also see 'Request Context'

// PageA  
frame.navigate({
    moduleName: 'Pages/Delivery/delivery-page',
    context: { id: 1234 }
});

// PageB
function onNavigatingTo(args) {
    let page = args.object;    
    let requestContext = page.navigationContext;
	let id = requestContext.id;
    ...
}

Request Context
---------------
we can pass a custom context between pages using the navigationContext.

steps: 
1. use the frame module to navigate from PageA to pageB. add context to the navigation.
2. use the 'navigationContext' property in PageB to read the transfered context from chapter 1.

// PageA
var frameModule = require("tns-core-modules/ui/frame");
var frame = frameName ? frameModule.getFrameById(frameName) : frameModule.topmost();

var options = {
    moduleName: path,
    context: { .... }
}   
frame.navigate(options);

---

// PageB
const defaultContext = { ... };

function onNavigatingTo(args) {
    let page = args.object;    
    let context = page.navigationContext || defaultContext;     
    page.bindingContext = context;
}
exports.onNavigatingTo = onNavigatingTo; 


Navigation
----------
see 'JS Modules/frame'
see 'Page Component/page frame'
see 'TabView'
see 'RadSideDrawer'
see 'Modals'
see 'Fixed bottom Strip'

Fixed bottom Strip
------------------
structure:
<ActionBar title="Some Title"></ActionBar>
<GridLayout rows="*,60">
    <ScrollView row="0">
        ....
    </ScrollView>
    <StackLayout row="1" orientation="horizontal">
        ....
    </StackLayout>
</GridLayout>

Notifications
-------------

[Local Notifications]
notifications that are pushed from the app itself.

install:
tns plugin add nativescript-local-notifications

source:
https://github.com/EddyVerbruggen/nativescript-local-notifications

Notification object:
id: number
title: string 
subtitle: string 
body: string
color: Color
ticker: string  // status-bar message (instead of the body)
interval
image: URL  // big image below the message body
forceShowWhenInForeground  // always show the notification
actions: [NotificationAction]  // add buttons/Inputs
at: Date  // Date object indicating when the notification should be shown 
bigTextStyle: boolean  // multiple body lines (default: false)
icon  // system tray icon (res://filename located in App_Resouces/Android/drawable)
silhouetteIcon  // same as icon for Android >= Lollipop (21)
thumbnail  // notification right icon 

NotificationAction object:
id
type  // button or input
title

methods:
schedule(<[Notification]>);  // promise
requestPermission();  // promise
hasPermission();  // promise
cancelAll()
cancel(<id>)

callback registration:
addOnMessageReceivedCallback(callback);  // promise

require:
const localNotifications = require("nativescript-local-notifications").LocalNotifications;

sample:
<Button tap="{{ onNotificationTap }}" text="notification" /> 

const localNotifications = require("nativescript-local-notifications").LocalNotifications;
const dialogs = require('ui/dialogs');
var colorModule = require("color");

// notification callback registration
localNotifications.addOnMessageReceivedCallback(notification => {
    let options = {
        title: notification.title,
        message: `callback from message #[${notification.id}]`,
        okButtonText: "OK"		
    };
        
    dialogs.alert(options); 
});

viewModel.onNotificationTap = args => {
    localNotifications.requestPermission().then(granted => {
        if(!granted) return;
  
        var notifications = [];
        notifications.push({
            id: 100,
            title: 'Lorem Ipsum',
            subtitle: 'What is Lorem Ipsum?',
            body: 'dummy text of he printing and typesetting industry',
            color: new colorModule.Color('#85c241'),
            at: new Date(new Date().getTime() + (2 * 1000)),  // in 2 sec
            silhouetteIcon: 'res://nowings',
            icon: 'res://nowings',
            thumbnail: 'res://logo',
            image: 'https://cdn-images-1.medium.com/max/1200/1*c3cQvYJrVezv_Az0CoDcbA.jpeg'
        });

        localNotifications.schedule(notifications);
    });
};

---
   
[Push Notifications]
notifications that are pushed from a server. 

about the process:
notifications are sending to the end user device through a 'Notification Server'. 
each user register to that server and get a unique token which will used to identify him once a message enter, 
then we send the received token to our 'APP Server' and map it to the user. 
now, we can use those token to target each user and send a message to him by send the desired message to the 'Notification Server' using the desired token/s.

to recup
the app make a registeration of the device in the 'Notification Server' and get the token, than the app sends it to the 'App Server' and store it. 
later, it uses the strored tokens to call the 'Notification Server' and send messages to the end users.

schema:
App Server > Notification Server > User Device

// TODO 
  
Firebase:
see 'Google Firebase/firebase Cloud Messaging' 


Debugging
---------

syntax:
> tns debug [android|ios]  // debug a device

livesync:
an auto livesync process applied 

flags:
--bundle // debug a Webpack bundled application
--start
--emulator  // debug the app in an emulator
--timeout
--no-watch  // disable the livesync
--clean  // forces rebuilding the native application

using:
1. > tns debug android
2. copy the generated url and copy it into chrome browser
3. use the devTools (F12) to debug the app!

Storage
-------
types:
LocalStorage
SessionStorage

install:
tns plugin add nativescript-localstorage

source:
https://github.com/NathanaelA/nativescript-localstorage

require:
nativescript-localstorage

properties:
length

methods:
setItem(key: string, value: string)
setItemObject(key: string, value: json)
getItem(key: string)
removeItem(key: string)
clear()

using:
let localStorage = require('nativescript-localstorage');

localStorage.clear();
localStorage.setItemObject("test", {a: 1, b: 2});
]jkj .;lxssdkjm64localStorage.setItem('counter', 33);945ikl['p7p[;0-var counter = localStorage.getItem('counter');

Techniques
----------
- BaseViewModel
  
  let Observable = require("data/observable").Observable;
  let ObservableArray  = require("data/observable-array").ObservableArray;

  function BaseViewModel() {
    var viewModel = new Observable();   
	...
	...
    return viewModel;
  }

  function EmployeePageViewModel() {
    var viewModel = new BaseViewModel();   
	...
	...
    return viewModel;
  }
  exports.EmployeePageViewModel = EmployeePageViewModel;

  function RestaurantPageViewModel() {
    var viewModel = new BaseViewModel();   
	...
	...
    return viewModel;
  }
  exports.RestaurantPageViewModel = RestaurantPageViewModel;
  
  ---

  // using (Employee)
  function onNavigatingTo(args) {
    let page = args.object;    
    page.bindingContext = new PageViewModel.EmployeePageViewModel();;
  }

- abstract methods

  let Observable = require("data/observable").Observable;
  
  function BaseViewModel() {
    var viewModel = new Observable();   
	
	viewModel.fun1 = args => {    
        viewModel.doSomething();  // abstract        
    };

    return viewModel;
  }

  function PageViewModel1() {
    var viewModel = new BaseViewModel();   

	viewModel.doSomething = args => { 
		console.log('in Model 1');
	};

    return viewModel;
  }
  exports.PageViewModel1 = PageViewModel1;

  function PageViewModel2() {
    var viewModel = new BaseViewModel();   
	
	viewModel.doSomething = args => { 
		console.log('in Model 2');
	};

    return viewModel;
  }
  exports.PageViewModel2 = PageViewModel2;

- passing parameters/ context:
  see 'Passing Context'
  see 'Request Parameteres'
  see 'Request Context'


Multiple Views
--------------
nativescript provides a way to define different files (.js, .css, .xml etc.) to be loaded based on the screen size, platform and orientation.

qualifiers:
- Platform 
- Screen size
- Orientation 

Platform:
- android 
- ios 

  note!
  also see 'Platform Specific Capabilities'

Screen size:
- minWH<X>
- minW<X>
- minH<X>

Orientation:
- land 
- port 

samples:
app.android.css
app.ios.css

main-page.minW600.xml
main-page.minH400.xml

Icons
-----
see 'systemIcon'
see 'Font Awesome'

App Resources
-------------
- load image syntax:
  res://[resourceName]

- auto choose:
  the engine loads the best image for the current device screen density

- supported formats:
  PNG
  JPG

- change application icon:
  > tns resources generate icon [path]

- sample:
  <Image src="res://logo" stretch="none" /> 

[android]
- location
  App_Resources\Android\src\main\res

- add resource:
  images should be added to the corresponding drawable-XXX folders.

  e.g:
  drawable-hdpi/icon.png
  drawable-ldpi/icon.png
  drawable-mdpi/icon.png
  drawable-nodpi/icon.png
  drawable-xhdpi/icon.png
  drawable-xxhdpi/icon.png
  drawable-xxxhdpi/icon.png

  note! we can create our own drawable folders based on specific sizes > drawable-800x480 etc.


[iOS]
- location:
  App_Resources\ios

- add resource:
  @1x
  @2x
  @3x

  e.g:
  icon.png
  icon@2x.png
  icon@3x.png

systemIcon
----------
- android.systemIcon 
  https://developer.android.com/reference/android/R.drawable

- iOs.systemIcon
  0: Done
  1: Cancel
  2: Edit
  3: Save
  4: Add
  5: FlexibleSpace
  6: FixedSpace
  7: Compose
  8: Reply
  9: Action
  10: Organize
  11: Bookmarks
  12: Search
  13: Refresh
  14: Stop
  15: Camera
  16: Trash
  17: Play
  18: Pause
  19: Rewind
  20: FastForward
  21: Undo
  22: Redo
  23: PageCurl

Font Awesome
------------
in order to add fonts to the app, we'll need to place the '.ttf' files 
in a 'fonts' folder under the 'app' folder

- icons folder: 
  fonts

- npm install:
  npm install @fortawesome/fontawesome-free

- icon list
  https://fontawesome.com/icons?d=gallery&m=free

- free packages
  Regular
  Solid
  Brands

- icon code:
  &#x[code];

  e.g:
  &#xf36d;
  &#xf4e7;
  &#xf589;

- font color:
  css > use 'color' and 'background-color'
  property > use 'color' and 'backgroundColor'

  e.g:
  

- font family:
  Font Awesome 5 [packageName], [fileName]

  e.g:
  Font Awesome 5 Brands, fa-brands-400
  Font Awesome 5 Regular, fa-regular-400
  Font Awesome 5 Solid, fa-solid-900
     
- Implementation:
  1. download fontAwesome
  2. copy '.ttf' files to 'app/fonts' folder
  3. set the component font family (see 'font family')
  4. set the icon code as the component text (see 'icon code')
  5. (optional) set the icon color using (see 'font color')
  

- sample:
  
  <Label android:text="&#xf09b;" fontFamily="Font Awesome 5 Brands, fa-brands-400" fontSize="30" color="blue" />  
  <Label android:text="&#xf4e7;" fontFamily="Font Awesome 5 Brands, fa-brands-400" fontSize="30" color="green" />
  <Label android:text="&#xf0b2;" fontFamily="Font Awesome 5 Solid, fa-solid-900" fontSize="30" />
  <Label android:text="&#xf589;" fontFamily="Font Awesome 5 Regular, fa-regular-400" fontSize="30" color="red" />

  ---

  .faSolid {
    font-family: Font Awesome 5 Solid, fa-solid-900;
    font-weight: 400; 
  }
  
  .faBrands {
  	font-family: Font Awesome 5 Brands, fa-brands-400;
  	font-weight: 400; 
  }
  
  .faRegular {
  	font-family: Font Awesome 5 Regular, fa-regular-400;
  	font-weight: 900; 
  }

  .pink{
    color: pink;
  }

  <Label android:text="&#xf09b;" class="faBrands pink" fontSize="30" />

  ---

  // default vs colored 
  <FlexboxLayout class="p-4">
      <Label flexGrow="1" android:text="&#xf09b;" class="faBrands"  fontSize="30" color="#283593" />  
      <Label flexGrow="1" android:text="&#xf36d;" class="faBrands"  fontSize="30" color="#c43c00" />            
      <Label flexGrow="1" android:text="&#xf4e7;" class="faBrands"  fontSize="30" color="#790e8b" />  
      <Label flexGrow="1" android:text="&#xf0b2;" class="faSolid"   fontSize="30" color="#6ff9ff" />
      <Label flexGrow="1" android:text="&#xf55f;" class="faSolid" fontSize="30" color="#00c853" />
      <Label flexGrow="1" android:text="&#xf1fa;" class="faSolid" fontSize="30" color="#b71c1c" />
      <Label flexGrow="1" android:text="&#xf589;" class="faRegular" fontSize="30" color="#1b1b1b" />
      <Label flexGrow="1" android:text="&#xf164;" class="faRegular" fontSize="30" color="#009624" />
      <Label flexGrow="1" android:text="&#xf2bd;" class="faRegular" fontSize="30" color="#e91e63" />
  </FlexboxLayout> 
  <FlexboxLayout class="p-4">
      <Label flexGrow="1" android:text="&#xf09b;" class="faBrands"  fontSize="30" />  
      <Label flexGrow="1" android:text="&#xf36d;" class="faBrands"  fontSize="30" />            
      <Label flexGrow="1" android:text="&#xf4e7;" class="faBrands"  fontSize="30" />  
      <Label flexGrow="1" android:text="&#xf0b2;" class="faSolid"   fontSize="30" /> 
      <Label flexGrow="1" android:text="&#xf55f;" class="faSolid"   fontSize="30" />
      <Label flexGrow="1" android:text="&#xf1fa;" class="faSolid"   fontSize="30" />
      <Label flexGrow="1" android:text="&#xf589;" class="faRegular" fontSize="30" />
      <Label flexGrow="1" android:text="&#xf164;" class="faRegular" fontSize="30" />
      <Label flexGrow="1" android:text="&#xf2bd;" class="faRegular" fontSize="30" />
  </FlexboxLayout>

  ---

  <FlexboxLayout class="bubble-green big">
       <Button flexGrow="1" tap="{{ onEndShift }}" text="In &#xf204;" class="faSolid" />                     
       <Button flexGrow="1" tap="{{ onTakeABreak }}" text="Break &#xf0f4;" class="faSolid" />        
       <Button flexGrow="1" tap="{{ onStartShift }}" text="Out &#xf205;" class="faSolid" />                       
  </FlexboxLayout>

Platform Specific Capabilities
------------------------------
- File level:
  [view].android
  [view].ios

- Tag level:
  <android></android>
  <ios></ios>

- Attribute level:
  android: [attribute]
  ios: [attribute] 

- CSS:
  see 'CSS/platform specific css'

  e.g: 
  <label android:class="A" ios:class="B" />

CSS
---
nativescript map the known css rules into native style.

- nativeScript Theme Builder
  a great feature which allows us to create a css layout and import it to our app!
  https://www.nativescriptthemebuilder.com

- supported selectors:
  - Element Type
  - Class (.)
  - Id (#)
  - Hierachical (.A > .B etc.)

- supported properties:
  - https://docs.nativescript.org/ui/styling#supported-css-properties

- themes:
  - https://docs.nativescript.org/ui/theme
    https://docs.nativescript.org/ui/theme#color-schemes
  
  - the selected theme located in the app.css file 
    @import '~nativescript-theme-core/css/sky.css';
	
  - schemes
	- core.light.css
	- core.dark.css

    - aqua.css
    - blue.css
    - brown.css
    - forest.css
    - grey.css
    - lemon.css
    - lime.css
    - orange.css
    - purple.css
    - ruby.css
    - sky.css

  - headings
    h1-h6
    use the h1-h6 css classes to replace the html h tags

	<Label class="h1" text="big heading" />
	<Label class="h6" text="small heading"></Label>

  - text alignment
    text-left
	text-right
	text-center

	<Label class="text-left" text="left aligned" />
	<Label class="text-right" text="right aligned" />
	<Label class="text-center" text="center aligned" />

  - text transform
    text-lowercase
	text-uppercase
	text-capitalize

	<Label class="text-lowercase" text="Hello" />
	<Label class="text-uppercase" text="Hello" />
	
  - font
    font-weight-normal
	font-weight-bold
	font-italic

	<Label class="font-weight-bold" text="bold text" />
	<Label class="font-italic" text="italic text" />

  - margin
    m-[value] 
	m-t-[value]
	m-b-[value]
	m-r-[value]
	m-l-[value]
	m-x-[value]
	m-y-[value]
	m-x-auto

	m stands-for margin 
	t stands-for top 
	b stands-for bottom
	r stands-for right
	l stands-for left
	x represents the x axis
	y represents the y axis
	[value] can be one of the following values > 0, 2, 5, 10, 15, 20, 25, 30 

	// using
	m-0 // margin 0
	m-t-2 // margin top 2
	m-b-20 // margin bottom 20
	m-x-10 // margin left and right 10
	m-y-5 // margin top and bottom 5
	m-x-auto // horizontal-align center

  - padding
    p-[value] 
	p-t-[value]
	p-b-[value]
	p-r-[value]
	p-l-[value]
	p-x-[value]
	p-y-[value]	

	p stands-for pagging 
	t stands-for top 
	b stands-for bottom
	r stands-for right
	l stands-for left
	x represents the x axis
	y represents the y axis
	[value] can be one of the following values > 0, 2, 5, 10, 15, 20, 25, 30 

	// using
	p-0 // pagging 0
	p-t-2 // pagging top 2
	p-b-20 // pagging bottom 20
	p-x-10 // pagging left and right 10
	p-y-5 // pagging top and bottom 5	

  - hr divider
    hr-light
	hr-dark

	need to apply to 'StackLayout' component

	<Label text="part 1" />
	<StackLayout class="hr-light m-10" />
	<Label text="part 2" />

  - colors
    text-primary // soft-blue 
	text-muted   // light-silver
	text-danger  // red
	bg-primary	 // soft-blue 
	bg-danger    // red

  - page class
    alters text colors when using the dark color scheme
	<Page class="page">...</Page>

  - action-bar classes

    action-bar
    applies the theme’s color scheme to ActionBar components		
	<Page.actionBar>
		<ActionBar class="action-bar" title="My App">
		</ActionBar>
	</Page.actionBar>	

	action-bar-title
	applies the theme’s color scheme when using a custom title view	
	<Page.actionBar>
		<ActionBar class="action-bar">
		  <StackLayout class="action-bar-title">
			<Label text="My App" class="font-weight-bold" color="blue"></Label>
		  </StackLayout>
		</ActionBar>
	</Page.actionBar>	
	
	action-item
	applies the theme’s color scheme to custom UI components

	tip! 
	we can create a custom action-bar without the 'ActionBar' component 
	using the action-bar classes on other UI components as presented below
	<GridLayout rows="auto" columns="75,*,75" class="action-bar p-10">
		<Button text="Close" class="text-left action-item" row="0" col="0"></Button> 
		<Label text="My Modal" class="text-center action-bar-title" row="0" col="1"></Label>
	</GridLayout>

  - buttons
    btn
	btn-primary		// soft-blue color
	btn-outline		// border and a transparent background
	btn-rounded-sm  // small rounded corners
	btn-rounded-lg	// large rounded corners
	btn-active		// highlighted when tapped

  - form
    form			// the form container
	input			// form input
    input-border    // input with border
	input-rounded   // input with rounded corners
	label			// form label
	input-field     
	input-sides

  - images
    img-rounded
	img-circle

	<Image src="1.jpeg" width="150" class="img-rounded" />
    <Image src="1.jpeg" width="150" class="img-circle" />

  - listViews 
    list-group				// applied on the ListView components
	list-group-item			// applied to each item template
	list-group-item.active  // set item as active
	list-group-item.thumb   // represents a thumbnail image, applied to Image component
	list-group-item-heading // represents an heading in multiline template
	list-group-item-text	// represents a text content in multiline template

	<ListView class="list-group">
	  <ListView.itemTemplate>
		<GridLayout class="list-group-item" rows="auto, *" columns="80, *">
		  <Image row="0" col="0" src="80x80.jpg" class="thumb img-circle" rowSpan="2"></Image>
		  <Label row="0" col="1" text="" class="list-group-item-heading" />
		  <Label row="1" col="1" text="" class="list-group-item-text" />
		</GridLayout>
	  </ListView.itemTemplate>
	</ListView>

  - progress bar
    progress  // applied to the Progress component
	<Progress class="progress m-20" value="50" />

  - activity indicator
	activity-indicator  // applied to the ActivityIndicator component
	<ActivityIndicator class="activity-indicator" busy="true" />

  - sliders
    slider  // applied to the Slider component
	<Slider minValue="1" maxValue="100" value="50" class="slider" />

  - switches
    switch  // applied to the Switch component 
	<Switch checked="true" class="switch" horizontalAlignment="center" />

  - fzzz 
    tab-view // applied to the TabView component 


  - predefined css classes
    - see 'headings'	
	- see 'text alignment'
	- see 'text transform'
	- see 'font'
	- see 'margin'
	- see 'padding'
	- see 'hr divider'
	- see 'colors'
	- see 'page class'
	- see 'action-bar classes'
	- see 'buttons'
	- see 'form'
	- see 'images'
	- see 'listViews'
	- see 'progress bar'
	- see 'activity indicator'
	- see 'sliders'
	- see 'switches'
	- see 'tabViews'

	- pull-left
	- pull-right  
	- body  // long text	

- convention:
  - app.css  // global styles
  - [view].css  // view/ page styles
  - [view].ios.css  // ios platform specific styles
  - [view].android.css  // android platform specific styles
  - [view].common.css  // shared styles

  note: 
  use '@import' to import the 'common.css'  file in both 'android' and 'ios' specific css files.

- platform specific css:
  [name].[platform].css

  e.g:  
  styles.ios.css  
  styles.android.css 

- @import: 
  use this command to import css files 
  use it within a css file.
  
  e.g:
  // ios.css
  @import 'common.css';
  .class1 { ... }
  .class2 { ... }

- auto css apply:
  a css file with the same name as the xml file within the same directory will be loaded and applied automatically by the nativescript engine!
  e.g: given a folder with both mypage.xml and mypage.css, the css will be applied automatically on the xml page. 

- addCssFile function:
  level > page component
  use the page function 'addCssFile' to add css files to the page.

- addCss function:
  level > page component
  use the page function 'addCss' to add css content to the page.

  e.g: 
  page.addCss('button {background-color: blue}');  
  
- inline css: 
  level > any component
  use the 'style' property to add an inline css rules

  e.g:
  <Button text="inline style" style="background-color: green;" />

- Less/ Saas:
  > tns install less
  > tns install sass

- Units:
  - DO NOT specify px!
  - e.g
  button{
  	border-radius: 3;
  	border-width: 1;
  	border-color: #d3d3d3;
  	width: 100;	
  }

- @keyframes:
  - we can use css keyframes
  - e.g
    @keyframes spin {
        from {
            transform: rotate(0);
        }
    
        to {
            transform: rotate(360);
        }
    }
    
    Image {
        animation-name: spin;
        animation-duration: 3s;
        animation-iteration-count: infinite;
        animation-timing-function: linear;
    }

- background-image

  - sample:
    // css
	.app-background{
		background-image: url('~/Images/background.jpg');
		background-repeat: no-repeat;
		background-position: center top;
		background-size: cover;  /* background-size: 750 695; */
	}

	// ui
	<Page ... class="app-background">

- bind css dynamically 
    
	// UI 
   <Image ... class="{{ getSelectedUserClass(4) }}" />             
   <Image ... class="{{ getSelectedUserClass(1) }}" />             
   <Image ... class="{{ getSelectedUserClass(2) }}" /> 

   // Code
   viewModel.selectedUserType = 2;          
   viewModel.getSelectedUserClass = type =>{        
        return 'radioItem' + (viewModel.selectedUserType == type ? 'selected' : '');
   }

   // CSS
   .radioItem {
		opacity: 0.2;
		animation-name: fadeIn;
		animation-duration: 0.7s;     

		text-align: center;  
		horizontal-align:center;    
	}

	.radioItem.selected {
		opacity: 1;
		animation-name: fadeOut;
		animation-duration: 0.7s;     
	}

	@keyframes fadeOut {
		from { opacity: 0.2; }
		to { opacity: 1; }
	}

	@keyframes fadeIn {
		from { opacity: 1; }
		to { opacity: 0.2; }
	}


Launch Process
--------------
[OPTION 1]

1. the file app/package.json should define the name of the starting js file 

   e.g:
   {
       "main": "app.js"
   	   "name": "my-app"
   }

2. in the app.js we need to execute the application 

   var application = require("application");
   application.run({ moduleName: "app-root" });

3. need to create the app-root.xml file defined in chapter 2
 
   <Frame defaultPage="main-page"></Frame>

4. create the main-page view
   - main-page.js
   - main-page.xml
   - main-page.css
   
---

[OPTION 2]

1. same as in [OPTION 1]
2. app.js 
   
   var application = require("application");
   application.mainModule = "main-page";
   application.start();

3. create the main-page view

Deploy(android)
---------------
https://docs.nativescript.org/tooling/publishing/publishing-android-apps

sidekick:
use Sidekick for easy publish (see 'Sidekick APP/publish to stores')

Deploy (steps): 
1. set app global configuration
2. create a Keystore private key
3. Build(Release)
4. Submit the apk to the store

Deploy Update:
1. Build(Release) 
   note: different version number (AndroidManifest.xml) and name (yyyyMMdd)
2. choose the app you want to update 
3. release managment -> app releases -> edit release
4. upload apk -> save draft 
5. save (button) -> Review (button) -> Start Roll-out (button) -> Create Release (button)

Build(Release):
- source:
  https://docs.nativescript.org/tooling/docs-cli/project/testing/build-android
- syntax:
  > tns build android <options>
- using: 
  > tns build android --release --key-store-path "E:\Projects\DelivIT\Documents\Keystores\hadeliverim-app.keystore" --key-store-password "delivIt1234" --key-store-alias "hadeliverim-app" --key-store-alias-password "delivIt1234"
- note:
  attach the keystore to the build

reminder:
1. change the version number to be higher than the current one.
2. chnage the version name to be the date in the following format yyyyMMdd 
3. build the app in release mode.

--

Submit the apk to the store:
- open the Google Play Developer Console:
    https://play.google.com/apps/publish/
- All applications -> Create application.
- app information
    set language and title

- [app releases tab]
    1. choose release mode (Production, Beta or Alpha)
	2. create release (button)
	3. upload the apk
	4. set the release name

	note: 
	you can create a release from library (e.g: production from beta)

- [store listing tab]
    Title // app's name on Google Play (30 Characters)
	Short description // app short description (80 Characters)
	Full description // app description (4000 Characters)
	Graphic Assets // screenshot, youTube video etc. (required! logo 512x512, at least 1 mobile screenshot, 7" and 10" tablet screenshot 2:1 ratio, app scrennshot 1024x500)
	Categorisation // app type, category etc.

- [content rating tab]
    need to complete a rating questionnaire and apply a content rating.

- [pricing & distribution tab]
    set mode: PAID or FREE 
	Countries // choose in which countries the app will be available

- Publish     
    open the release -> Review (button) -> Start Roll-out (button) -> Create Release (button)
  
note: 
you need to have all the V icons at the left pane in green! 
you have a small link 'Why can't I publish?' which lists the missing content.

--

set app global configuration:
- open the app
- open AndroidManifest file ('app/App_Resources/Android/AndroidManifest.xml')
- [application] tag
  android:name   // e.g: android:name="com.hadeliverim"
  android:icon   // e.g: android:icon="@drawable/icon"
  android:label  // e.g: android:label="@string/app_name"
  android:theme  // e.g: android:theme="@style/AppTheme" 
- [manifest] tag
  package="__PACKAGE__"   // do not change! __PACKAGE__ is a variable replaced by the application id defined in the package.json file.
  android:versionCode	  // e.g: android:versionCode="10000"
  android:versionName     // e.g: android:versionName="1.0"  
- note 
  @string, @drawable and @style are references to resources files 
  located in 'App_Resources/Android/src/main/res/' 

--

create a Keystore private key:
about: keystore is a binary file which contains a set of private keys, it required in order to sign the app.
- open CMD as administrator
- nevigate the %JAVA_HOME%\bin folder 

    e.g: 
    C:\Program Files (x86)\Java\jdk1.7.0_55\bin
    C:\Program Files\Java\jdk1.8.0_151\bin

- command: 
    keytool -genkey -v -keystore [keystore path] -alias [alias] -keyalg RSA -keysize 2048 -validity 10000

    e.g:  
    keytool -genkey -v -keystore "C:\Users\RcBuilder\Desktop\Hadeliverim Apps\certificates\Android\hadeliverim-app.keystore" -alias hadeliverim-app -keyalg RSA -keysize 2048 -validity 10000

- set keystore information:
    Enter keystore password: [password]
	What is your first and last name? [name] e.g: Roby Cohen
	What is the name of your organizational unit? [organisation unit] e.g: RcBuilder
	What is the name of your organization? [organisation] e.g: RcBuilder
	What is the name of your of your City or Locality? [city] e.g: Tel Aviv
	What is the name of your State or Province? [province]
	What is the two-letter country code for this unit? [county code] e.g: IL

- confirm the information: 
    y = yes (confirmed) 
	n = no

- enter extra password (alias password)
    Enter key password for <alias> (optional) 
	note: you can click on enter to use the same password as the keystore password

-- 

deploy tests:
  for non-production releases you need to create a testing unit
   there are few options available:
   - open testing 
     based on limited downloads from the store, at least 1000 users. 
	 once it reaches the limitation - the app will no longer be available for download.

   - closed testing 
     based on specific pre-defined email list (gmails). you can add specific emails and the app will be available ONLY for them.
	 note: you can also create custom users lists. 

   - group/community testing
     based on a group or a community users. only users in the specified group could download the app. 

publish the app:
see 'publish the app (iphone)'
see 'publish the app (android)'

publish the app (android):
- open 'Sidekick APP'
- open the project 
- click on publish button (top-right) 
- choose 'Google Play' as a destination
- settings (cogwheel icon) > set the certificate (keystore) file
- choose build type (local or cloud)
- Next

Deploy(iOS) 
-----------
https://docs.nativescript.org/tooling/publishing/publishing-ios-apps

IPA file:
iOS app store package.

IOS on Windows:
we can't build for iOS using windows due to a requirement of Xcode which is only available on MAC machines! 
there's a cloud build option using nativescript Sidekick (see 'Sidekick APP')

sidekick:
use Sidekick for easy publish (see 'Sidekick APP/publish to stores')

pre-requirements:
- open an apple account
- enable the 'Two-factor Authentication' mode
- enroll as a development (join the Apple Developer Program)
  note: annual cost of 99$ 

requirements:
- Certificate (see 'certificates')
- App Id
- Provisioning Profile

to get those, we need to enroll in the Apple iOS Developer Program and then, to use the dev Center platform.

tip! 
we can use the nativescript Sidekick app to generate those requirements
see 'establish environment for iOS' chapter under 'Sidekick APP' section 

certificates:
- terms:
  CSR = Certificate Signing Request 
  CER = iOS Certificate 

- process:
  use a Certificate Signing Request (CSR) to generate an iOS Certificate (CER)

  step1 - create an iOS Certificate Signing Request (CSR)
  step2 - create an iOS Certificate (CER)
  step3 - create an App id
  step4 - create distribution provisioning
  step5 - create a P12 file from iOS Certificate
  step6 - connect a P!2 file to an app 
  step7 - publish the app
  step8 - add an App to the Store

- types:
  Certificate for Development
  Certificate for Distribution   

create an iOS Certificate Signing Request (CSR):
- open 'Sidekick APP'
- (menu) Tools > Certificate Signing Request
- specify name, email and country 
- click on 'Create CSR' button
- save the generated CSR to the local disk (.csr file)
- use the certificate request to create a Certificate (see 'create an iOS Certificate')

create an iOS Certificate (CER):
- go to the 'dev Center'
- (menu) Certificates, Identifiers & Profiles
- on the top-left dropdown > select 'iOS, tvOS, watchOS'
- (menu) Certificates > Production
- click the + button (on the top-right)
- choose the certificate distribution typeto create > continue 
  (need to choose 'App Store and Ad Hoc' type)
- continue
- load the generated CSR > continue
  see 'create an iOS Certificate Signing Request (CSR)'
- Download the CER!

create distribution provisioning:
- go to the 'dev Center'
- (menu) Certificates, Identifiers & Profiles
- on the top-left dropdown > select 'iOS, tvOS, watchOS'
- (menu) Provisioning Profiles > Distribution
- click the + button (on the top-right)
- select the distribution > continue
  (need to choose 'App Store')
- select an App ID to associate with the profile > continue  
  note! to create app id see 'create an App id'
- select the certificate > continue
- set the profile name > continue
- download the provisioning profile

create an App id:
- go to the 'dev Center'
- (menu) Certificates, Identifiers & Profiles
- on the top-left dropdown > select 'iOS, tvOS, watchOS'
- (menu) Identifiers > App IDs
- App AI Description: the app name 
  e.g: HaDeliverim Restaurant
- App ID Suffix > Explicit App ID: a unique app id 
  e.g: com.HaDeliverim.Restaurant
- App Services: choose the services the app uses 
- click on register

  notes! 
  * app id is just a custom string value to identify the app.
  * don't forget to set the app id in the package.json file!

create a P12 file from iOS Certificate:
- open 'Sidekick APP'
- (menu) Tools > Certificate Signing Request
- click on 'Import CER' button
- load the certificate file (.cer file)
- provide a password > save

connect a P!2 file to an app:
- open 'Sidekick APP'
- open the project 
- (tab) connected devices > settings (cogwheel icon)
- choose the P12 file > add 

build the app on a specific Phone/AVD:
- open 'Sidekick APP'
- open the project 
- (tab) connected devices > choose the device 
- choose build type (local or cloud)
- choose build config (debug or release)
- click 'Run on Device'

publish the app:
see 'publish the app (iphone)'

publish the app (iphone):
- open 'Sidekick APP'
- open the project 
- click on publish button (top-right) 
- choose 'Apple App Store' as a destination
- settings (cogwheel icon) > set the certificate (P12) and provisioning files 
- choose build type (local or cloud)
- Next  
- once the build completed - an .IPA file will be created in [yourProject]\.cloud\ios\device 
  and a popup will be shown requesting your developer credentials - provide them and click 'Upload'

create an app strore build:
// TODO 

- tip
  use sidekick to publish an app to the app-store

add an App to the Store:
- go to the 'dev Center'
- (menu) App Store Connect > click on 'Go to ..' button
- choose 'My Apps'
- New App: platform 
  choose 'iOS' 
- New App: language  
- App information: App Name 
  app name as it will apear in the store
- App information: Privacy Policy URL 
  provide a url to the app policy 
- General information: Bundle ID 
  choose the created bundle
- General information: SKU 
  unique identifier (package id)
  e.g: co.il.rcbuilder.sample
- General information: Category 
  choose the app category 
  e.g: Food & Drink
- Pricing and Availability: Price Schedule
  set the app price 
  e.g: ILS 0 (Free)
- Prepare for Submission: Keywords
  app keywords
- Prepare for Submission: Support URL
  provide a url to a support page
- App Review Information: Contact Information
- General App Information: App Store Icon
  app icon (1024x1024)
- Build: choose a build 
  see 'create an app strore build'.

developer Program:
https://developer.apple.com/programs/

dev Center:
https://developer.apple.com/account/

deploy steps:
1. go to the 'dev Center' > 
// TODO

Sidekick APP
------------
install:
NativeScriptSidekickSetup.exe

a desktop application which built on top of the nativeScript CLI.
it was built using Electron to provide us a cross-platform desktop app for Windows, macOS, and Linux. 
with sidekick we can access templates and verified plugins, we can use a cloud builds service and a debugging service.

cloud build:
sidekick allows us to build an app in the cloud! 
no configuration required nor extra local packages.
this allows windows users to build for iOS without needing a Mac!
the build server uses a super fast Mac processor so the cloud build process will be really fast! 
it also provides us a way to submit apps to the app stores and generate certificates for app signing.

debugging: 
sidelick provides us a few great debugging options such as liveSync and the chrome devTools.

Create a Build:
- Run > Build 
- choose the 'Cloud Build' option and the target package (iOS or Android)
- click on 'Build'

create an iOS Certificate Signing Request (CSR):
reference > 'iOS'

create a P12 file from iOS Certificate:
reference > 'iOS'

establish environment for iOS:
[steps]
1. create an apple account 
2. see 'create an iOS Certificate Signing Request (CSR)'
3. see 'create an iOS Certificate (CER)'
4. see 'create a P12 file from iOS Certificate'

publish to stores:
we can use Sidekick to easily publish our app to both android and ios app stores  
[steps]
1. run > publish
2. choose platform (android or iOS)
3. settings (cog-wheel icon) > set the required certificates (.keystore)
   note: we need to do this only once
4. choose the build type (local or clowd)
   note: for windows - we'll have to choose cloud for iOS build
5. next
6. upload the service account key (json) 
   note: we can create keys in 'google play console' 

iOS app-specific password:
to generate an application-specific password go to the 'dev Center' > 'Security' tab
this allows access to the app-store for services not provided by apple. 

MarketPlace
-----------
in the nativescript MarketPlace we can find Plugins, Templates and Samples!
https://market.nativescript.org/

Playground
----------
https://play.nativescript.org/

app: 
"NativeScript Playground app"

this app allows us to get a REAL-TIME review of the changes we do in the web Playground site! 
download the app, scan the QR code and get a liveSync view on the mobile.


Issues
------
issue:
build error

error:
ANY

cause:
clear cache!
try to refresh the platform folder (remove and add its content)

solution:
> tns platform remove android
> tns platform add android

--

issue:
some services are not working properly or we have a build errors

cause:
applicationId is __PACKAGE__ in app.gradle file in 'app/App_Resources/Android' folder

solution:
Must set the app identity as defined in 'package.json' under the root

--

issue:
Unable to apply changes on device: xxxx. Error is: Command gradlew.bat failed with exit code 1.

solution:
change the jvmargs value to -Xmx256M

file "platforms/android/gradle.properties"
org.gradle.jvmargs=-Xmx256M

--

issue:
build error

error:
No inputs were found in config file '...tsconfig.json'.

solution:
no .ts files, must have at least one, add a blank one 

app
 - dummy.ts // (empty file)

--

issue:
Could not create the Java Virtual Machine
Invalid maximum heap size: -Xmx16384M

solution:
change the jvmargs value to -Xmx256M or -Xmx512M

file "platforms/android/gradle.properties"
org.gradle.jvmargs=-Xmx256M

--

issue:
my location requires permission ACCESS_FINE_LOCATION or ACCESS_COARSE_LOCATION

solution:
add the following lines in the 'AndroidManifest.xml' (app/App_Resources/Android/src/main)
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>	

--

issue:
can't find the AVD Manager menu in Android Studio after update 

solution:
open android studio > (tab) messages/ event log (located in the bottom)
click "Install missing platforms(s)..."
then after the download/install, click "Intall Build Tools..."

--

issue:
ListView inside a ScrollView - the list is NOT scrollable

tip:
try to avoid such case, do not wrap a ListView with ScrollView.. 
it causes a scrolling issue due to it's inner calculation process. 

solution:
use either ListView or ScrollView!

--

issue:
nativescript-geolocation - issue in enableLocationRequest

error:
Cannot enable the location service. Error: java.lang.NoClassDefFoundError
Failed resolution of: Lcom/google/android/gms/internal/zzbck nativescript-geolocation

cause:
Version Conflicts – Google Play Services

note: 
mostly occur when there's multiple services using the googlePlayServices (geolocation, firebase and google-maps etc.)
+ represents the latest version

tip:
we can also go to each plugin and check the version it uses
path 'node_modules/<plugin>/platforms/android/include.gradle'

https://github.com/NativeScript/nativescript-geolocation
'Known Issues' section


solution:
add the below code to the app.gradle file 
located in 'app/App_Resources/Android/app.gradle'

project.ext {
    googlePlayServicesVersion = "15.0.1"
}

OR 

[best solution]
1.create a 'before-plugins.gradle' file under 'app/App_Resources/Android' folder
2.add the below code snippet:
  project.ext {
    googlePlayServicesVersion = "15.0.1"
  }

--

issue:
build error

error:
gradlew.bat failed with exit code 1

cause:
need to refresh the platform folder (remove and add its content)

solution:
> tns platform remove android
> tns platform add android

--

issue:
build error - missing key

error:
@string/nativescript_google_maps_api_key not found

cause:
need to add the resource key to 
App_Resources\Android\values\strings.xml

solution:
// strings.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="nativescript_google_maps_api_key">xxxxxxxxxxx</string>
</resources> 

--

issue:
Violation of Usage of Android Advertising ID policy and section 4.8 of the Developer Distribution Agreement

error:
firebase collect data  about the user activity 

solution:
disable the data collection 

// AndroidManifest.xml > within application tag
<meta-data android:name="firebase_analytics_collection_enabled" android:value="false" />

source:
https://firebase.google.com/docs/analytics/configure-data-collection?platform=android#disable_data_collection

--

issue:


error:
The number of method references in a .dex file cannot exceed 64K.

solution:
add multiDexEnabled flag to the app/App_Resources/Android/app.gradle file 

android {  
  defaultConfig {  
    ...
    multiDexEnabled true        
  }  
  ...    
} 

<meta-data android:name="firebase_analytics_collection_enabled" android:value="false" />

--

error:
calendar.RadCalendarView is not a constructor

plugin:
calendar

solution:
remove and then add platform

--

error:
Cannot read property 'registerCallbacks' of undefined

plugin:
nativescript-local-notifications

solution:
remove and then add platform

--

issue:
Creating a Button with no border or shadow

solution:
<Button text="clickMe" class="no-border" /> 

.no-border{    
    border-color: transparent;
    border-width: 1;       
}

--

issue:
localhost network connection issue
(usually for debug purposes)

error:
java.net.ConnectException: localhost/127.0.0.1:1234 - Connection refused

cause:
127.0.0.1 or localhost will be emulator's own loopback address

solution:
use inner machine ip

--

issue:
localhost network connection issue
(usually for debug purposes)

error:
unable to resolve processService
# tns .....

solution:
tns extension uninstall nativescript-cloud

--

issue:
nativescript-google-maps - maps:mapView tag is not recognize

error:
'ui/map-view' not found for element 'MapView'

cause:
missing namespace 

solution:
add the below namespace to the 'Page' tag
xmlns:maps="nativescript-google-maps-sdk"

sample:
<Page xmlns="http://schemas.nativescript.org/tns.xsd" xmlns:maps="nativescript-google-maps-sdk" navigatingTo="onNavigatingTo" class="page">  
    <Page.actionBar>        
        <StackLayout>             
            <maps:mapView latitude="{{ latitude }}" longitude="{{ longitude }}" />
        </StackLayout>
    </Page.actionBar>        
</Page> 

Code Samples
------------
// page navigation
<Button tap="goToAboutPage" text="About" />

var frameModule = require("tns-core-modules/ui/frame");
exports.goToAboutPage = function(){                  
    var options={
        moduleName: 'Pages/About/about-page',
        context: { param1: 'value1', param2: 'value2'}
    }
    frameModule.topmost().navigate(options);       
}

note: // redirect with no context
frameModule.topmost().navigate('Pages/About/about-page');

---

// page navigation - dynamic 
<Button tap="goToPage" text="Tracking" path="Pages/Tracking/tracking-page" />
<Button tap="goToPage" text="Fan" path="Pages/FanApp/fan-page" />
<Button tap="goToPage" text="Components" path="Pages/Components/components-page" />
<Button tap="goToPage" text="Layouts" path="Pages/Layouts/layouts-page" />

exports.goToPage = args => {
    var path = args.object.path;    
    console.log(path);          
    frameModule.topmost().navigate(path);       
}

---

// navigatingTo event + bind content from view-model

// view-model.js
var Observable = require("data/observable").Observable;
function createViewModel() { 
    var viewModel = new Observable();    
    viewModel.text = 'bla bla bla...';
    return viewModel;
}
exports.createViewModel = createViewModel;

// page.js
var createViewModel = require("./view-model").createViewModel;
function onNavigatingTo(args) { 
    var page = args.object;
    page.bindingContext = createViewModel();
}
exports.onNavigatingTo = onNavigatingTo;

// page.xml
<Page xmlns="http://schemas.nativescript.org/tns.xsd" navigatingTo="onNavigatingTo" class="page">  
    <Label text="{{ text }}" />
</Page>

---
