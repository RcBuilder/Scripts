// TODO

C# Features
===========

[Release 6.0]

// Expression body
public class Dummy {
        public string P1 => "V1"; // read-only
        public int P2 => 30; // read-only

        public override string ToString() => $"{this.P1} -> {this.P2}"; // V1 -> 30

        public float Fun1() => 40.1F;        
    }

var d1 = new Dummy();
Console.WriteLine(d1); // V1 -> 30
Console.WriteLine(d1.Fun1()); // 40.1

---

// Auto-property initializer
public int P1 { get; set; } = 10;
public string P2 { get; set; } = "V2";
public float P3 { get; set; } = 3.14F;

---

// Null-conditional operator
Dummy d2 = null;
Console.WriteLine(d2?.P1 ?? "NULL");  // NULL

d2 = new Dummy();
Console.WriteLine(d2?.P1 ?? "NULL");  // 10

---

// String interpolation
syntax:
$"...{<param>}..."

sample:
var name = "Roby";
var city = "Kfar saba";

var str1 = $"Hi, I'm {name} from {city}";
Console.WriteLine(str1);  // Hi, I'm Roby from Kfar saba

var str2 = $"10 * 3 = {10*3}";
Console.WriteLine(str2); // 10 * 3 = 30

---

// Exception filters
syntax:
try{}
catch(Exception ex) when (<filter>){} 
catch(Exception ex) when (<filter>){}
catch(Exception ex) {} // default

sample:
try {
    ...
}
catch (Exception ex) when (ex.Message == "Exception-1") { 
    Console.WriteLine("Exception-1");
}
catch (Exception ex) when (ex.Message == "Exception-2") {
    Console.WriteLine("Exception-2");
}
catch (Exception ex) when (ex.Message.StartsWith("Exception-")) {
    Console.WriteLine("Exception-X");
}
catch (Exception ex) {
    Console.WriteLine(ex.Message);
}

cases:
throw new Exception("Exception-1"); // will trigger the 1st catch 
throw new Exception("Exception-2"); // will trigger the 2nd catch 
throw new Exception("Exception-3"); // will trigger the 3rd catch 
throw new Exception("Exception-10"); // will trigger the 3rd catch 
throw new Exception("some error"); // will trigger the 4th catch (default)

---

// nameof
var name = "Roby";

Console.WriteLine(nameof(name)); // name
Console.WriteLine(nameof(d1)); // d1
Console.WriteLine(nameof(d1.P2));  // P2

---

// Collection initialize 

// option1
var dic1 = new Dictionary<int, char> {
    { 65, 'A' },
    { 66, 'B' },
    { 67, 'C' }
};

// option2 (using indexer)
var dic2 = new Dictionary<int, char> {
    [65] = 'A',
    [66] = 'B',
    [67] = 'C'
};

Console.WriteLine(dic1[66]); // B
Console.WriteLine(dic2[66]); // B

[Release 7.0]

// Out declaration (directly)

sample:
fun(out var i);
Console.WriteLine(i); // 1

void fun(out int num){
	num = 1;
}

sample (using TryParse):
if(int.TryParse(input, out int result))
	Console.WriteLine(result);

---

// Tuple improvements!

syntax:
(<param-1>, <param-2>...<param-N>) <name> = (<value-1>, <value-2>...<value-N>);
var <name> = (<param-1>: <value-1>, <value-2>: <value-2>... <value-N>: <value-N>);
(<param-1>, <param-2>...<param-N>) = (<value-1>, <value-2>...<value-N>);

sample:
(int Id, string Name) tuple = (10, "Roby");
Console.WriteLine($"{tuple.Id}. {tuple.Name}"); // 10. Roby

sample (using var):
var tuple = (Id: 10, Name: "Roby");
Console.WriteLine($"{tuple.Id}. {tuple.Name}"); // 10. Roby

sample (direct): 
(int Num1, int Num2) = (5, 2);
Console.WriteLine($"{Num1} * {Num2} = {Num1 * Num2}"); // 5 * 2 = 10

sample (using function):
var tuple = fun();
Console.WriteLine($"{tuple.Id}. {tuple.Name}");

(int Id, string Name) fun(){
	return (10, "Roby");
}

--- 

// Deconstruction

reference: 
Tuple improvements!

syntax:
(<param-1>, <param-2>...<param-N>) = (<value-1>, <value-2>...<value-N>);

discard:
use '_' sign to ignore a parameter value

sample:
int i, j, k;
(i,j, k) = (100, 200, 300);
Console.WriteLine($"{i}, {j}, {k}");  // 100, 200, 300

sample (discard):
(string p1, _, _, string p4, _) = ("A", "B", "C", "D", "E");
Console.WriteLine($"{p1}, {p4}"); // A, D

---





------------------------------------------------------------

// TODO 
obj?.name