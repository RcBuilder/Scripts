*****************************
******** SQL Indexes ********
*****************************

indexes help us to evade table-scans which are a heavy task and by doing so, improve performance. 
a table-scan is a process taken to loop through ALL rows of a table.
a table with no index has to do a table-scan for almost any query!

each Non-Clustered index takes extra disk space because it creates another mapping table.

indexes improve our SELECT clauses to fetch the data faster but the trade off is the maintenance work required for UPDATE and DELETE clauses 
in order to keep the indexes fully updated. as many as indexes we have - the slower those actions would be.
an update of a row requires going through all the indexes and update them accordingly! 

the indexes structure is B+Tree! the tree trunk is based on the index columns.
reference: 'B-Tree vs B+Tree vs Binary Tree'

Syntax
------
CREATE <UNIQUE>? <CLUSTERED|NONCLUSTERED> INDEX <IndexName> ON <TableName>(<Column-1> <ASC|DESC>? ...) INCLUDE(<Column-1> ...)? WITH(<Flags>)?
DROP INDEX <IndexName> ON <TableName>

Clustered Index
---------------
- works on the actual data (the table itself)
- the data is stored in the order of the clustered index.
- can only be 1 clustered index per table! 
- commonly used for the primary key but it's NOT a requirement! we can define ANY index to be our clustered index.
  note that a primary key creates a clustered index automatically. (if there's no cluseted index defined)
- we don't have to specify a clustered index, we can create a table with no indexes at all. 
- if a table does NOT have a clustered index defined, the data is being stored in NO particular order! as it comes in.

Non Clustered Index
-------------------
- creates a new side table which consists of the index columns, this table is sorted based on the index columns. 
- in each row within the index-table we'll find a pointer (aka 'row locator') to the actual row in the data-table. 
  the pointer can be one of two options (depending on the case)
  1. when there's NO clustered index on that table -> the pointer is the row address 
  2. when there IS a clustered index defined -> the pointer is the clustered index key!  
- when an index is being used, the SQL engine collects the rows pointer from the matches and uses it to fetch the data from the actual data-table.  
- can be multiple non-clustered indexes per table (up to 999)

Tips
----
1. use SQL Execution plan to find out where the engine works hard and try to solve it using indexes (see 'SQL Execution Plan')
2. use SQL Profiler to find long-taking stored procedures and try to analyze them.
3. keep in mind that indexed improves SELECT data but it also impacts the INSERT and UPDATE actions due to maintenance work that needed to be taken.
4. (see 'Include Columns')

Create An Index
---------------
1. using the designer
   - expand the table properties > Indexes > New Index
   - set index name. 
   - choose the index type: 'clustered', 'non-clustered' etc.
   - choose whether the index is Unique or not.
   - add > choose the column/s for the index > ok.

2. using code 
   CREATE Index <name> ON <table> (<columns> <sort>);

   e.g: 
   CREATE Index IX_Salary ON Employees (Salary ASC) 

Include Columns
---------------
we can include columns on an index which results in adding those columns data to the tree leaf. 
that way we can save the call to the clustered index using the rows pointers. 
if the data found on the leaf, it'll be returned directly from the index!

for example, given a table of users: 
Users(Id, UserName, Age, CityId....)

1 | User1 | 30 | 3
2 | User2 | 34 | 1
3 | User3 | 25 | 1
4 | User4 | 29 | 5
5 | User5 | 53 | 3
6 | User6 | 45 | 7
7 | User7 | 19 | 2

let take a look at the following statement:
SELECT Id, UserName from Users Where CityId = 3

lets assume that we have an index on CityId column:
IX_CityId(CityId) 

1 | pointer to #2
1 | pointer to #3
2 | pointer to #7
3 | pointer to #1
3 | pointer to #5
5 | pointer to #4
7 | pointer to #6

in this case, the sql engine uses the index to find the rows which match the criteria CityId = 3, 
once it finds them, it takes their pointers and uses them to fetch the data (Id and UserName) from the Users table. 

--- 

now, lets include columns 'Id' and 'UserName' in our index:
IX_CityId(CityId) Include(Id, UserName)

1 | 2 | User1 | pointer to #2
1 | 3 | User1 | pointer to #3
2 | 7 | User1 | pointer to #7
3 | 1 | User1 | pointer to #1
3 | 5 | User1 | pointer to #5
5 | 4 | User1 | pointer to #4
7 | 6 | User1 | pointer to #6

in this case, the SQL engine finds the matching rows using the index (the same as in the previous example)
but because we've only requested the column 'Id' and 'UserName' and they exist on the index leaves, the data will be returned directly from the index 
and no extra call to the data-table will be made!

Flags
-----
- DROP_EXISTING		// ON|OFF (default: OFF)
  when set to ON, the SQL engine will rebuild the existing clustered by dropping and re-creating it.

- ONLINE		// ON|OFF (default: OFF)
  when set to ON, related table and associated indexes will be available for queries and data modification.
  
Order
-----
- ASC		// default
- DESC

when we have an ASC index and we request the data in DESC order there's almost no performance difference when using a single-key index 
but it does matter when we have a combined-key index of 2 or more columns!

--

note:
given the following combined-key index:
col1 ASC, col2 ASC

the below clause:
Order by col1 ASC, col2 ASC

will perform better than the below:
Order by col1 ASC, col2 DESC

due to the need of sorting the data (which in a different sort as the index!)

--

sample:
CREATE NONCLUSTERED INDEX [IX_Col1] ON [dbo].[MyTable] (Col1 ASC)
CREATE NONCLUSTERED INDEX [IX_Col1_Col2] ON [dbo].[MyTable] (Col1 ASC, Col2 DESC)

Uniqueness
----------
- UNIQUE

mark the index as unique. no duplicate values allowed!

sample:
CREATE UNIQUE INDEX IX_Id ON Persons (PersonID);

Filtered Index
--------------
use the WHERE clause in the Index definition to filter-out un-wanted rows to index! 
common case is to filter-out NULLs and ONLY index columns with values.
can also be used for genetating an Index Range! 

sample:
CREATE UNIQUE NONCLUSTERED INDEX [IX_OrderDate] 
ON [dbo].[Products](OrderDate ASC) 
WHERE [IX_OrderDate] IS NOT NULL;

// TODO --> test of range index + sample (by id etc.)

Using Example
-------------

** No Index **

[table] 
Employees(Id, Name, Salary)

1 | Emp1 | 5100
2 | Emp2 | 4100
3 | Emp3 | 2200
4 | Emp4 | 3700
5 | Emp5 | 2900
6 | Emp6 | 4500
7 | Emp7 | 3300

[query]

SELECT * from Employees where Salary between 3000 and 5000

[process]
a table-scan will be performed! the SQL engine will be looping-through ALL rows and check each one against the Salary range criteria. 

---

** With IX_Salary Index **

now, lets add a Non-Clustered index on 'Salary' column:
CREATE INDEX IX_Salary ON Employees(Salary ASC)

[index]
IX_Salary(Salary)

note: 
this is a B+Tree structure in the real world.

2200 | pointer to #3
2900 | pointer to #5
3300 | pointer to #7
3700 | pointer to #4
4100 | pointer to #2
4500 | pointer to #6
5100 | pointer to #1

[process]
the engine will now use the IX_Salary index to find only the rows matches the criteria, 
from that index, it'll take the identities (or addresses) of the matched rows,
with those ids, it'll fetch the actual rows from the data table. 
NO table-scan occurred this time!  

---------------------------------------------------

// TODO 

Page node ???
Leaf ???

index with bit type?
index with null?