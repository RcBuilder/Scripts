****** React ******
*******************

// TODO
=== [TOC] ==================
- Sources
- Install
- Npx Commands
- Using React
- CRA (Create-React-App)  
- Serverless
- NodeJS Express
- ReactJS.NET
- React Templates
- JSX
- File Structure
- CSS
- State
- Lifecycle
- Binding a Function
- Dynamic Content
============================


Sources
-------
// TODO

Install
-------
// TODO

Npx Commands
------------
// TODO

Using React
-----------
to use react with the built-in CRA framework (NodeJS based): 
see 'CRA (Create-React-App)'
-
to use react with NO SERVER, directly in the HTML:
see 'Serverless'
-
to use react with NodeJS & Express server: 
see 'NodeJS Express'
-
to use react in .Net MVC:
see 'ReactJS.NET'


CRA (Create-React-App)
----------------------
// TODO

Serverless
----------
// TODO

NodeJS Express
--------------
// TODO

ReactJS.NET
-----------
// TODO

React Templates
---------------
// TODO

JSX
---
// TODO

CSS
---
// TODO

multiple styles:
render() {
    let stylesA = { color: '#fff' }
	let stylesB = { backgroundColor: 'mediumvioletred' }
	let stylesC = { fontStyle: 'italic' }
        
    return (
        <>
            <h1 style={{ ...stylesA, ...stylesB, ...stylesC }}>Hello React</h1>
        </>
    )
}

-

multiple classes:
render() {
    let classA = 'cssClassA';
	let classB = 'cssClassB';
	let classC = 'cssClassC';
        
    return (
        <>
            <h1 className={`${classA} ${classB} ${classC}`}>Hello React</h1>
        </>
    )
}

State
-----
// TODO ->> check
[inheritance]
when using inheritance, by extending the 'Component' class, we have access to the base class 'State' object. 
use 'this.state' to get the current state. 
use 'this.setState' method to update the current state.

the state object can be of any type.
note that we don't have to provide the 'state' object structure beforehand. we can define it as an empty object and add properties to it on the fly.
ANY change to the 'state' - re-renders the view! (see 'Lifecycle')

a reminder - when using functions, do not forget to bind them to the component (see 'Binding a Function')

[useState model]
// TODO

Lifecycle
---------
// TODO

Binding a Function
------------------
in some cases, we lose the context of 'this' keyword so it refers to a different object than our class.
a common case is event callback (onPress, onChange etc.). to solve this issue, we need to bind 'this' to those callbacks.
the bind process is usually performed within the class constructor. 

tip: 
as a thumb-rule, it's better to bind any NON-arrow defined function.
note that the 'this' in arrow-functions always refer to the component so there's no need to bind them!

to recap:
regular function requires a binding to the component.
arrow function does NOT require a binding process.

example:
class TestEvents extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            value: ''
        };

        this.fun2 = this.fun2.bind(this);  // bind method (for regular functions)
    }
    
    fun1 = e => {
        this.setState({
            value: Math.floor(Math.random() * 1000)
        });
    }  
    
    fun2(e) {
        this.setState({
            value: Math.floor(Math.random() * 1000)
        });
    }  

    render() {
        return (
            <>
                <h5>{this.state.value}</h5>
                <p>
                    <button onClick={this.fun1}>clickMe</button>                    
                    <button onClick={this.fun2}>clickMe</button>
                </p>
            </>
        )
    }
}



Dynamic Content
---------------
we can embed content within the js code to generate a dynamic content.
we can use any of the available modules as part of our js code. (see 'JSX')

we have 2 options to do so: 
1. using code within the 'render' function.
2. using a function as a class member. 

e.g: 
// option 2
renderContent(){
    return <h1>Hello React</h1>;
}

render() {
	// option 1
    let dynamicContent = [];
        dynamicContent.push(<p>dynamic 1</p>);
        dynamicContent.push(<p>dynamic 2</p>);   

	return (
		<>
            {this.renderContent()}
            {dynamicContent}                
        </>
	);
}







-------------------------------------------

merge with React Native
see 'React Native.txt'

-

empty root node:

// syntax
<>...</>

// sample
return (
	<>
		<h1>header</h1>
		<p>body</p>
    </>
)

-

// wrapper component
use 'children' to create a wrapper component. ????
{this.props.children}
sample idea - colored boxes

-

ReactJS.NET
react with .Net (ASP.NET MVC)

sources:
https://reactjs.net/
https://reactjs.net/getting-started/aspnet.html

(steps)
1. open an MVC project (blank)
2. install react
   > Install-Package React.Web.Mvc4 -Version 5.2.7
   > JavaScriptEngineSwitcher.V8
   > Install-Package JavaScriptEngineSwitcher.V8.Native.win-x64
3. add Controller and a View
4. import react namespace to the created view 
   @using React.Web.Mvc;
5. render a component in the view
   @Html.React("TestReact", new {
		name = "Roby"
	})
6. create a new .jsx file and implement the react component 
   // Scripts/app.jsx
   class TestReact extends React.Component {
		render() {
			return (
				<div>
					<h1>Hello React</h1>
					<p>{this.props.name}</p>
				</div>
			)
		}
	}
7. App_Start > ReactConfig > set configuration for react
   public static class ReactConfig {
		public static void Configure() {
            ReactSiteConfiguration.Configuration
                .AddScript("~/Scripts/app.jsx");
			JsEngineSwitcher.Current.DefaultEngineName = V8JsEngine.EngineName;
            JsEngineSwitcher.Current.EngineFactories.AddV8();
        }
    }
8. Build

references:
see 'ReactJS.NET server & client rendering'
see 'ReactJS.NET render using @Html.React'
see 'ReactJS.NET render using js libraries'
see 'ReactJS.NET component in component'

-

react-bundle:
System.Web.Optimization.React  ???

-

ReactJS.NET server & client rendering:

important! 
when using server react rendering (using @Html.React) 
the jsx files are NOT being rendered to the client and therefore, client events, logs and etc will not work!!
to perform a client rendering we need to add client reference to the jsx files (at the header) and call the @Html.ReactInitJavaScript method (at the bottom)

// note
alternatively, we can use the 'ReactDOM.render' to inject the component to a DOM element.
see 'ReactJS.NET render using js libraries'


// using
<script src="~/Scripts/React/component1.jsx"></script>
<script src="~/Scripts/React/component2.jsx"></script>

@Html.React("component1", new {})
@Html.React("component2", new {})

<!-- render react components in the client -->
@Html.ReactInitJavaScript()

- 

ReactJS.NET component in component:

notes:
use the ReactConfig to import all related jsx files. 
do not use the keyword 'import' within the jsx files (its already imported)

// ReactConfig.cs
using JavaScriptEngineSwitcher.Core;
using JavaScriptEngineSwitcher.V8;
using React;

public static class ReactConfig {
	public static void Configure() {
        ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/comp.jsx")
            .AddScript("~/Scripts/app.jsx");  

        JsEngineSwitcher.Current.DefaultEngineName = V8JsEngine.EngineName;
        JsEngineSwitcher.Current.EngineFactories.AddV8();
    }
}

// comp.jsx
class TestComp extends React.Component {
    render() {
        return (<h1>Hello Component</h1>)
    }
}

// app.jsx
class TestReact extends React.Component {
    render() {
        return (
            <div>
                <h1>Hello React</h1>
                <p>{this.props.name}</p>   
				<TestComp />
            </div>
        )
    }
}

-

ReactJS.NET render using @Html.React:
server rendering.

note!
only server rendering. 
this technique renders the components in the server and does NOT pull them into the client (see 'ReactJS.NET server & client rendering')

// ReactConfig.cs
using JavaScriptEngineSwitcher.Core;
using JavaScriptEngineSwitcher.V8;
using React;

public static class ReactConfig {
	public static void Configure() {
        ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/app.jsx");            

        JsEngineSwitcher.Current.DefaultEngineName = V8JsEngine.EngineName;
        JsEngineSwitcher.Current.EngineFactories.AddV8();
    }
}

// Index.cshtml
@Html.React("TestReact", new {
    name = "Roby"
})

// app.jsx
class TestReact extends React.Component {
    render() {
        return (
            <div>
                <h1>Hello React</h1>
                <p>{this.props.name}</p>                
            </div>
        )
    }
}

-

ReactJS.NET render using js libraries:
client rendering.

// _Layout.cshtml
@RenderSection("scripts", required: false)

// Index.cshtml
<div id="root"></div>
@section scripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>

    <script src="~/Scripts/app.jsx"></script>    
}

// app.jsx
class TestReact extends React.Component {
    render() {
        return (
            <div>
                <h1>Hello React</h1>
                <p>{this.props.name}</p>
            </div>
        )
    }
}
ReactDOM.render(<TestReact name="Roby" />, document.getElementById('root'));

-

ReactJS.NET styles

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/testCss.jsx");

// Index.cshtml
<p>using inline styles</p>
@Html.React("TestCss1", new {
    headerColor = "red"
})

<p>using inline styles with a js-object</p>
@Html.React("TestCss2", new
{
    headerColor = "purple"
})

<p>using css class</p>
<style type="text/css">
    .header {
        color: #fff;
        background-color: mediumvioletred;
    }
</style>

@Html.React("TestCss3", new
{
    headerClass = "header"
})

// testCss.jsx
class TestCss1 extends React.Component {
    render() {
        return (
            <div>
                <h1 style={{ color: this.props.headerColor }}>Hello Css 1</h1>
                <p>props: {this.props.headerColor}</p>                                   
            </div>
        )
    }
}

class TestCss2 extends React.Component {
    render() {
        const headerStyles = {
            color: this.props.headerColor,
            textDecoration: 'underline'
        };

        return (
            <div>
                <h1 style={headerStyles}>Hello Css 2</h1>
                <p>props: {this.props.headerColor}</p>
            </div>
        )
    }
}

class TestCss3 extends React.Component {
    render() {
        return (
            <div>
                <h1 className={this.props.headerClass}>Hello Css 3</h1>
                <p>props: {this.props.headerClass}</p>
            </div>
        )
    }
}

class TestCss4 extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            classA: 'classA'
        };
    }

    getClassB = () => {
        return 'classB';
    }

    render() {
        let classC = 'classC';

        return (
            <>
                <h1 className={`${this.state.classA} ${this.getClassB()} ${classC}`}>Hello Css 4</h1>
                <p>multiple classes</p>
            </>
        )
    }
}

class TestCss5 extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            stylesA: {
                color: '#fff'
            }
        };
    }

    getStylesB = () => {
        return {
            backgroundColor: 'mediumvioletred'
        };
    }

    render() {
        let stylesC = {
            fontStyle: 'italic'
        };
        
        return (
            <>
                <h1 style={{ ...this.state.stylesA, ...this.getStylesB(), ...stylesC }}>Hello Css 5</h1>
                <p>multiple styles</p>
            </>
        )
    }
}

-

ReactJS.NET Lifecycle:

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/React/testLifecycle.jsx");

// Index.cshtml

<p>Mounting</p>
<p>occurs when a component is created.</p>
@Html.React("TestMounting", new {})
<pre>
    [TestMounting] constructor
    [TestMounting] pre-render
    [TestMounting] render
    [TestMounting] post-render    
</pre>

<p>Updating</p>
<p>occurs when a component is updated (there was a change in the state or props).</p>
@Html.React("TestUpdating", new { })
<pre>
    [TestUpdating] onstructor
    [TestUpdating] pre-render
    [TestUpdating] render

    -- after click --

    [TestUpdating] executing doSomeChange method..
    [TestUpdating] pre-render
    [TestUpdating] should perform the update
    [TestUpdating] render
    [TestUpdating] get the state before the change
    [TestUpdating] post-render
</pre>

<p>Unmounting</p>
<p>occurs when a component is removed from the DOM.</p>
@Html.React("TestUnmounting", new { })
<pre>
    [TestUnmounting] constructor
    [TestUnmounting] render
    [ChildComponent] constructor
    [ChildComponent] render

    -- after click --

    [TestUnmounting] executing removeComponent method..
    [TestUnmounting] render
    [ChildComponent] pre-remove
</pre>

@section scripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>    
    <script src="~/Scripts/React/testLifecycle.jsx"></script>

	<!-- render react components in the client -->
	@Html.ReactInitJavaScript()
}


// testLifecycle.jsx
class TestMounting extends React.Component {
    constructor(props) {
        super(props);
        this.state = {};
        
        console.log('[TestMounting] constructor');
    }

    static getDerivedStateFromProps(props, state) {
        console.log('[TestMounting] pre-render');        
    }

    componentDidMount() {                
        console.log('[TestMounting] post-render');
    } 
    
    render() {
        console.log('[TestMounting] render');
        
        return (
            <div>
                <h1>Hello Lifecycle</h1>
                <p>see console output</p>                
            </div>
        )
    }
}

class TestUpdating extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            someValue: 1
        };
        
        console.log('[TestUpdating] onstructor');
    }

    static getDerivedStateFromProps(props, state) {
        console.log('[TestUpdating] pre-render');
    }

    shouldComponentUpdate() {
        console.log('[TestUpdating] should perform the update');
        return true;
    }

    getSnapshotBeforeUpdate(prevProps, prevState) {
        console.log('[TestUpdating] get the state before the change');
    }

    componentDidUpdate() {
        console.log('[TestUpdating] post-render');
    } 

    doSomeChange = e => {
        console.log('[TestUpdating] executing doSomeChange method..');
        this.setState({ someValue: 2 });
    }

    render() {
        console.log('[TestUpdating] render');

        return (
            <div>
                <h1>Hello Lifecycle</h1>
                <p>see console output</p>
                <p><button onClick={this.doSomeChange}>clickMe</button></p>
            </div>
        )
    }
}

class TestUnmounting extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            render: true
        };

        console.log('[TestUnmounting] constructor');
    }

    removeComponent = e => {
        console.log('[TestUnmounting] executing removeComponent method..');
        this.setState({ render: false });
    }
    
    render() {
        console.log('[TestUnmounting] render');

        let childComponent = this.state.render ? <ChildComponent /> : null;

        return (
            <div>
                {childComponent}
                <p>see console output</p>
                <p><button onClick={this.removeComponent}>clickMe</button></p>
            </div>
        )
    }
}

class ChildComponent extends React.Component {
    constructor(props) {
        super(props);
        console.log('[ChildComponent] constructor');
    }

    componentWillUnmount() {
        console.log('[ChildComponent] pre-remove')
    }

    render() {
        console.log('[ChildComponent] render');
        return <h1>Hello Lifecycle</h1>;
    }
}

-

ReactJS.NET State:

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/React/testState.jsx");

// Index.cshtml
<p>change state</p>
@Html.React("TestState", new { })

@section scripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>    
    <script src="~/Scripts/React/testState.jsx"></script>

	<!-- render react components in the client -->
	@Html.ReactInitJavaScript()
}

// testState.jsx
class TestState extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            p1: 'value-1',
            p2: 'value-2'
        };        
    }

    changeP1 = e => {
		// option1 to update a state
        this.state.p1 = `value-${Math.floor(Math.random() * 1000)}`;
        this.setState(this.state);
    }

    changeP2 = e => {        
		// option2 to update a state
        this.setState({
            p2: `value-${Math.floor(Math.random() * 1000)}`
        });
    }

    render() {
        return (
            <div>
                <p>{this.state.p1}</p>
                <p>{this.state.p2}</p>
                <p>
                    <button onClick={this.changeP1}>change-p1</button>                    
                    <button onClick={this.changeP2}>change-p2</button>
                </p>
            </div>
        )
    }
}

-

ReactJS.NET Events:

notes:
- for arrow function - no binding is required! 'this' refers to the component.
- for regular function - binding is required!

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/React/testEvents.jsx");


// Index.cshtml
<p>arrow & regular functions</p>
@Html.React("TestEvents", new { })

@section scripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>    
    <script src="~/Scripts/React/testEvents.jsx"></script>
		
	<!-- render react components in the client -->
	@Html.ReactInitJavaScript()
}


// testEvents.jsx
class TestEvents extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            value: ''
        };

        this.fun2 = this.fun2.bind(this);  // bind method (for regular functions)
    }
    
    fun1 = e => {
        this.setState({
            value: Math.floor(Math.random() * 1000)
        });
    }  
    
    fun2(e) {
        this.setState({
            value: Math.floor(Math.random() * 1000)
        });
    }  

    render() {
        return (
            <div>
                <h5>{this.state.value}</h5>
                <p>
                    <button onClick={this.fun1}>clickMe</button>                    
                    <button onClick={this.fun2}>clickMe</button>
                </p>
            </div>
        )
    }
}

-

ReactJS.NET Forms:

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/React/testForms.jsx");

// Index.cshtml
<p>onChange and onSubmit</p>
@Html.React("TestForm1", new {})

<p>setInput using name</p>
@Html.React("TestForm2", new { })

<p>special tags</p>
@Html.React("TestForm3", new { })

<p>React ref</p>
@Html.React("TestForm4", new { })

@section scripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>    
    <script src="~/Scripts/React/testForms.jsx"></script>

	<!-- render react components in the client -->
	@Html.ReactInitJavaScript()
}


// testForms.jsx
class TestForm1 extends React.Component {
    constructor() {
        super();
        this.state = {
            input1: '',
            input2: ''
        };
    }

    setInput1 = e => {
        this.setState({
            input1: e.target.value
        });
    }

    setInput2 = e => {
        this.setState({
            input2: e.target.value
        });
    }

    submitForm = e => {
        e.preventDefault();
        // code here...
    }

    render() {
        return (
            <form onSubmit={this.submitForm}>
                <h1>Test Form 1</h1>
                <input type="text" placeholder="input-1" onChange={this.setInput1} />
                &nbsp;&nbsp;<span>{this.state.input1}</span>
                <br /><br />
                <input type="text" placeholder="input-2" onChange={this.setInput2} />
                &nbsp;&nbsp;<span>{this.state.input2}</span>
                <br /><br />
                <p><input type="submit" value="SUBMIT" /></p>
            </form>
        )
    }
}

class TestForm2 extends React.Component {
    constructor() {
        super();
        this.state = {
            input1: '',
            input2: ''
        };
    }

    setInput = e => {
        this.setState({
            [e.target.name]: e.target.value
        });
    }

    render() {
        return (
            <form>
                <h1>Test Form 2</h1>
                <input type="text" placeholder="input-1" onChange={this.setInput} name="input1" />
                &nbsp;&nbsp;<span>{this.state.input1}</span>
                <br /><br />
                <input type="text" placeholder="input-2" onChange={this.setInput} name="input2" />
                &nbsp;&nbsp;<span>{this.state.input2}</span>              
                <br /><br />
            </form>
        )
    }
}

class TestForm3 extends React.Component {
    constructor() {
        super();
        this.state = {
            selectedValue: '2',
            description: 'bla bla bla...'
        };
    }

    setSelectedValue = e => {
        this.setState({
            selectedValue: e.target.value
        });
    }

    render() {        
        return (
            <form>
                <h1>Test Form 3</h1>
                <select value={this.state.selectedValue} onChange={this.setSelectedValue}>
                    <option value="1">Value1</option>
                    <option value="2">Value2</option>
                    <option value="3">Value3</option>
                </select>
                <br /><br />
                select value is {this.state.selectedValue}                
                <br /><br />
                <textarea value={this.state.description} />
                <br /><br />
            </form>
        )
    }
}

class TestForm4 extends React.Component {
    constructor() {
        super();
        this.form = React.createRef();        
    }

    submitForm = e => {
        e.preventDefault();
        console.log(this.form.current);  // reference to the current form!
        // code here...
    }

    render() {
        return (
            <form ref={this.form} onSubmit={this.submitForm}>
                <h1>Test Form 4</h1>
                <p><input type="submit" value="SUBMIT" /></p>
            </form>
        )
    }
}

-

BUG:
ReactJS.NET
Ex -> Cannot use import statement outside a module 
cause -> can't use the keyword 'import' within a jsx file.
solution -> remove all 'import' caluses, use the 'ReactConfig.cs' to register all jsx files. this will auto-import them so they all would be available to use.
see 'ReactJS.NET component in component'

BUG:
ReactJS.NET
Ex -> React is not defined
cause -> there are no react libraries imported 
solution -> add reference to react client engine 
see 'ReactJS.NET render using js libraries'

BUG:
ReactJS.NET
Issue -> No Client events nor console log
cause -> server rendering only!
solution -> render react in the client 
see 'ReactJS.NET server & client rendering'

- 

about:
React is a JavaScript library created by Facebook.
it creates a virtual DOM (in memory), apply the changes there and only then update the actual DOM. 
React library uses JSX which stands for 'JavaScript XML' and allows us to add HTML tags within the script. 

-

[react]
escape curly brackets -> '{' and '}' 
{'{...}'}

-

cra - multiple pages ???

-

client routing ???

-

ReactDOM.render
https://www.pluralsight.com/guides/just-plain-react

- 

render using express server 

-

cra = create-react-app 

// install app-creator (globally)
> npm install -g create-react-app

-

// create an app using npx
> npx create-react-app test-react
-OR-
// create an app using npm
> npm init react-app test-react

// run 
// start and launch server 
> npm start

// build (for deployment)
// creates a minified bundle
> npm run build

-

syntax:
--template <template-name>

templates:
https://www.npmjs.com/search?q=cra-template-*

e.g:
> npx create-react-app my-app --template typescript

-

[typescript]

new project:
// use template
> npx create-react-app my-app --template typescript

existing project:
1. > npm install --save typescript @types/node @types/react @types/react-dom @types/jest
2. change any .js file to .tsx
3. restart your development server!

- 

Blank-app???

-
 
%PUBLIC_URL%/favicon.ico ???

-

[react with no server]
ReactDOM.render

// in HTML
<script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>

<div id="root"></div>

<script type="text/babel">
    class TestReact extends React.Component {
		render() {
			return (<h1>Hello World!</h1>)
		}
    }

    ReactDOM.render(<TestReact />, document.getElementById('root'));
</script>

-

basic sample using 'create-react-app':

// index.js
import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import './index.css';

class Test extends Component {
    constructor() {
        super();
        this.state = {
            p1: 'value-1', 
            p2: 'value-2'
        };
    }
    
    changeP1 = e => {
        this.state.p1 = `value-${Math.floor(Math.random() * 1000)}`;
        this.setState(this.state);
    }

    render() {
        return (<div>
            <h1 className="blue">Hello World</h1>
            <p>{this.state.p1}</p>
            <p>{this.state.p2}</p>
            <p><button onClick={this.changeP1}>change-p1</button></p>
        </div>)
    }
}

ReactDOM.render(<Test />, document.getElementById('root'));

-

[render]

note: 
MUST include root element (like a valid XML)!


// render a class (component)
class ClassA extends React.Component {
	render() {
		return (<h1>Hello World!</h1>)
	}
}
ReactDOM.render(<ClassA />, document.getElementById('root'));

// render a function (component)
function FunA() {	
	return (<h1>Hello World!</h1>);	
}
ReactDOM.render(<FunA />, document.getElementById('root'));

// render an element
const elem = (<h1 className="red">Hello World</h1>);
ReactDOM.render(elem, document.getElementById('root'));

// direct rendering 
ReactDOM.render(<h1 className="red">Hello World</h1>, document.getElementById('root'));

// render content
const content = ((<div>
    <h1 className="blue">Hello World</h1>
    <p>P1</p>
    <p>P2</p>    
</div>));
ReactDOM.render(content, document.getElementById('root'));

- 

render multiple: 
<div id="root1"></div>
<div id="root2"></div>

ReactDOM.render(<h1>Hello Root 1</h1>, document.getElementById('root1'));
ReactDOM.render(<h1>Hello Root 2</h1>, document.getElementById('root2'));

-

// bind an processed element
class Test extends Component {    
    render() {
        let arr = ['Random-Header-1', 'Random-Header-2', 'Random-Header-3', 'Random-Header-4', 'Random-Header-5'];
        let header = <h1>{arr[Math.floor(Math.random() * arr.length)]}</h1>;

        return (
            <div>
                {header}
				<p>Paragraph</p>
				<p>Paragraph</p>
            </div>
        )
    }
}

-

[props]
passing arguments using tag attributes syntax.
we can pass any type as props (string, number, object etc.)

recommendation:
always pass the props to the parent component.

using:
class ClassA extends React.Component {
	constructor(props) {
		super(props);   
	}

	render() {
		return (<h1>Hello {this.props.name}!</h1>)
	}
}
ReactDOM.render(<ClassA name="Roby" />, document.getElementById('root'));

-

[component in component]
class ClassA extends React.Component {
    render() {
        return (
            <div>
                <h1>Hello {this.props.name}!</h1>
                <ClassB />
            </div>
		)
    }
}

class ClassB extends React.Component {
    render() {
        return (
            <div>
                <p>Paragraph 1</p>
                <p>Paragraph 2</p>
            </div>
		)
    }
}

ReactDOM.render(<ClassA name="Roby" />, document.getElementById('root'));

-

[external components]
use 'export' keyword to expose the component to be able to use it from other files.

// ComponentA.js
import React from 'react';
import ReactDOM from 'react-dom';

class ComponentA extends React.Component {
	render() {
		return <h2>Hi ComponentA</h2>;	 
	}
}
export default ComponentA;


// index.js
import React from 'react';
import ReactDOM from 'react-dom';
import ComponentA from './ComponentA.js';

ReactDOM.render(<ComponentA />, document.getElementById('root'));

-

[state]
- init the state in the constructor.
- use state.<propName> anywhere within the component.
- use setState to update the state. setState method allows us to update the full state object or only partial properties. 

setState(<newState>);  // full update 
setState({ <propName>: <value>});  // partial update

sample:
class Test extends Component {
    constructor() {
        super();
        this.state = {
            p1: 'value-1', 
            p2: 'value-2'
        };
    }
    
    changeP1 = e => {
        this.state.p1 = `value-${Math.floor(Math.random() * 100)}`;
        this.setState(this.state);
    }

    render() {
        return (<div>
            <h1 className="blue">Hello World</h1>
            <p>{this.state.p1}</p>
            <p>{this.state.p2}</p>
            <p><button onClick={this.changeP1}>change-p1</button></p>
        </div>)
    }
}

-

[Lifecycle]
the component's lifecycle. 

operations:
1. Mounting	   
   occurs when a component is created.

2. Updating	
   occurs when a component is updated (there was a change in the state or props)

3. Unmounting
   occurs when a component is removed from the DOM.

Mounting lifecycle:
- constructor				// init component 
- getDerivedStateFromProps	// pre-render. signature: static getDerivedStateFromProps(props, state);  
- render					// render 
- componentDidMount			// post-render

Updating lifecycle:
- getDerivedStateFromProps	// pre-render. signature: static getDerivedStateFromProps(props, state);  
- shouldComponentUpdate		// determine whether to continue with the update process or not (default: true)
- render					// render
- getSnapshotBeforeUpdate	// get access to the state and props before the changes. signature: getSnapshotBeforeUpdate(prevProps, prevState);
- componentDidUpdate		// post-render

Unmounting lifecycle:
- componentWillUnmount		// pre-remove. right before removing the component. 

using:
// the value of 'p1' will be updated after 2 seconds.
class Test extends Component {
    constructor(props) {
        super(props);
        this.state = {
            p1: 'value-1'
        };       
    }

	componentDidMount() {
		setTimeout(() => {
			this.setState({ p1: "value-1-updated" })
		}, 2000)
	}

	render() {
        return (<p>{this.state.p1}</p>)
    }
}

-

[Events]
React supports the same events as HTML.
it uses the same evente name but in camelcase mode (onclick -> onClick etc.)

tip: 
use arrow functions to refer 'this' always as the component. 

important! 
when using regular functions instead of arrows, we MUST bind the function using the 'bind' method.
this.fun1 = this.fun1.bind(this);

sample:
class Test extends Component {    
	constructor(props) {
		super(props)
		this.fun2 = this.fun2.bind(this);  // bind method (for regular functions)
	}	

	fun1 = e => { ... }  // arrow function - no binding is required! 'this' refers to the component.
    fun2(e) { ... }  // regular function - binding is required!

    render() {
        return (
			<div>
				<button onClick={this.fun1}>clickMe</button>
				<button onClick={this.fun2}>clickMe</button>
			</div>
		)
    }
}

-

[Forms]
when using forms in react, we need to update the component's state on each change. 
we do that using the 'onChange' event of the input.
we can also use 'onSubmit' event to be triggered when the form is about to be submitted.
to revoke the actual submit action, we can call 'preventDefault' method of the event.

validations:
we can handle validations as part of each change or when submitting the form. 
we can use the state to collect errors and present them as a summary in the html.

textarea tag:
unlike in HTML, in React, the value of a TextArea is set using a 'value' attribute and NOT as innerText.
// e.g 
<textarea value={this.state.description} />
<textarea value="some description..." />

select tag:
unlike in HTML, in React, the selected value is controlled by a 'value' attribute of the 'select' tag and NOT as the option's 'selected'.
// e.g
<select value={this.state.selectedValue}>
    <option value="1">Value1</option>
    <option value="2">Value2</option>
    <option value="3">Value3</option>
</select>
<select value="2">
    <option value="1">Value1</option>
    <option value="2">Value2</option>
    <option value="3">Value3</option>
</select>

using:
class TestForm extends Component {
    constructor() {
        super();
        this.state = {
            input1: '',
            input2: ''
        };
    }

    setInput1 = e => {
        this.setState({
            input1: e.target.value
        });
    }

    setInput2 = e => {
        this.setState({
            input2: e.target.value
        });
    }

	submitForm = e => {
		e.preventDefault();
		// code here...
	}

    render() {
        return (
            <form onSubmit={this.submitForm}>
                <h1>Test Form</h1>
                <input type="text" placeholder="input-1" onChange={this.setInput1} />
                &nbsp;&nbsp;<span>{this.state.input1}</span>
                <br /><br />
                <input type="text" placeholder="input-2" onChange={this.setInput2} />                                
                &nbsp;&nbsp;<span>{this.state.input2}</span>
				<br /><br />
				<input type="submit" />
            </form>
        )
    }
}

ReactDOM.render(<TestForm />, document.getElementById('root'));

-

[CSS]
- inline 
- inline using a js-object 
- css file

inline:
style={{ <name>:<value>... }}

inline using a js-object:
style={ <stylesObject> }

css file:
import <cssFile>;
className="<className>"


sample:
import './index.css';

class TestStyles extends Component {
    render() {
		const p2Styles = {
			color: "yellow", 
			backgroundColor: "blue"
		};

        return (<div>            
            <p style={{color: "blue", backgroundColor: "yellow"}}>Paragraph 1</p>
            <p style={p2Styles}>Paragraph 2</p>
            <p className="red">Paragraph 3</p>            
        </div>)
    }
}

-

[Sass]
CSS pre-processor. 
files with .scss extension.

install:
> npm install --save node-sass

sample:
import './index.scss';

// jsx
<h6 className="title">Hello World</h6>

// scss
$size: 20px;
$color: purple;

h6.title {
    font-size: $size;
    color: $color;
    border:dashed 1px #808080;
    padding: 8px;
    margin: 0px;
}

- 

React ref:
// declare a ref
constructor(props) {
    super(props);    
    this.textInput = React.createRef();    
  }

 // bind a ref
 <input type="text" ref={this.textInput} />

 // access  
 this.textInput.current;

 -

 React.createRef
 see 'React ref'