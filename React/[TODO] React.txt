****** React ******
*******************

=== [TOC] ==================
-
-
-
-
-
-
============================


// TODO 
merge with React Native
see 'React Native.txt'




-------------------------------------------

ReactJS.NET
react with .Net (ASP.NET MVC)

sources:
https://reactjs.net/
https://reactjs.net/getting-started/aspnet.html

(steps)
1. open an MVC project (blank)
2. install react
   > Install-Package React.Web.Mvc4 -Version 5.2.7
   > JavaScriptEngineSwitcher.V8
   > Install-Package JavaScriptEngineSwitcher.V8.Native.win-x64
3. add Controller and a View
4. import react namespace to the created view 
   @using React.Web.Mvc;
5. render a component in the view
   @Html.React("TestReact", new {
		name = "Roby"
	})
6. create a new .jsx file and implement the react component 
   // Scripts/app.jsx
   class TestReact extends React.Component {
		render() {
			return (
				<div>
					<h1>Hello React</h1>
					<p>{this.props.name}</p>
				</div>
			)
		}
	}
7. App_Start > ReactConfig > set configuration for react
   public static class ReactConfig {
		public static void Configure() {
            ReactSiteConfiguration.Configuration
                .AddScript("~/Scripts/app.jsx");
			JsEngineSwitcher.Current.DefaultEngineName = V8JsEngine.EngineName;
            JsEngineSwitcher.Current.EngineFactories.AddV8();
        }
    }
8. Build

references:
see 'ReactJS.NET server & client rendering'
see 'ReactJS.NET render using @Html.React'
see 'ReactJS.NET render using js libraries'
see 'ReactJS.NET component in component'

-

ReactJS.NET server & client rendering:

important! 
when using server react rendering (using @Html.React) 
the jsx files are NOT being rendered to the client and therefore, client events, logs and etc will not work!!
to perform a client rendering we need to add client reference to the jsx files (at the header) and call the @Html.ReactInitJavaScript method (at the bottom)

// note
alternatively, we can use the 'ReactDOM.render' to inject the component to a DOM element.
see 'ReactJS.NET render using js libraries'


// using
<script src="~/Scripts/React/component1.jsx"></script>
<script src="~/Scripts/React/component2.jsx"></script>

@Html.React("component1", new {})
@Html.React("component2", new {})

<!-- render react components in the client -->
@Html.ReactInitJavaScript()

- 

ReactJS.NET component in component:

notes:
use the ReactConfig to import all related jsx files. 
do not use the keyword 'import' within the jsx files (its already imported)

// ReactConfig.cs
using JavaScriptEngineSwitcher.Core;
using JavaScriptEngineSwitcher.V8;
using React;

public static class ReactConfig {
	public static void Configure() {
        ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/comp.jsx")
            .AddScript("~/Scripts/app.jsx");  

        JsEngineSwitcher.Current.DefaultEngineName = V8JsEngine.EngineName;
        JsEngineSwitcher.Current.EngineFactories.AddV8();
    }
}

// comp.jsx
class TestComp extends React.Component {
    render() {
        return (<h1>Hello Component</h1>)
    }
}

// app.jsx
class TestReact extends React.Component {
    render() {
        return (
            <div>
                <h1>Hello React</h1>
                <p>{this.props.name}</p>   
				<TestComp />
            </div>
        )
    }
}

-

ReactJS.NET render using @Html.React:
server rendering.

note!
only server rendering. 
this technique renders the components in the server and does NOT pull them into the client (see 'ReactJS.NET server & client rendering')

// ReactConfig.cs
using JavaScriptEngineSwitcher.Core;
using JavaScriptEngineSwitcher.V8;
using React;

public static class ReactConfig {
	public static void Configure() {
        ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/app.jsx");            

        JsEngineSwitcher.Current.DefaultEngineName = V8JsEngine.EngineName;
        JsEngineSwitcher.Current.EngineFactories.AddV8();
    }
}

// Index.cshtml
@Html.React("TestReact", new {
    name = "Roby"
})

// app.jsx
class TestReact extends React.Component {
    render() {
        return (
            <div>
                <h1>Hello React</h1>
                <p>{this.props.name}</p>                
            </div>
        )
    }
}

-

ReactJS.NET render using js libraries:
client rendering.

// _Layout.cshtml
@RenderSection("scripts", required: false)

// Index.cshtml
<div id="root"></div>
@section scripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>

    <script src="~/Scripts/app.jsx"></script>    
}

// app.jsx
class TestReact extends React.Component {
    render() {
        return (
            <div>
                <h1>Hello React</h1>
                <p>{this.props.name}</p>
            </div>
        )
    }
}
ReactDOM.render(<TestReact name="Roby" />, document.getElementById('root'));

-

ReactJS.NET styles

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/testCss.jsx");

// Index.cshtml
<p>using inline styles</p>
@Html.React("TestCss1", new {
    headerColor = "red"
})

<p>using inline styles with a js-object</p>
@Html.React("TestCss2", new
{
    headerColor = "purple"
})

<p>using css class</p>
<style type="text/css">
    .classA {
        color: #fff;
        background-color: mediumvioletred;
    }
</style>

@Html.React("TestCss3", new
{
    headerClass = "classA"
})

// testCss.jsx
class TestCss1 extends React.Component {
    render() {
        return (
            <div>
                <h1 style={{ color: this.props.headerColor }}>Hello Css 1</h1>
                <p>props: {this.props.headerColor}</p>                                   
            </div>
        )
    }
}

class TestCss2 extends React.Component {
    render() {
        const headerStyles = {
            color: this.props.headerColor,
            textDecoration: 'underline'
        };

        return (
            <div>
                <h1 style={headerStyles}>Hello Css 2</h1>
                <p>props: {this.props.headerColor}</p>
            </div>
        )
    }
}

class TestCss3 extends React.Component {
    render() {
        return (
            <div>
                <h1 className={this.props.headerClass}>Hello Css 3</h1>
                <p>props: {this.props.headerClass}</p>
            </div>
        )
    }
}

-

ReactJS.NET Lifecycle:

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/React/testLifecycle.jsx");

// Index.cshtml
@section headerScripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>    
    <script src="~/Scripts/React/testLifecycle.jsx"></script>
}

<p>Mounting</p>
<p>occurs when a component is created.</p>
@Html.React("TestMounting", new {})
<pre>
    [TestMounting] constructor
    [TestMounting] pre-render
    [TestMounting] render
    [TestMounting] post-render    
</pre>

<p>Updating</p>
<p>occurs when a component is updated (there was a change in the state or props).</p>
@Html.React("TestUpdating", new { })
<pre>
    [TestUpdating] onstructor
    [TestUpdating] pre-render
    [TestUpdating] render

    -- after click --

    [TestUpdating] executing doSomeChange method..
    [TestUpdating] pre-render
    [TestUpdating] should perform the update
    [TestUpdating] render
    [TestUpdating] get the state before the change
    [TestUpdating] post-render
</pre>

<p>Unmounting</p>
<p>occurs when a component is removed from the DOM.</p>
@Html.React("TestUnmounting", new { })
<pre>
    [TestUnmounting] constructor
    [TestUnmounting] render
    [ChildComponent] constructor
    [ChildComponent] render

    -- after click --

    [TestUnmounting] executing removeComponent method..
    [TestUnmounting] render
    [ChildComponent] pre-remove
</pre>

<!-- render react components in the client -->
@Html.ReactInitJavaScript()


// testLifecycle.jsx
class TestMounting extends React.Component {
    constructor(props) {
        super(props);
        this.state = {};
        
        console.log('[TestMounting] constructor');
    }

    static getDerivedStateFromProps(props, state) {
        console.log('[TestMounting] pre-render');        
    }

    componentDidMount() {                
        console.log('[TestMounting] post-render');
    } 
    
    render() {
        console.log('[TestMounting] render');
        
        return (
            <div>
                <h1>Hello Lifecycle</h1>
                <p>see console output</p>                
            </div>
        )
    }
}

class TestUpdating extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            someValue: 1
        };
        
        console.log('[TestUpdating] onstructor');
    }

    static getDerivedStateFromProps(props, state) {
        console.log('[TestUpdating] pre-render');
    }

    shouldComponentUpdate() {
        console.log('[TestUpdating] should perform the update');
        return true;
    }

    getSnapshotBeforeUpdate(prevProps, prevState) {
        console.log('[TestUpdating] get the state before the change');
    }

    componentDidUpdate() {
        console.log('[TestUpdating] post-render');
    } 

    doSomeChange = e => {
        console.log('[TestUpdating] executing doSomeChange method..');
        this.setState({ someValue: 2 });
    }

    render() {
        console.log('[TestUpdating] render');

        return (
            <div>
                <h1>Hello Lifecycle</h1>
                <p>see console output</p>
                <p><button onClick={this.doSomeChange}>clickMe</button></p>
            </div>
        )
    }
}

class TestUnmounting extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            render: true
        };

        console.log('[TestUnmounting] constructor');
    }

    removeComponent = e => {
        console.log('[TestUnmounting] executing removeComponent method..');
        this.setState({ render: false });
    }
    
    render() {
        console.log('[TestUnmounting] render');

        let childComponent = this.state.render ? <ChildComponent /> : null;

        return (
            <div>
                {childComponent}
                <p>see console output</p>
                <p><button onClick={this.removeComponent}>clickMe</button></p>
            </div>
        )
    }
}

class ChildComponent extends React.Component {
    constructor(props) {
        super(props);
        console.log('[ChildComponent] constructor');
    }

    componentWillUnmount() {
        console.log('[ChildComponent] pre-remove')
    }

    render() {
        console.log('[ChildComponent] render');
        return <h1>Hello Lifecycle</h1>;
    }
}

-

BUG:
ReactJS.NET
Ex -> Cannot use import statement outside a module 
cause -> can't use the keyword 'import' within a jsx file.
solution -> remove all 'import' caluses, use the 'ReactConfig.cs' to register all jsx files. this will auto-import them so they all would be available to use.
see 'ReactJS.NET component in component'

BUG:
ReactJS.NET
Ex -> React is not defined
cause -> there are no react libraries imported 
solution -> add reference to react client engine 
see 'ReactJS.NET render using js libraries'

BUG:
ReactJS.NET
Issue -> No Client events nor console log
cause -> server rendering only!
solution -> render react in the client 
see 'ReactJS.NET server & client rendering'

- 

about:
React is a JavaScript library created by Facebook.
it creates a virtual DOM (in memory), apply the changes there and only then update the actual DOM. 
React library uses JSX which stands for 'JavaScript XML' and allows us to add HTML tags within the script. 

-

[react]
escape curly brackets -> '{' and '}' 
{'{...}'}

-

cra - multiple pages ???

-

client routing ???

-

ReactDOM.render
https://www.pluralsight.com/guides/just-plain-react

- 

render using express server 

-

cra = create-react-app 

// install app-creator (globally)
> npm install -g create-react-app

-

// create an app using npx
> npx create-react-app test-react
-OR-
// create an app using npm
> npm init react-app test-react

// run 
// start and launch server 
> npm start

// build (for deployment)
// creates a minified bundle
> npm run build

-

syntax:
--template <template-name>

templates:
https://www.npmjs.com/search?q=cra-template-*

e.g:
> npx create-react-app my-app --template typescript

-

[typescript]

new project:
// use template
> npx create-react-app my-app --template typescript

existing project:
1. > npm install --save typescript @types/node @types/react @types/react-dom @types/jest
2. change any .js file to .tsx
3. restart your development server!

- 

Blank-app???

-
 
%PUBLIC_URL%/favicon.ico ???

-

[react with no server]
ReactDOM.render

// in HTML
<script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>

<div id="root"></div>

<script type="text/babel">
    class TestReact extends React.Component {
		render() {
			return (<h1>Hello World!</h1>)
		}
    }

    ReactDOM.render(<TestReact />, document.getElementById('root'));
</script>

-

basic sample using 'create-react-app':

// index.js
import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import './index.css';

class Test extends Component {
    constructor() {
        super();
        this.state = {
            p1: 'value-1', 
            p2: 'value-2'
        };
    }
    
    changeP1 = e => {
        this.state.p1 = `value-${Math.floor(Math.random() * 1000)}`;
        this.setState(this.state);
    }

    render() {
        return (<div>
            <h1 className="blue">Hello World</h1>
            <p>{this.state.p1}</p>
            <p>{this.state.p2}</p>
            <p><button onClick={this.changeP1}>change-p1</button></p>
        </div>)
    }
}

ReactDOM.render(<Test />, document.getElementById('root'));

-

[render]

note: 
MUST include root element (like a valid XML)!


// render a class (component)
class ClassA extends React.Component {
	render() {
		return (<h1>Hello World!</h1>)
	}
}
ReactDOM.render(<ClassA />, document.getElementById('root'));

// render a function (component)
function FunA() {	
	return (<h1>Hello World!</h1>);	
}
ReactDOM.render(<FunA />, document.getElementById('root'));

// render an element
const elem = (<h1 className="red">Hello World</h1>);
ReactDOM.render(elem, document.getElementById('root'));

// direct rendering 
ReactDOM.render(<h1 className="red">Hello World</h1>, document.getElementById('root'));

// render content
const content = ((<div>
    <h1 className="blue">Hello World</h1>
    <p>P1</p>
    <p>P2</p>    
</div>));
ReactDOM.render(content, document.getElementById('root'));

- 

render multiple: 
<div id="root1"></div>
<div id="root2"></div>

ReactDOM.render(<h1>Hello Root 1</h1>, document.getElementById('root1'));
ReactDOM.render(<h1>Hello Root 2</h1>, document.getElementById('root2'));

-

// bind an processed element
class Test extends Component {    
    render() {
        let arr = ['Random-Header-1', 'Random-Header-2', 'Random-Header-3', 'Random-Header-4', 'Random-Header-5'];
        let header = <h1>{arr[Math.floor(Math.random() * arr.length)]}</h1>;

        return (
            <div>
                {header}
				<p>Paragraph</p>
				<p>Paragraph</p>
            </div>
        )
    }
}

-

[props]
passing arguments using tag attributes syntax.
we can pass any type as props (string, number, object etc.)

recommendation:
always pass the props to the parent component.

using:
class ClassA extends React.Component {
	constructor(props) {
		super(props);   
	}

	render() {
		return (<h1>Hello {this.props.name}!</h1>)
	}
}
ReactDOM.render(<ClassA name="Roby" />, document.getElementById('root'));

-

[component in component]
class ClassA extends React.Component {
    render() {
        return (
            <div>
                <h1>Hello {this.props.name}!</h1>
                <ClassB />
            </div>
		)
    }
}

class ClassB extends React.Component {
    render() {
        return (
            <div>
                <p>Paragraph 1</p>
                <p>Paragraph 2</p>
            </div>
		)
    }
}

ReactDOM.render(<ClassA name="Roby" />, document.getElementById('root'));

-

[external components]
use 'export' keyword to expose the component to be able to use it from other files.

// ComponentA.js
import React from 'react';
import ReactDOM from 'react-dom';

class ComponentA extends React.Component {
	render() {
		return <h2>Hi ComponentA</h2>;	 
	}
}
export default ComponentA;


// index.js
import React from 'react';
import ReactDOM from 'react-dom';
import ComponentA from './ComponentA.js';

ReactDOM.render(<ComponentA />, document.getElementById('root'));

-

[state]
- init the state in the constructor.
- use state.<propName> anywhere within the component.
- use setState to update the state. setState method allows us to update the full state object or only partial properties. 

setState(<newState>);  // full update 
setState({ <propName>: <value>});  // partial update

sample:
class Test extends Component {
    constructor() {
        super();
        this.state = {
            p1: 'value-1', 
            p2: 'value-2'
        };
    }
    
    changeP1 = e => {
        this.state.p1 = `value-${Math.floor(Math.random() * 100)}`;
        this.setState(this.state);
    }

    render() {
        return (<div>
            <h1 className="blue">Hello World</h1>
            <p>{this.state.p1}</p>
            <p>{this.state.p2}</p>
            <p><button onClick={this.changeP1}>change-p1</button></p>
        </div>)
    }
}

-

[Lifecycle]
the component's lifecycle. 

operations:
1. Mounting	   
   occurs when a component is created.

2. Updating	
   occurs when a component is updated (there was a change in the state or props)

3. Unmounting
   occurs when a component is removed from the DOM.

Mounting lifecycle:
- constructor				// init component 
- getDerivedStateFromProps	// pre-render. signature: static getDerivedStateFromProps(props, state);  
- render					// render 
- componentDidMount			// post-render

Updating lifecycle:
- getDerivedStateFromProps	// pre-render. signature: static getDerivedStateFromProps(props, state);  
- shouldComponentUpdate		// determine whether to continue with the update process or not (default: true)
- render					// render
- getSnapshotBeforeUpdate	// get access to the state and props before the changes. signature: getSnapshotBeforeUpdate(prevProps, prevState);
- componentDidUpdate		// post-render

Unmounting lifecycle:
- componentWillUnmount		// pre-remove. right before removing the component. 

using:
// the value of 'p1' will be updated after 2 seconds.
class Test extends Component {
    constructor(props) {
        super(props);
        this.state = {
            p1: 'value-1'
        };       
    }

	componentDidMount() {
		setTimeout(() => {
			this.setState({ p1: "value-1-updated" })
		}, 2000)
	}

	render() {
        return (<p>{this.state.p1}</p>)
    }
}

-

[Events]
React supports the same events as HTML.
it uses the same evente name but in camelcase mode (onclick -> onClick etc.)

tip: 
use arrow functions to refer 'this' always as the component. 

important! 
when using regular functions instead of arrows, we MUST bind the function using the 'bind' method.
this.fun1 = this.fun1.bind(this);

sample:
class Test extends Component {    
	constructor(props) {
		super(props)
		this.fun1 = this.fun1.bind(this);  // bind method (for regular functions)
	}	

	fun1 = e => { ... }  // arrow function - no binding is required! 'this' refers to the component.
    fun2(e) { ... }  // regular function - binding is required!

    render() {
        return (
			<div>
				<button onClick={this.fun1}>clickMe</button>
				<button onClick={this.fun2}>clickMe</button>
			</div>
		)
    }
}

-

[Forms]
when using forms in react, we need to update the component's state on each change. 
we do that using the 'onChange' event of the input.
we can also use 'onSubmit' event to be triggered when the form is about to be submitted.
to revoke the actual submit action, we can call 'preventDefault' method of the event.

validations:
we can handle validations as part of each change or when submitting the form. 
we can use the state to collect errors and present them as a summary in the html.

textarea tag:
unlike in HTML, in React, the value of a TextArea is set using a 'value' attribute and NOT as innerText.
// e.g 
<textarea value={this.state.description} />
<textarea value="some description..." />

select tag:
unlike in HTML, in React, the selected value is controlled by a 'value' attribute of the 'select' tag and NOT as the option's 'selected'.
// e.g
<select value={this.state.selectedValue}>
    <option value="1">Value1</option>
    <option value="2">Value2</option>
    <option value="3">Value3</option>
</select>
<select value="2">
    <option value="1">Value1</option>
    <option value="2">Value2</option>
    <option value="3">Value3</option>
</select>

using:
class TestForm extends Component {
    constructor() {
        super();
        this.state = {
            input1: '',
            input2: ''
        };
    }

    setInput1 = e => {
        this.setState({
            input1: e.target.value
        });
    }

    setInput2 = e => {
        this.setState({
            input2: e.target.value
        });
    }

	submitForm = e => {
		e.preventDefault();
		// code here...
	}

    render() {
        return (
            <form onSubmit={this.submitForm}>
                <h1>Test Form</h1>
                <input type="text" placeholder="input-1" onChange={this.setInput1} />
                &nbsp;&nbsp;<span>{this.state.input1}</span>
                <br /><br />
                <input type="text" placeholder="input-2" onChange={this.setInput2} />                                
                &nbsp;&nbsp;<span>{this.state.input2}</span>
				<br /><br />
				<input type="submit" />
            </form>
        )
    }
}

ReactDOM.render(<TestForm />, document.getElementById('root'));

-

[CSS]
- inline 
- inline using a js-object 
- css file

inline:
style={{ <name>:<value>... }}

inline using a js-object:
style={ <stylesObject> }

css file:
import <cssFile>;
className="<className>"


sample:
import './index.css';

class TestStyles extends Component {
    render() {
		const p2Styles = {
			color: "yellow", 
			backgroundColor: "blue"
		};

        return (<div>            
            <p style={{color: "blue", backgroundColor: "yellow"}}>Paragraph 1</p>
            <p style={p2Styles}>Paragraph 2</p>
            <p className="red">Paragraph 3</p>            
        </div>)
    }
}

-

[Sass]
CSS pre-processor. 
files with .scss extension.

install:
> npm install --save node-sass

sample:
import './index.scss';

// jsx
<h6 className="title">Hello World</h6>

// scss
$size: 20px;
$color: purple;

h6.title {
    font-size: $size;
    color: $color;
    border:dashed 1px #808080;
    padding: 8px;
    margin: 0px;
}

- 

