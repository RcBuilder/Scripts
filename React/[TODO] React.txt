****** React ******
*******************

// TODO
=== [TOC] ==================
- Sources
- Install
- About
- CDN
- Npx Commands
- Using React
- CRA (Create-React-App)  
- Serverless
- NodeJS Express
- ReactJS.NET
- React Templates
- JSX
- File Structure
- Router
- CSS
- State
- Lifecycle
- HTML Raw
- Binding a Function
- Dynamic Content
- Render arrays inline
- Empty Root node
- Escape Curly-Brackets 
- TODO App
- BUGS
============================


Sources
-------
// TODO

Install
-------
// TODO

About
-----
React is a JavaScript library created by Facebook.
it creates a virtual DOM (in memory), apply the changes there and only then update the actual DOM. 
React library uses JSX which stands for 'JavaScript XML' and allows us to add HTML tags within the script. 
React uses Virtual-DOM to track changes in the components, and then apply only those changes on the actual DOM.

CDN
---
DEV:
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>

PROD:
<script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>

Npx Commands
------------
// TODO

Using React
-----------
to use react with the built-in CRA framework (NodeJS based): 
see 'CRA (Create-React-App)'
-
to use react with NO SERVER, directly in the HTML:
see 'Serverless'
-
to use react with NodeJS & Express server: 
see 'NodeJS Express'
-
to use react in .Net MVC:
see 'ReactJS.NET'


CRA (Create-React-App)
----------------------
// TODO

Serverless
----------
// TODO

NodeJS Express
--------------
// TODO

ReactJS.NET
-----------
// TODO

React Templates
---------------
// TODO

JSX
---
// TODO

File Structure
--------------
// TODO

Router
------
// TODO

CSS
---
// TODO

multiple styles:
render() {
    let stylesA = { color: '#fff' }
	let stylesB = { backgroundColor: 'mediumvioletred' }
	let stylesC = { fontStyle: 'italic' }
        
    return (
        <>
            <h1 style={{ ...stylesA, ...stylesB, ...stylesC }}>Hello React</h1>
        </>
    )
}

-

multiple classes:
render() {
    let classA = 'cssClassA';
	let classB = 'cssClassB';
	let classC = 'cssClassC';
        
    return (
        <>
            <h1 className={`${classA} ${classB} ${classC}`}>Hello React</h1>
        </>
    )
}

State
-----
// TODO ->> check
[inheritance]
when using inheritance, by extending the 'Component' class, we have access to the base class 'State' object. 
use 'this.state' to get the current state. 
use 'this.setState' method to update the current state.

the state object can be of any type.
note that we don't have to provide the 'state' object structure beforehand. we can define it as an empty object and add properties to it on the fly.
ANY change to the 'state' - re-renders the view! (see 'Lifecycle')

a reminder - when using functions, do not forget to bind them to the component (see 'Binding a Function')

[useState model]
// TODO

Lifecycle
---------
// TODO

HTML Raw
--------
use 'dangerouslySetInnerHTML' property to inject raw html content.

example:
render() {
    const html = `
        <h3>Title</h3>
        <h4>Title</h4>
        <h5>Title</h5>
    `;
    return (
        <>                              
            <div dangerouslySetInnerHTML={{ __html: html }} />
        </>
    )
}

Binding a Function
------------------
in some cases, we lose the context of 'this' keyword so it refers to a different object than our class.
a common case is event callback (onPress, onChange etc.). to solve this issue, we need to bind 'this' to those callbacks.
the bind process is usually performed within the class constructor. 

tip: 
as a thumb-rule, it's better to bind any NON-arrow defined function.
note that the 'this' in arrow-functions always refer to the component so there's no need to bind them!

to recap:
regular function requires a binding to the component.
arrow function does NOT require a binding process.

example:
class TestEvents extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            value: ''
        };

        this.fun2 = this.fun2.bind(this);  // bind method (for regular functions)
    }
    
    fun1 = e => {
        this.setState({
            value: Math.floor(Math.random() * 1000)
        });
    }  
    
    fun2(e) {
        this.setState({
            value: Math.floor(Math.random() * 1000)
        });
    }  

    render() {
        return (
            <>
                <h5>{this.state.value}</h5>
                <p>
                    <button onClick={this.fun1}>clickMe</button>                    
                    <button onClick={this.fun2}>clickMe</button>
                </p>
            </>
        )
    }
}



Dynamic Content
---------------
we can embed content within the js code to generate a dynamic content.
we can use any of the available modules as part of our js code. (see 'JSX')

we have 2 options to do so: 
1. using code within the 'render' function.
2. using a function as a class member. 

e.g: 
// option 2
renderContent(){
    return <h1>Hello React</h1>;
}

render() {
	// option 1
    let dynamicContent = [];
        dynamicContent.push(<p>dynamic 1</p>);
        dynamicContent.push(<p>dynamic 2</p>);   

	return (
		<>
            {this.renderContent()}
            {dynamicContent}                
        </>
	);
}

Render arrays inline
--------------------
we can render arrays inline using the the known es6 functions -> map, filter and reduce.

e.g: 
render() {
    const arr = ['A', 'B', 'C', 'D'];
    return (
        <>              
            <h1>Hello React</h1>
            <ul>
                {arr.map(x => <li>{x}</li>)}
            </ul>
        </>
    )
}

Empty Root node
---------------
syntax:
<>...</>

sample:
return (
	<>
		<h1>header</h1>
		<p>body</p>
    </>
)

Escape Curly-Brackets
---------------------
use apostrophe sign (') to escape curly brackets -> '{' and '}' 

syntax:
{'{...}'}

sample:
// the value "{ 123 }" is printed 
return <p>{'{ 123 }'}</p>  


TODO App
--------

// available actions (enum)
const eTodoActionType = Object.freeze({
    CHANGE_STATUS: Symbol("CHANGE_STATUS"),
    ADD: Symbol("ADD"),
    REMOVE: Symbol("REMOVE")
});

// action: { type, payload }
const TodoReducer = (state, action) => {
    console.log(action);

    let current = action.payload;

    switch (action.type) {
        case eTodoActionType.ADD:
            return [...state, current];

        case eTodoActionType.REMOVE:
            return state.filter(x => x.id != current.id);

        case eTodoActionType.CHANGE_STATUS:
            return state.map(x => {
                if (x.id == current.id)
                    return x;
                return { ...x, complete: x.complete }
            });

        default: return state;
    }

    return state;    
}

const TodoApp = () => {        
    const [todos, dispatch] = useReducer(TodoReducer, []);

    return (
        <>
            <h4>TODO APP</h4>
            <ul>
                {todos.map(todo => <Todo todo={todo} dispatch={dispatch} />)}
            </ul>
            <NewTodo dispatch={dispatch} />
        </>
    )    
}

const Todo = ({ todo, dispatch }) => {

    const statusChanged = (e) => {
        todo.complete = e.target.checked;
        dispatch({ type: eTodoActionType.CHANGE_STATUS, payload: todo })
    }

    return (
        <li key={todo.id}>
            <label>
                <input type="checkbox" checked={todo.complete} onChange={statusChanged} />
                {todo.task}
            </label>
            <img src={closeIcon} style={{ width: '16px', margin: '0 10px' }} onClick={() => {
                dispatch({ type: eTodoActionType.REMOVE, payload: todo })
            }} />            
        </li>
    );
}

const NewTodo = ({ dispatch }) => {
    const taskInput = React.createRef();
    const submitForm = e => {
        e.preventDefault();

        let todo = {
            id: uuid(),
            task: taskInput.current.value || 'EMPTY',
            complete: false
        };
        
        dispatch({ type: eTodoActionType.ADD, payload: todo });
        taskInput.current.value = '';
    }

    return (
        <form onSubmit={submitForm}>   
            <input type="text" placeholder="task" ref={taskInput} />
            <input type="submit" />
        </form>
    )
}



BUGS
----
BUG:
ReactJS.NET
Ex -> Cannot use import statement outside a module 
cause -> can't use the keyword 'import' within a jsx file.
solution -> remove all 'import' caluses, use the 'ReactConfig.cs' to register all jsx files. this will auto-import them so they all would be available to use.
see 'ReactJS.NET > component in component'

-

BUG:
ReactJS.NET
Ex -> React is not defined
cause -> there are no react libraries imported 
solution -> add reference to react client engine 
see 'ReactJS.NET > render using js libraries'

-

BUG:
ReactJS.NET
Issue -> No Client events nor console log
cause -> server rendering only!
solution -> render react in the client 
see 'ReactJS.NET > server & client rendering'

BUG:
ReactJS.NET
Issue -> Cannot load V8 interface assembly.
cause -> no v8 engine files (in the bin folder), the IIS express might use a 32bit version and the 64bit was installed.
solution -> change IIS target or install the correct version (32bit or 64bit) 

-------------------------------------------


ReactJS.NET
react with .Net (ASP.NET MVC)

sources:
https://reactjs.net/
https://reactjs.net/getting-started/aspnet.html

(steps)
1. open an MVC project (blank)
2. install react
   > Install-Package React.Web.Mvc4 -Version 5.2.7
   > Install-Package JavaScriptEngineSwitcher.V8
   > Install-Package JavaScriptEngineSwitcher.V8.Native.win-x64
   // > Install-Package JavaScriptEngineSwitcher.V8.Native.win-x86

3. add Controller and a View
4. import react namespace to the created view 
   @using React.Web.Mvc;

5. render a component in the view
   @Html.React("TestReact", new {
		name = "Roby"
	})

6. create a new .jsx file and implement the react component 
   // Scripts/app.jsx
   class TestReact extends React.Component {
		render() {
			return (
				<div>
					<h1>Hello React</h1>
					<p>{this.props.name}</p>
				</div>
			)
		}
	}

7. App_Start > ReactConfig > set configuration for react
   public static class ReactConfig {
		public static void Configure() {
            ReactSiteConfiguration.Configuration
                .AddScript("~/Scripts/app.jsx");
			JsEngineSwitcher.Current.DefaultEngineName = V8JsEngine.EngineName;
            JsEngineSwitcher.Current.EngineFactories.AddV8();
        }
    }

8. Build

references:
see 'ReactJS.NET server & client rendering'
see 'ReactJS.NET render using @Html.React'
see 'ReactJS.NET render using js libraries'
see 'ReactJS.NET component in component'

-

react-bundle:
System.Web.Optimization.React  ???

-

ReactJS.NET server & client rendering:

important! 
when using server react rendering (using @Html.React) 
the jsx files are NOT being rendered to the client and therefore, client events, logs and etc will not work!!
to perform a client rendering we need to add client reference to the jsx files (at the header) and call the @Html.ReactInitJavaScript method (at the bottom)

// note
alternatively, we can use the 'ReactDOM.render' to inject the component to a DOM element.
see 'ReactJS.NET render using js libraries'


// using
<script src="~/Scripts/React/component1.jsx"></script>
<script src="~/Scripts/React/component2.jsx"></script>

@Html.React("component1", new {})
@Html.React("component2", new {})

<!-- render react components in the client -->
@Html.ReactInitJavaScript()

- 

ReactJS.NET component in component:

notes:
use the ReactConfig to import all related jsx files. 
do not use the keyword 'import' within the jsx files (its already imported)

// ReactConfig.cs
using JavaScriptEngineSwitcher.Core;
using JavaScriptEngineSwitcher.V8;
using React;

public static class ReactConfig {
	public static void Configure() {
        ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/comp.jsx")
            .AddScript("~/Scripts/app.jsx");  

        JsEngineSwitcher.Current.DefaultEngineName = V8JsEngine.EngineName;
        JsEngineSwitcher.Current.EngineFactories.AddV8();
    }
}

// comp.jsx
class TestComp extends React.Component {
    render() {
        return (<h1>Hello Component</h1>)
    }
}

// app.jsx
class TestReact extends React.Component {
    render() {
        return (
            <div>
                <h1>Hello React</h1>
                <p>{this.props.name}</p>   
				<TestComp />
            </div>
        )
    }
}

-

ReactJS.NET render using @Html.React:
server rendering.

note!
only server rendering. 
this technique renders the components in the server and does NOT pull them into the client (see 'ReactJS.NET server & client rendering')

// ReactConfig.cs
using JavaScriptEngineSwitcher.Core;
using JavaScriptEngineSwitcher.V8;
using React;

public static class ReactConfig {
	public static void Configure() {
        ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/app.jsx");            

        JsEngineSwitcher.Current.DefaultEngineName = V8JsEngine.EngineName;
        JsEngineSwitcher.Current.EngineFactories.AddV8();
    }
}

// Index.cshtml
@Html.React("TestReact", new {
    name = "Roby"
})

// app.jsx
class TestReact extends React.Component {
    render() {
        return (
            <div>
                <h1>Hello React</h1>
                <p>{this.props.name}</p>                
            </div>
        )
    }
}

-

ReactJS.NET work with MVC Models:

// SomeModel.cs
public class SomeModel
{
    [JsonProperty(PropertyName = "id")]
    public int Id { get; set; }

    [JsonProperty(PropertyName = "name")]
    [Required(ErrorMessage = "Name is Required")]
    [MinLength(10, ErrorMessage = "Name is too short")]
    public string Name { get; set; }

    [JsonProperty(PropertyName = "price")]
    public float Price { get; set; }

    [JsonProperty(PropertyName = "expiry")]
    public DateTime Expiry { get; set; }
}

// Controller
public ActionResult Model() {
    return View(new Models.SomeModel {
        Id = 100,
        Name = "Test Model",
        Price = 99.9F,
        Expiry = DateTime.Now
    });
}

[HttpPost]
public ActionResult CheckModel(Models.SomeModel SomeModel)
{            
    if (ModelState.IsValid)
        return Json(new { Status = "OK" });
    return Json(new { Status = "ERROR", State = ModelStateToJson(ModelState) });
}

// Helper
public static dynamic ModelStateToJson(ModelStateDictionary ModelState) {
    var errorList = (
        from item in ModelState
        where item.Value.Errors.Any()
        select new
        {
            key = item.Key,
            errors = item.Value.Errors.Select(e => e.ErrorMessage)
        }
    );

    return errorList;
}

// Index.cshtml
@model Models.SomeModel

<p>pass Model as props</p>
@Html.React("TestModel", Model)

<p>model error state</p>
@Html.React("TestModel2", Model)

// testModel.jsx
class TestModel extends React.Component {
    constructor(props) {
        super(props);        
    }
   
    render() {
        return (
            <>
                <p>{this.props.id}</p>
                <p>{this.props.name}</p>
                <p>{this.props.price}</p>
                <p>{this.props.expiry}</p>
            </>
        )
    }
}

class TestModel2 extends React.Component {
    constructor(props) {
        super(props);
    }

    checkModel = async e => {
        this.props.name = 'short';

        var result = await fetch('CheckModel', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(this.props)
        }).then(result => result.json());
        console.log(result);
    }

    render() {
        return (
            <>
                <button onClick={this.checkModel}>clickMe</button>
            </>
        )
    }
}

-

ReactJS.NET render using js libraries:
client rendering.

// _Layout.cshtml
@RenderSection("scripts", required: false)

// Index.cshtml
<div id="root"></div>
@section scripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>

    <script src="~/Scripts/app.jsx"></script>    
}

// app.jsx
class TestReact extends React.Component {
    render() {
        return (
            <div>
                <h1>Hello React</h1>
                <p>{this.props.name}</p>
            </div>
        )
    }
}
ReactDOM.render(<TestReact name="Roby" />, document.getElementById('root'));

-

ReactJS.NET styles

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/testCss.jsx");

// Index.cshtml
<p>using inline styles</p>
@Html.React("TestCss1", new {
    headerColor = "red"
})

<p>using inline styles with a js-object</p>
@Html.React("TestCss2", new
{
    headerColor = "purple"
})

<p>using css class</p>
<style type="text/css">
    .header {
        color: #fff;
        background-color: mediumvioletred;
    }
</style>

@Html.React("TestCss3", new
{
    headerClass = "header"
})

// testCss.jsx
class TestCss1 extends React.Component {
    render() {
        return (
            <div>
                <h1 style={{ color: this.props.headerColor }}>Hello Css 1</h1>
                <p>props: {this.props.headerColor}</p>                                   
            </div>
        )
    }
}

class TestCss2 extends React.Component {
    render() {
        const headerStyles = {
            color: this.props.headerColor,
            textDecoration: 'underline'
        };

        return (
            <div>
                <h1 style={headerStyles}>Hello Css 2</h1>
                <p>props: {this.props.headerColor}</p>
            </div>
        )
    }
}

class TestCss3 extends React.Component {
    render() {
        return (
            <div>
                <h1 className={this.props.headerClass}>Hello Css 3</h1>
                <p>props: {this.props.headerClass}</p>
            </div>
        )
    }
}

class TestCss4 extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            classA: 'classA'
        };
    }

    getClassB = () => {
        return 'classB';
    }

    render() {
        let classC = 'classC';

        return (
            <>
                <h1 className={`${this.state.classA} ${this.getClassB()} ${classC}`}>Hello Css 4</h1>
                <p>multiple classes</p>
            </>
        )
    }
}

class TestCss5 extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            stylesA: {
                color: '#fff'
            }
        };
    }

    getStylesB = () => {
        return {
            backgroundColor: 'mediumvioletred'
        };
    }

    render() {
        let stylesC = {
            fontStyle: 'italic'
        };
        
        return (
            <>
                <h1 style={{ ...this.state.stylesA, ...this.getStylesB(), ...stylesC }}>Hello Css 5</h1>
                <p>multiple styles</p>
            </>
        )
    }
}

-

ReactJS.NET Wrapper Component:

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/React/testWrapper.jsx");

// Index.cshtml
<p>wrapper box</p>
@Html.React("TestWrapper1", new { })
<p>use {this.props.children}</p>

// testWrapper.jsx
class Wrapper1 extends React.Component {
    constructor(props) {
        super(props);
    }

    render() {
        const box = {
            backgroundColor: '#666',
            color: '#fff',
            padding: '12px',
            border: 'solid 1px #000',
            marginBottom: '10px'
        };

        return (
            <div style={box}>
                {this.props.children}
            </div>
        )
    }
}

class TestWrapper1 extends React.Component {

    render() {
        return (
            <Wrapper1>
                <p>Paragraph 1</p>
                <p>Paragraph 2</p>
                <p>Paragraph 3</p>
            </Wrapper1>    
        )
    }
}

-

ReactJS.NET API Data:

// tip
we can use a flag to specify whether the data was loaded or not. 
use this flag to conditionally render a "Loading..." icon. 
the default flag value should be FALSE and once the data was loaded, set it to TRUE.

// best practices
fetch data on the componentDidMount stage (post-render)

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/React/testAPI.jsx");

// Index.cshtml
<p>using promise fetch/p>
@Html.React("TestAPI", new { })

<p>using async fetch</p>
@Html.React("TestAPIAsync", new { })

@section scripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>    
    <script src="~/Scripts/React/testAPI.jsx"></script>

	<!-- render react components in the client -->
	@Html.ReactInitJavaScript()
}

// testAPI.jsx
class TestAPI extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            customers: []
        }
    }

    // post-render
    componentDidMount() {
        const service = 'https://www.w3schools.com/js/customers_mysql.php';
        fetch(service)
            .then(data => data.json())
            .then(json => this.setState({
                customers: json
            }));
    }

    render() {                
        return (
            <ul>
                {this.state.customers.map(x => <li>{x.Name}</li>)}
            </ul>
        )
    }
}

class TestAPIAsync extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            customers: []
        }
    }

    // post-render
    async componentDidMount() {
        const service = 'https://www.w3schools.com/js/customers_mysql.php';
        let data = await fetch(service)
        let json = await data.json();

        this.setState({
            customers: json
        });
    }

    render() {
        return (
            <ul>
                {this.state.customers.map(x => <li>{x.Name}</li>)}
            </ul>
        )
    }
}

-

ReactJS.NET Lifecycle:

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/React/testLifecycle.jsx");

// Index.cshtml
<p>Mounting</p>
<p>occurs when a component is created.</p>
@Html.React("TestMounting", new {})
<pre>
    [TestMounting] constructor
    [TestMounting] pre-render
    [TestMounting] render
    [TestMounting] post-render    
</pre>

<p>Updating</p>
<p>occurs when a component is updated (there was a change in the state or props).</p>
@Html.React("TestUpdating", new { })
<pre>
    [TestUpdating] onstructor
    [TestUpdating] pre-render
    [TestUpdating] render

    -- after click --

    [TestUpdating] executing doSomeChange method..
    [TestUpdating] pre-render
    [TestUpdating] should perform the update
    [TestUpdating] render
    [TestUpdating] get the state before the change
    [TestUpdating] post-render
</pre>

<p>Unmounting</p>
<p>occurs when a component is removed from the DOM.</p>
@Html.React("TestUnmounting", new { })
<pre>
    [TestUnmounting] constructor
    [TestUnmounting] render
    [ChildComponent] constructor
    [ChildComponent] render

    -- after click --

    [TestUnmounting] executing removeComponent method..
    [TestUnmounting] render
    [ChildComponent] pre-remove
</pre>

@section scripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>    
    <script src="~/Scripts/React/testLifecycle.jsx"></script>

	<!-- render react components in the client -->
	@Html.ReactInitJavaScript()
}


// testLifecycle.jsx
class TestMounting extends React.Component {
    constructor(props) {
        super(props);
        this.state = {};
        
        console.log('[TestMounting] constructor');
    }

    static getDerivedStateFromProps(props, state) {
        console.log('[TestMounting] pre-render');        
    }

    componentDidMount() {                
        console.log('[TestMounting] post-render');
    } 
    
    render() {
        console.log('[TestMounting] render');
        
        return (
            <div>
                <h1>Hello Lifecycle</h1>
                <p>see console output</p>                
            </div>
        )
    }
}

class TestUpdating extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            someValue: 1
        };
        
        console.log('[TestUpdating] onstructor');
    }

    static getDerivedStateFromProps(props, state) {
        console.log('[TestUpdating] pre-render');
    }

    shouldComponentUpdate() {
        console.log('[TestUpdating] should perform the update');
        return true;
    }

    getSnapshotBeforeUpdate(prevProps, prevState) {
        console.log('[TestUpdating] get the state before the change');
    }

    componentDidUpdate() {
        console.log('[TestUpdating] post-render');
    } 

    doSomeChange = e => {
        console.log('[TestUpdating] executing doSomeChange method..');
        this.setState({ someValue: 2 });
    }

    render() {
        console.log('[TestUpdating] render');

        return (
            <div>
                <h1>Hello Lifecycle</h1>
                <p>see console output</p>
                <p><button onClick={this.doSomeChange}>clickMe</button></p>
            </div>
        )
    }
}

class TestUnmounting extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            render: true
        };

        console.log('[TestUnmounting] constructor');
    }

    removeComponent = e => {
        console.log('[TestUnmounting] executing removeComponent method..');
        this.setState({ render: false });
    }
    
    render() {
        console.log('[TestUnmounting] render');

        let childComponent = this.state.render ? <ChildComponent /> : null;

        return (
            <div>
                {childComponent}
                <p>see console output</p>
                <p><button onClick={this.removeComponent}>clickMe</button></p>
            </div>
        )
    }
}

class ChildComponent extends React.Component {
    constructor(props) {
        super(props);
        console.log('[ChildComponent] constructor');
    }

    componentWillUnmount() {
        console.log('[ChildComponent] pre-remove')
    }

    render() {
        console.log('[ChildComponent] render');
        return <h1>Hello Lifecycle</h1>;
    }
}

-

ReactJS.NET State:

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/React/testState.jsx");

// Index.cshtml
<p>change state</p>
@Html.React("TestState", new { })

@section scripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>    
    <script src="~/Scripts/React/testState.jsx"></script>

	<!-- render react components in the client -->
	@Html.ReactInitJavaScript()
}

// testState.jsx
class TestState extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            p1: 'value-1',
            p2: 'value-2'
        };        
    }

    changeP1 = e => {
		// option1 to update a state
        this.state.p1 = `value-${Math.floor(Math.random() * 1000)}`;
        this.setState(this.state);
    }

    changeP2 = e => {        
		// option2 to update a state
        this.setState({
            p2: `value-${Math.floor(Math.random() * 1000)}`
        });
    }

    render() {
        return (
            <div>
                <p>{this.state.p1}</p>
                <p>{this.state.p2}</p>
                <p>
                    <button onClick={this.changeP1}>change-p1</button>                    
                    <button onClick={this.changeP2}>change-p2</button>
                </p>
            </div>
        )
    }
}

-

ReactJS.NET Events:

notes:
- for arrow function - no binding is required! 'this' refers to the component.
- for regular function - binding is required!

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/React/testEvents.jsx");


// Index.cshtml
<p>arrow & regular functions</p>
@Html.React("TestEvents", new { })

@section scripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>    
    <script src="~/Scripts/React/testEvents.jsx"></script>
		
	<!-- render react components in the client -->
	@Html.ReactInitJavaScript()
}


// testEvents.jsx
class TestEvents extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            value: ''
        };

        this.fun2 = this.fun2.bind(this);  // bind method (for regular functions)
    }
    
    fun1 = e => {
        this.setState({
            value: Math.floor(Math.random() * 1000)
        });
    }  
    
    fun2(e) {
        this.setState({
            value: Math.floor(Math.random() * 1000)
        });
    }  

    render() {
        return (
            <div>
                <h5>{this.state.value}</h5>
                <p>
                    <button onClick={this.fun1}>clickMe</button>                    
                    <button onClick={this.fun2}>clickMe</button>
                </p>
            </div>
        )
    }
}

-

ReactJS.NET Forms:

// ReactConfig.cs
ReactSiteConfiguration.Configuration                
            .AddScript("~/Scripts/React/testForms.jsx");

// Index.cshtml
<p>onChange and onSubmit</p>
@Html.React("TestForm1", new {})

<p>setInput using name</p>
@Html.React("TestForm2", new { })

<p>special tags</p>
@Html.React("TestForm3", new { })

<p>React ref</p>
@Html.React("TestForm4", new { })

@section scripts{
    <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>    
    <script src="~/Scripts/React/testForms.jsx"></script>

	<!-- render react components in the client -->
	@Html.ReactInitJavaScript()
}


// testForms.jsx
class TestForm1 extends React.Component {
    constructor() {
        super();
        this.state = {
            input1: '',
            input2: ''
        };
    }

    setInput1 = e => {
        this.setState({
            input1: e.target.value
        });
    }

    setInput2 = e => {
        this.setState({
            input2: e.target.value
        });
    }

    submitForm = e => {
        e.preventDefault();
        // code here...
    }

    render() {
        return (
            <form onSubmit={this.submitForm}>
                <h1>Test Form 1</h1>
                <input type="text" placeholder="input-1" onChange={this.setInput1} />
                &nbsp;&nbsp;<span>{this.state.input1}</span>
                <br /><br />
                <input type="text" placeholder="input-2" onChange={this.setInput2} />
                &nbsp;&nbsp;<span>{this.state.input2}</span>
                <br /><br />
                <p><input type="submit" value="SUBMIT" /></p>
            </form>
        )
    }
}

class TestForm2 extends React.Component {
    constructor() {
        super();
        this.state = {
            input1: '',
            input2: ''
        };
    }

    setInput = e => {
        this.setState({
            [e.target.name]: e.target.value
        });
    }

    render() {
        return (
            <form>
                <h1>Test Form 2</h1>
                <input type="text" placeholder="input-1" onChange={this.setInput} name="input1" />
                &nbsp;&nbsp;<span>{this.state.input1}</span>
                <br /><br />
                <input type="text" placeholder="input-2" onChange={this.setInput} name="input2" />
                &nbsp;&nbsp;<span>{this.state.input2}</span>              
                <br /><br />
            </form>
        )
    }
}

class TestForm3 extends React.Component {
    constructor() {
        super();
        this.state = {
            selectedValue: '2',
            description: 'bla bla bla...'
        };
    }

    setSelectedValue = e => {
        this.setState({
            selectedValue: e.target.value
        });
    }

    render() {        
        return (
            <form>
                <h1>Test Form 3</h1>
                <select value={this.state.selectedValue} onChange={this.setSelectedValue}>
                    <option value="1">Value1</option>
                    <option value="2">Value2</option>
                    <option value="3">Value3</option>
                </select>
                <br /><br />
                select value is {this.state.selectedValue}                
                <br /><br />
                <textarea value={this.state.description} />
                <br /><br />
            </form>
        )
    }
}

class TestForm4 extends React.Component {
    constructor() {
        super();
        this.form = React.createRef();        
    }

    submitForm = e => {
        e.preventDefault();
        console.log(this.form.current);  // reference to the current form!
        // code here...
    }

    render() {
        return (
            <form ref={this.form} onSubmit={this.submitForm}>
                <h1>Test Form 4</h1>
                <p><input type="submit" value="SUBMIT" /></p>
            </form>
        )
    }
}

-



cra - multiple pages ???

-

client routing ???

-

.Net React Router
> Install-Package React.Router.Mvc4 -Version 5.2.7
DOES NOT WORK!!
https://reactjs.net/features/react-router.html#:~:text=React%20Router%20is%20a%20Javascript,by%20deferring%20to%20React%20Router

-

.Net Typescript

-

ReactDOM.render
https://www.pluralsight.com/guides/just-plain-react

- 

render using express server 

-

cra = create-react-app 

// install app-creator (globally)
> npm install -g create-react-app

-

// create an app using npx
> npx create-react-app test-react
-OR-
// create an app using npm
> npm init react-app test-react

// run 
// start and launch server 
> npm start

// build (for deployment)
// creates a minified bundle
> npm run build

-

syntax:
--template <template-name>

templates:
https://www.npmjs.com/search?q=cra-template-*

e.g:
> npx create-react-app my-app --template typescript

-

[typescript]

new project:
// use template
> npx create-react-app my-app --template typescript

existing project:
1. > npm install --save typescript @types/node @types/react @types/react-dom @types/jest
2. change any .js file to .tsx
3. restart your development server!

- 

Blank-app???

-
 
%PUBLIC_URL%/favicon.ico ???

-

[react with no server]
ReactDOM.render

// in HTML
<script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>

<div id="root"></div>

<script type="text/babel">
    class TestReact extends React.Component {
		render() {
			return (<h1>Hello World!</h1>)
		}
    }

    ReactDOM.render(<TestReact />, document.getElementById('root'));
</script>

-

basic sample using 'create-react-app':

// index.js
import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import './index.css';

class Test extends Component {
    constructor() {
        super();
        this.state = {
            p1: 'value-1', 
            p2: 'value-2'
        };
    }
    
    changeP1 = e => {        
        this.setState({
			p1: `value-${Math.floor(Math.random() * 1000)}`
		});
    }

    render() {
        return (<div>
            <h1 className="blue">Hello World</h1>
            <p>{this.state.p1}</p>
            <p>{this.state.p2}</p>
            <p><button onClick={this.changeP1}>change-p1</button></p>
        </div>)
    }
}

ReactDOM.render(<Test />, document.getElementById('root'));

-

[render]

note: 
MUST include root element (like a valid XML)!


// render a class (component)
class ClassA extends React.Component {
	render() {
		return (<h1>Hello World!</h1>)
	}
}
ReactDOM.render(<ClassA />, document.getElementById('root'));

// render a function (component)
function FunA() {	
	return (<h1>Hello World!</h1>);	
}
ReactDOM.render(<FunA />, document.getElementById('root'));

// render an element
const elem = (<h1 className="red">Hello World</h1>);
ReactDOM.render(elem, document.getElementById('root'));

// direct rendering 
ReactDOM.render(<h1 className="red">Hello World</h1>, document.getElementById('root'));

// render content
const content = ((<div>
    <h1 className="blue">Hello World</h1>
    <p>P1</p>
    <p>P2</p>    
</div>));
ReactDOM.render(content, document.getElementById('root'));

- 

render multiple: 
<div id="root1"></div>
<div id="root2"></div>

ReactDOM.render(<h1>Hello Root 1</h1>, document.getElementById('root1'));
ReactDOM.render(<h1>Hello Root 2</h1>, document.getElementById('root2'));

-

// bind an processed element
class Test extends Component {    
    render() {
        let arr = ['Random-Header-1', 'Random-Header-2', 'Random-Header-3', 'Random-Header-4', 'Random-Header-5'];
        let header = <h1>{arr[Math.floor(Math.random() * arr.length)]}</h1>;

        return (
            <div>
                {header}
				<p>Paragraph</p>
				<p>Paragraph</p>
            </div>
        )
    }
}

-

[props]
passing arguments using tag attributes syntax.
we can pass any type as props (string, number, object etc.)

recommendation:
always pass the props to the parent component.

props accessibility:
the 'props' object is available for us within the component even if we haden't declared it explicitly! 
the best practice is to declare it in the constructor and pass it through to the parent using the super function.
we can use js destructuring to extract specific properties from the props object. (see 'using destructuring') 

using destructuring:
// extracts only the 'name' property from the props object. 
// note that we can still access all properties via the 'props' object
constructor({ name }){ ... } // name is accessible within the constructor, props also available.
constructor(props, { name }){ ... } // same as above but explicit (props)

using:
class ClassA extends React.Component {
	constructor(props) {
		super(props);   
	}

	render() {
		return (<h1>Hello {this.props.name}!</h1>)
	}
}
ReactDOM.render(<ClassA name="Roby" />, document.getElementById('root'));

-

class Test extends React.Component {
	constructor({ name }) {
		super();  
		this.state = {
			o_name: name
		}
	}

	render() {
		return (
			<>
				<p>{JSON.stringify(this.props)}</p>
				<p>{this.props.name}</p>
				<p>{this.state.o_name}</p>
			</>
		)
	}
}

-

[component in component]
class ClassA extends React.Component {
    render() {
        return (
            <div>
                <h1>Hello {this.props.name}!</h1>
                <ClassB />
            </div>
		)
    }
}

class ClassB extends React.Component {
    render() {
        return (
            <div>
                <p>Paragraph 1</p>
                <p>Paragraph 2</p>
            </div>
		)
    }
}

ReactDOM.render(<ClassA name="Roby" />, document.getElementById('root'));

-

[external components]
use 'export' keyword to expose the component to be able to use it from other files.

// ComponentA.js
import React from 'react';
import ReactDOM from 'react-dom';

class ComponentA extends React.Component {
	render() {
		return <h2>Hi ComponentA</h2>;	 
	}
}
export default ComponentA;


// index.js
import React from 'react';
import ReactDOM from 'react-dom';
import ComponentA from './ComponentA.js';

ReactDOM.render(<ComponentA />, document.getElementById('root'));

-

[state]
- init the state in the constructor.
- use state.<propName> anywhere within the component.
- use setState to update the state. setState method allows us to update the full state object or only partial properties. 

setState(<newState>);  // full update 
setState({ <propName>: <value>});  // partial update

tip:
best practice is to NOT do changes directly on the state and then pass it to the 'setState' function! 
try to always use the partial update approach.

sample:
class Test extends Component {
    constructor() {
        super();
        this.state = {
            p1: 'value-1', 
            p2: 'value-2'
        };
    }
    
    changeP1 = e => {
        this.state.p1 = `value-${Math.floor(Math.random() * 100)}`;
        this.setState(this.state);
    }

    render() {
        return (<div>
            <h1 className="blue">Hello World</h1>
            <p>{this.state.p1}</p>
            <p>{this.state.p2}</p>
            <p><button onClick={this.changeP1}>change-p1</button></p>
        </div>)
    }
}

-

[Lifecycle]
the component's lifecycle. 

operations:
1. Mounting	   
   occurs when a component is created.

2. Updating	
   occurs when a component is updated (there was a change in the state or props)

3. Unmounting
   occurs when a component is removed from the DOM.

Mounting lifecycle:
- constructor				// init component 
- getDerivedStateFromProps	// pre-render. signature: static getDerivedStateFromProps(props, state);  
- render					// render 
- componentDidMount			// post-render

Updating lifecycle:
- getDerivedStateFromProps	// pre-render. signature: static getDerivedStateFromProps(props, state);  
- shouldComponentUpdate		// determine whether to continue with the update process or not (default: true)
- render					// render
- getSnapshotBeforeUpdate	// get access to the state and props before the changes. signature: getSnapshotBeforeUpdate(prevProps, prevState);
- componentDidUpdate		// post-render

Unmounting lifecycle:
- componentWillUnmount		// pre-remove. right before removing the component. 

using:
// the value of 'p1' will be updated after 2 seconds.
class Test extends Component {
    constructor(props) {
        super(props);
        this.state = {
            p1: 'value-1'
        };       
    }

	componentDidMount() {
		setTimeout(() => {
			this.setState({ p1: "value-1-updated" })
		}, 2000)
	}

	render() {
        return (<p>{this.state.p1}</p>)
    }
}

-

[Events]
React supports the same events as HTML.
it uses the same evente name but in camelcase mode (onclick -> onClick etc.)

tip: 
use arrow functions to refer 'this' always as the component. 

important! 
when using regular functions instead of arrows, we MUST bind the function using the 'bind' method.
this.fun1 = this.fun1.bind(this);

sample:
class Test extends Component {    
	constructor(props) {
		super(props)
		this.fun2 = this.fun2.bind(this);  // bind method (for regular functions)
	}	

	fun1 = e => { ... }  // arrow function - no binding is required! 'this' refers to the component.
    fun2(e) { ... }  // regular function - binding is required!

    render() {
        return (
			<div>
				<button onClick={this.fun1}>clickMe</button>
				<button onClick={this.fun2}>clickMe</button>
			</div>
		)
    }
}

-

[Forms]
when using forms in react, we need to update the component's state on each change. 
we do that using the 'onChange' event of the input.
we can also use 'onSubmit' event to be triggered when the form is about to be submitted.
to revoke the actual submit action, we can call 'preventDefault' method of the event.

validations:
we can handle validations as part of each change or when submitting the form. 
we can use the state to collect errors and present them as a summary in the html.

textarea tag:
unlike in HTML, in React, the value of a TextArea is set using a 'value' attribute and NOT as innerText.
// e.g 
<textarea value={this.state.description} />
<textarea value="some description..." />

select tag:
unlike in HTML, in React, the selected value is controlled by a 'value' attribute of the 'select' tag and NOT as the option's 'selected'.
// e.g
<select value={this.state.selectedValue}>
    <option value="1">Value1</option>
    <option value="2">Value2</option>
    <option value="3">Value3</option>
</select>
<select value="2">
    <option value="1">Value1</option>
    <option value="2">Value2</option>
    <option value="3">Value3</option>
</select>

generic setInput function:
in js, we can use the array-like syntax to create object properties dynamically. 
obj[<key>] = <value>

// e.g
setInput = e => {
    this.setState({
        [e.target.name]: e.target.value
    });
}

using:
class TestForm extends Component {
    constructor() {
        super();
        this.state = {
            input1: '',
            input2: ''
        };
    }

    setInput1 = e => {
        this.setState({
            input1: e.target.value
        });
    }

    setInput2 = e => {
        this.setState({
            input2: e.target.value
        });
    }

	submitForm = e => {
		e.preventDefault();
		// code here...
	}

    render() {
        return (
            <form onSubmit={this.submitForm}>
                <h1>Test Form</h1>
                <input type="text" placeholder="input-1" onChange={this.setInput1} />
                &nbsp;&nbsp;<span>{this.state.input1}</span>
                <br /><br />
                <input type="text" placeholder="input-2" onChange={this.setInput2} />                                
                &nbsp;&nbsp;<span>{this.state.input2}</span>
				<br /><br />
				<input type="submit" />
            </form>
        )
    }
}

ReactDOM.render(<TestForm />, document.getElementById('root'));

-

[CSS]
- inline 
- inline using a js-object 
- css file

inline:
style={{ <name>:<value>... }}

inline using a js-object:
style={ <stylesObject> }

css file:
import <cssFile>;
className="<className>"


sample:
import './index.css';

class TestStyles extends Component {
    render() {
		const p2Styles = {
			color: "yellow", 
			backgroundColor: "blue"
		};

        return (<div>            
            <p style={{color: "blue", backgroundColor: "yellow"}}>Paragraph 1</p>
            <p style={p2Styles}>Paragraph 2</p>
            <p className="red">Paragraph 3</p>            
        </div>)
    }
}

-

[Sass]
CSS pre-processor. 
files with .scss extension.

install:
> npm install --save node-sass

sample:
import './index.scss';

// jsx
<h6 className="title">Hello World</h6>

// scss
$size: 20px;
$color: purple;

h6.title {
    font-size: $size;
    color: $color;
    border:dashed 1px #808080;
    padding: 8px;
    margin: 0px;
}

- 

React ref:
// declare a ref
constructor(props) {
    super(props);    
    this.textInput = React.createRef();    
  }

 // bind a ref
 <input type="text" ref={this.textInput} />

 // access  
 this.textInput.current;

 -

 React.createRef
 see 'React ref'

 -

 wrapper component:
 use {this.props.children} to render the inner content! 

 // sample
 class Wrapper1 extends React.Component {
    constructor(props) {
        super(props);
    }

    render() {
        const box = {
            backgroundColor: '#666',
            color: '#fff',
            padding: '12px',
            border: 'solid 1px #000',
            marginBottom: '10px'
        };

        return (
            <div style={box}>
                {this.props.children}
            </div>
        )
    }
}

class TestWrapper1 extends React.Component {
    render() {
        return (
            <Wrapper1>
                <p>Paragraph 1</p>
                <p>Paragraph 2</p>
                <p>Paragraph 3</p>
            </Wrapper1>    
        )
    }
}

-

// using map to render an array 
render() {   
    const arr = ['A', 'B', 'C', 'D'];
    return (
        <ul>
            {arr.map(x => <li>{x}</li>)}
        </ul>
    )
}

-

arrays and the 'key' property.
commonly used when returning a JSX of component arrays.
must be unique. allows REACT engine to render only the changed array items by identifying the item by its key.

// sample
class Test extends React.Component {
    render() {
        const arr = [
            { id: 1, name: 'Roby' },
            { id: 2, name: 'Roby' },
            { id: 3, name: 'Avi' },
            { id: 4, name: 'Avi' }
        ];
        return (
            arr.map(x => {
                return <Component1 key={x.id} name={x.name} />
            })
        )
    }
}

class Component1 extends React.Component {
    render() {
        return <p>{this.props.name}</p>
    }
}

-

useEffect ???

-

sample
localStorage 
getItem, setItem

-

localStorage exception in react.NET:
an attempt to use 'localStorage' before the component was rendered will throw an exception! 
use the 'componentDidMount' to access the storage after the component was created!
best practices - use setState to preserve the value on any react re-rendering actions.

example-1:
componentDidMount = () => {
    const affiliateId = localStorage.getItem('affiliateId') || 0;
    if(affiliateId) document.querySelector('#affiliateId').value = affiliateId;
}
<input type="text" name="affiliateId" id="affiliateId" defaultValue="0" />

example-2:
constructor(props) {
    super(props);
    this.state = {
        selectedIndex: 0
    }
}

componentDidMount = () => {
    const stepIndex = localStorage.getItem('stepIndex');
    if (stepIndex) this.setState({ selectedIndex: stepIndex });
}

changeView = componentIndex => {        
    this.setState({
        selectedIndex: componentIndex
    });
    localStorage.setItem('stepIndex', componentIndex);
}

-

// state with no constructor
class Test extends React.Component {
    state = { ... };
}

-

[debugging]

chrome EXT:
React Developer Tools
https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en

// using
open dev tools (F12) > a new tab is added to the right (React or Components).
we would see all the defined components on the page. 
once click on a component, a new pane appears from the right with the selected component's props and state.  
we can change the state or props and it will be reflected on the page immediately.

// note
we MUST use the client version to use the React tools! there are 2 versions: PROD and DEV (see 'CDN')


-

Supported Events:
- Clipboard
	- onCopy 
	- onCut 
	- onPaste
- Composition
	- onCompositionEnd 
	- onCompositionStart 
	- onCompositionUpdate
- Keyboard 
	- onKeyDown 
	- onKeyPress 
	- onKeyUp
- Focus 
	- onFocus 
	- onBlur
- Form 
	- onChange 
	- onInput 
	- onInvalid 
	- onReset 
	- onSubmit 
Generic 
	- onError 
	- onLoad
Mouse 
	- onClick 
	- onContextMenu 
	- onDoubleClick 
	- onDrag 
	- onDragEnd 
	- onDragEnter 
	- onDragExit
	- onDragLeave 
	- onDragOver 
	- onDragStart 
	- onDrop 
	- onMouseDown 
	- onMouseEnter 
	- onMouseLeave
	- onMouseMove 
	- onMouseOut 
	- onMouseOver 
	- onMouseUp
Pointer 
	- onPointerDown 
	- onPointerMove 
	- onPointerUp 
	- onPointerCancel 
	- onGotPointerCapture
	- onLostPointerCapture 
	- onPointerEnter 
	- onPointerLeave 
	- onPointerOver 
	- onPointerOut
Selection 
	- onSelect
Touch 
	- onTouchCancel
	- onTouchEnd 
	- onTouchMove 
	- onTouchStart
UI 
	- onScroll
Wheel 
	- onWheel
Media 
	- onAbort 
	- onCanPlay 
	- onCanPlayThrough 
	- onDurationChange 
	- onEmptied 
	- onEncrypted
	- onEnded 
	- onError 
	- onLoadedData 
	- onLoadedMetadata 
	- onLoadStart 
	- onPause 
	- onPlay
	- onPlaying 
	- onProgress 
	- onRateChange 
	- onSeeked 
	- onSeeking 
	- onStalled 
	- onSuspend
	- onTimeUpdate 
	- onVolumeChange 
	- onWaiting
Image 
	- onLoad 
	- onError
Animation 
	- onAnimationStart 
	- onAnimationEnd 
	- onAnimationIteration
Transition 
	- onTransitionEnd

- 

function-based components:
commonly used for UI components when there's no state required! 

import React from 'react'
const TestComponent = (props) => {
	return (
		<h1>Hello React</h1>
	)
}

- 

best practices to get access to the parent state is by creating a function which makes the desired changes to the state 
and pass this function as prop to the child component.

// use form as the child component
class ParentComponent extends React.Component {
    constructor() {
        super();
        this.state = {
            users: [
                { name: 'User-A' },
                { name: 'User-B' }
            ]
        }
    }

    addUser = (user) => {
        let newUsers = [...this.state.users, user];
        this.setState({
            users: newUsers
        });
    }

    render() {
        return (
            <>
                <h1>Test React</h1>
                {this.state.users.map(u => <div>{u.name}</div>)}
                <ChildComponent fnAddUser={this.addUser} />                
            </>
        )
    }
}

class ChildComponent extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            name: ''
        };
    }

    setName = e => {
        this.setState({
            name: e.target.value
        });
    }

    submitForm = e => {
        e.preventDefault();

		// code... (send to server etc.)

		// update the parent with the new user        
		this.props.fnAddUser({ name: this.state.name });
    }

    render() {
        return (
            <form onSubmit={this.submitForm}>
                <h5>new user</h5>
                <p>
					<input type="text" placeholder="user-name" onChange={this.setName} />
					<input type="submit" value="SUBMIT" />
				</p>
            </form>
        )
    }
}

// extra
// create a child without a form, it uses js events to call the parent 'fnAddUser' 
class ChildComponentNoForm extends React.Component {       
    addUser = e => {
        this.props.fnAddUser({ name: this.userName.current.value });  // call the parent fn
    }

    render() {
        this.userName = React.createRef();  // create ref to the input

        return (
            <>
                <input ref={this.userName} type="text" placeholder="user-name"  />
                <button onClick={this.addUser}>add</button>
            </>
        )
    }
}

-

install:
> npm install --save react-router-dom

import:
import { BrowserRouter as Router, Route } from 'react-router-dom';

syntax:
<Router>    
    <Route path="[path]" component={component} />
    ...
	...
</Router>

BrowserRouter properties:
- basename		// base path
- forceRefresh	// determine whether to use full-page-refresh

Route properties:
- path			// route relative path
- exact			// see 'Route exact property'

Route parameters:
use the :<parameter> syntax (similar to node express)
to get the parameter value, use the 'match' object from the component props.

// syntax
<Route path="[path]/:[parameter]" ... />	// define route with parameter
this.props.match.params.<paramName>			// get parameter

//e.g 
<Route path="/users/:id" ... />
let userId = this.props.match.params.id;

Route exact property:
by default, the route path uses 'contains' match-type, to set an exact match use 'exact' route property.
note that for these 2 routes '/' and '/a' with no 'exact', when routing to '/a' we'll see the content of both route '/' and route '/a' cause '/a' contains the value '/' !

Link module:
generates an a tag

NavLink module:
same as the 'Link' module with extra 'active' css-class for the active link.

Link module vs a-href:
its best practices to use 'Link' module always instead of regular HTML a tag. 
using 'Link' prevents the default behavior so it disables the request and only load (client-side) the route component. 
hence, the performance is better and the transition is smoother!

props:
all of the listed object are added to the props collection
- match object
- location object
- history object

params
see 'Route parameters'

note! 
to import these props to a non-route component (e.g: NavBar) we must wrap it using the 'withRouter' module 

import { withRouter } from 'react-router-dom';
const NavBar = withRouter((props) => { ... });

Switch module:
grab ONLY the first (route) match from top to bottom!

import { Switch } from 'react-router-dom';
<Router>
    <NavBar />
	<Switch>		
		<Route path="/page" component={Component1} />                    		
		<Route path="/:name" component={Component2} />                                   
	</Switch>
</Router>

in the above example, the URL '/page' matches both routes! ('name' is a parameter which can also takes 'page' as a value)
without the 'Switch' module, both 'Component1' and 'Component2' will be rendered. whereas, using a 'Switch' will only render 'Component1' cause it is the first match from the top!


sample:
import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter as Router, Route, Link } from 'react-router-dom';

const NavBar = () => {
    return (
        <ul>
            <li><Link to="/">Home</Link></li>
			<li><Link to="/a">PageA</Link></li>
			<li><Link to="/b">PageB</Link></li>            
        </ul>
    )
}

class Index extends Component {
    render() {
        return (
            <Router>
                <NavBar />
                <Route exact path="/" component={Home} />
                <Route path="/a" component={PageA} />                    
                <Route path="/b" component={PageB} />
                <Route path="/c/:id" component={PageC} />                                   
            </Router>
        )
    }
}

class Home extends Component {
    render() {
        return (
            <>
                <h1>Hello Home</h1>
            </>
        )
    }
}

class PageA extends Component {
    render() {
        return (
            <>                
                <h1>Hello Page A</h1>
            </>            
        )
    }
}

class PageB extends Component {
    render() {
        return (
            <>             
                <h1>Hello Page B</h1>
            </>
        )
    }
}

class PageC extends Component {        
    render() {        
        return (
            <>
                <h1>Hello Page C</h1>
                <p>{this.props.match.params.id}</p>
            </>
        )
    }
}

ReactDOM.render(<Index />, document.getElementById('root'));

-

// change state after X seconds
constructor(props) {
    super(props);
    this.state = {
        value: ''
    };       
}
    
render() {        
	setTimeout(() => {
		this.setState({
            value: 'some-value'
        });
	}, 5000);

    return (           
        <p>{this.state.value}</p>            
    )
}

- 

Higher Order Component:
aka wrapper-component.

note! 
we can also create a component which renders the children (this.props.children) 
and consume it by wrapping content in the JSX returning value. (see 'wrapper component using children rendering')

creation of an Higher Order Component requires 3 steps
- create a component which gets an inner-component as a parameter
- create a wrapped-version of the inner-component by wrapping it with the wrapper.
- render the wrapped-version 

// sample
// wrapper component - gets a component to wrap as a parameter
const WrapperComponent = InnerComponent => {
    let styles = {
        backgroundColor: 'yellow',
        color: 'red',
        padding: '12px'
    }

    return class extends Component {
        render() {
            return (
                <div style={styles}>
                    <InnerComponent {...this.props} />
                </div>
            )
        }
    }
}

// inner component - a component to be wrapped
const SomeComponent = props => {
    return <h4>Hello {props.name || 'Anonymous'}</h4>
}

// wrapped version of the inner component
const SomeComponentWrapped = WrapperComponent(SomeComponent);

// using
<SomeComponentWrapped name="roby" />

- 

Wrapper-component using children rendering:
use {this.props.children} within the wrapper JSX to render the children. 

tip:
another alternative is to use Higher Order Component as a wrapper (see 'Higher Order Component')

// sample
class Wrapper1 extends Component {    
    render() {        
        const box = {
            backgroundColor: '#666',
            color: '#fff',
            padding: '12px',
            border: 'solid 1px #000',
            marginBottom: '10px'
        };

        return (
            <div style={box}>
                {this.props.children}
            </div>
        )
    }
}

class TestWrapper1 extends Component {
    render() {
        return (
            <Wrapper1>
                <p>Paragraph 1</p>
                <p>Paragraph 2</p>
                <p>Paragraph 3</p>
            </Wrapper1>    
        )
    }
}

-

conditional JSX:

render(){
	... 
	...
	let jsxToRender = users.length == 0 ? (
		<h4>No Users!</h4>
	) : (
		users.map(u => { 
			return <div>{u.name}</div>
		})
	)

	return (
		<>
			{jsxToRender}
		</>
	)
}

-

images:
import image1 from './237-300x200.jpg';

render(){	
	return (<img src={image1} />)
}

-

// TODO ->> document + sample test
[React Context]
context to share across the app. a global state.
serves as a global data for a tree of react components.
an alternative to the REDUX engine (see 'REDUX') 
can also be replaced with useContext (see 'React Hooks') - better approach.

update context:
to update the context outside of the provider, we need to create a function which performs the update and pass it to the context value. 

// e.g:
this.state = { value: 'value1' };
updateValue = (newValue) => { 
	this.SetState({ value: newValue }) 
}
<MyContext.Provider value={{ ...this.state, updateValue }}>
	{ this.props.children }
</MyContext.Provider>


process:
// TODO 

// using
// myContext.jsx
import React, { createContext } from 'react';
const MyContext = createContext();

class MyContextProvider extends Component { 
	constructor(props) {
		super(props);
		this.state = {
			p1: 'value1',
			p2: 'value2'
		};       
	}

	fun = () => { }
	foo = () => { }

	render(){
		return (
			// the 'value' property holds the context which will be available to the children components.
			// passing the current state as the context (using spread operator) plus adding 'fun' and 'foo' to the context.
			<MyContext.Provider value={{ ...this.state, fun, foo }}>
				{ this.props.children }
			</MyContext.Provider>
		)
	}
}

export default MyContextProvider;

// index.jsx
// wrap the root component with the ContextProvider.
import MyContextProvider from './myContext';

class Index extends Component { 
	render() {
		return(
			<MyContextProvider>
				<h4>Hello React</h4>
				<Component1 />
				<Component2 />
				<Component3 />
			</MyContextProvider>
		)
	}
}

// (option-1) static contextType
// consume a context using static pre-defined type
// supports ONLY a single context
// supports ONLY class-based components
class Component1 extends Component { 
	static contextType = MyContext;  // set the contextType to consume as static and use the this.context to access it!
	render() {
		// context is now exposed (of type MyContext)
		// react engine bubbles-up the tree to find the first match based on the context-type defined as static to this component. it then sets it to the 'context' property. 
		console.log(this.context);
		return(...)
	}
}

// (option-2) Context.Consumer
// consume a context using Context Consumer
// supports multiple (see 'React Multiple Contexts')
// supports both class and function-based components 
class Component1 extends Component { 	
	render() {
		return (
			// uses a function to render a new JSX. gets the context as parameter. 
			<MyContext.Consumer> { 
				(context) => {
					console.log(this.context);
					return(...)
				}
			}
			</MyContext.Consumer>
		);		
	}
}

ReactDOM.render(<Index />, document.getElementById('root'));

-

// TODO ->> document + sample test
[React Multiple Contexts]
only the Context.Consumer approach supports multiple contexts. the 'contextType' can only use a single context. 
by wrapping a context in another context we get access to both contexts.

syntax:
return (
	<MyContext1.Consumer> { 
		(context1) => {

			<MyContext2.Consumer> { 
				(context2) => {					
					
					<MyContextN.Consumer> { 
						(contextN) => {					
							return(<JSX>)
						}
					}
					</MyContextN.Consumer>

				}
			}
			</MyContext2.Consumer>

		}
	}
	</MyContext1.Consumer>
)

sample:
// Context.Consumer with multiple contexts
// wrap one context with the other to gain access to both contexts
class Component1 extends Component { 	
	render() {
		return (			
			<MyContext1.Consumer> { 
				(context1) => {
					<MyContext2.Consumer> { 
						(context2) => {
							console.log(this.context1);
							console.log(this.context2);

							return(...)
						}
					}
					</MyContext2.Consumer>
				}
			}
			</MyContext1.Consumer>
		);		
	}
}

-

// TODO ->> document + sample test (optional: https://www.simplethread.com/cant-replace-redux-with-hooks/)

[React Hooks]

hooks:
- useState
- useEffect
- useContext
- useReducer


useState:
use it to create a state for a component (class or a function).  
when invoking the 'useState' method, we'll receive the current state value and a function to update the state with a new value.

// syntax 
const [value, setValue] = useState(<init-value>);

// using 
import React, { useState } from 'react';
const [str, setStr] = useState(''); // string-value state
const [obj, setObj] = useState({}); // object-value state
const [arr, setArr] = useState([]); // array-value state


useEffect:
occurs every time the component is being rendered. 
its a function which will be fired on-render.  

// syntax
useEffect(() => { ... });
useEffect(() => { ... }, [ <filter> ]); // filter = data to monitor

// note
we can use multiple 'useEffect' functions in the same component. 
can also add different filter each (data to monitor)

// using 
import React, { useEffect } from 'react';
useEffect(() => { 
	console.log('useEffect hook is triggered');
});

// using (multiple with filters)
const [name, setName] = useState('');
const [users, setUsers] = useState([]);

useEffect(() => { 
	console.log('some change has occurred in name');
}, [name]);
useEffect(() => { 
	console.log('some change has occurred in users');
}, [users]);


useContext:
another (cleaner) way to consume react contexts. see ('React Context').
supports multiple contexts, supports both class and function-based components.
the creation of the context provider is identical to the React Context approach, the only thing that changes is the way we consume it. 
when using the 'useContext' function, we consume it via hook instead of a static instance lookup.

// syntax 
const context = useContext(<contextName>);

// using 
// myContext.jsx
import React, { createContext, useContext } from 'react';

// create a context and a context-provider
const MyContext = createContext();
class MyContextProvider extends Component { 
	constructor(props) {
		super(props);
		this.state = {
			p1: 'value1',
			p2: 'value2'
		};       
	}

	fun = () => { }
	foo = () => { }

	render(){
		return (			
			<MyContext.Provider value={{ ...this.state, fun, foo }}>
				{ this.props.children }
			</MyContext.Provider>
		)
	}
}

export default MyContextProvider;

// index.jsx
// wrap the root component with the ContextProvider.
import MyContextProvider from './myContext';

class Index extends Component { 
	render() {
		return(
			<MyContextProvider>
				<h4>Hello React</h4>
				<Component1 />
				<Component2 />
				<Component3 />
			</MyContextProvider>
		)
	}
}

// consume a context
class Component1 extends Component { 	
	render() {
		// const context = useContext(MyContext);		
		const { p1, p2, fun, foo } = useContext(MyContext);		
		return(...)
	}
}


useReducer:
reducer is an event handler. it listens to actions coming-in and interacts with the component's state. it gets the current state and an action and returns a new state. 
(pseudo code -> (state, action) => newState)
the reducer is usually defined within the root-component and can be consumed by any other component down the components-tree.
the 'action' usually comprised of 2 properties -> { type, payload }
note! The state processed by a reducer function is immutable

useReducer vs REDUX:
REDUX creates one global state container for the whole app (store) and uses a single dispatch function to trigger all events. it also a "Single source of truth".
useReducer is an independent component located within the component it has been defined in and shares the same state. there are multiple reducers and each has its own dispatch function.
REDUX uses useReducer under-the-hood.

// syntax 
import React, { useReducer } from "react";
const [state, dispatch] = useReducer(<reducer>, <init-state>);
dispatch({ type, payload });

init-state-function:
when using the 3rd argument of the useReducer hook, it ignores the init-state from the 2nd argument and apply as init-value the return value from the init-state-function.
const [state, dispatch] = useReducer(<reducer>, <init-state>, <init-state-function>);

process:
a reducer function is created in a component (usually the root component). 
the reducer function is the event handler for incoming actions. it interacts with the component's state. it gets 2 parameters - the 'state' and the 'action' and returns the updated state.
a dispatch function fires an action from any component down the tree which then be caught and processed by a reducer function. 

note: 
we need to pass the dispatch function through the context.

// using 
import React, { useReducer } from "react";
const fnReducer = (state, action) => {
	switch(action.type){
		case 'action1' return 'value-1';
		case 'action2' return 'value-2';
		case 'action3' return 'value-3';		
		case 'actionN' return `value-${action.payload.value}`;
		default: return state;
	}
}
const [state, dispatch] = useReducer(fnReducer, 'default-value');
dispatch({ type: 'action1' });
dispatch({ type: 'action2' });
dispatch({ type: 'action1', payload: null });
dispatch({ type: 'actionN', payload: { value: 20 } });


// example
// myContext.jsx
import React, { createContext, useReducer } from 'react';

// create a context and a context-provider
const MyContext = createContext();

// create a reducer
const fnReducer = (state, action) => {
	switch(action.type){
		case 'action1' return 'value-1';
		case 'action2' return 'value-2';
		case 'action3' return 'value-3';		
		case 'actionN' return `value-${action.payload.value}`;
		default: return state;
	}
}

class MyContextProvider extends Component { 
	const [state, dispatch] = useReducer(fnReducer, 'default-value');

	render(){
		return (			
			<MyContext.Provider value={{ state, dispatch }}>
				{ this.props.children }
			</MyContext.Provider>
		)
	}
}
export default MyContextProvider;

// index.jsx
// wrap the root component with the ContextProvider.
import MyContextProvider from './myContext';

class Index extends Component { 
	render() {
		return(
			<MyContextProvider>
				<h4>Hello React</h4>
				<Component1 />
				<Component2 />
				<Component3 />
			</MyContextProvider>
		)
	}
}

// access the dispatch function from another component down the tree
class Component1 extends Component { 	
	render() {		
		const { dispatch } = useContext(MyContext);		
		return(...)
	}
}

-

// TODO ->> document + sample test
[REDUX]
a central data store for the app. 
commonly used as a shared state across the whole app.
also see 'React Context' and 'React Hooks'
 
source:
https://redux.js.org/introduction/getting-started


install:
> npm install --save redux react-redux

process:
// TODO 

sample:
// index.jsx
import { createStore } from 'redux';
import { Provider } from 'react-redux';

// reducer is kind of an handler to process actions coming from any component in the app
// and sets the redux-state accordingly 
const initState = {}
const reducer = (state = initState, action) => { 
	switch(action.type){
		...
	}
}
const store = createStore();
ReactDOM.render(<Provider store={store}><Index /></Provider>, document.getElementById('root'));


// someComponent.js
import { connect } from 'react-redux';

class SomeComponent extends Component{ 
	render(){
		return <p>{this.props.p1}</p>
	}
}

// 'connect' module adds data to the current component's props. it has access to the redux-state object and redux-dispatch function.
// in the below example, 'p1' and 'fun1' will be added to the current component's props object.
// note that, when invoking the 'fun1' function, the 'fnDispatch' function is being called so the 'reducer' defined in the root component (index.js) could catch it and process the action!

const mapReduxState2Props = (reduxState, componentProps) => { 
	return { p1: reduxState.p1 } 
}
const mapReduxDispatch2Props = (fnDispatch) => { 
	return { 
		fun1: () => { 
			fnDispatch({ type: 'SomeAction' ... })  // fnDispatch(<action>)
		}
	} 
}
export default connect(mapReduxState2Props, mapReduxDispatch2Props)(SomeComponent);

-

custom-made views router:
class HomeRouter extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            module: <Home />
        }
    }

    changeView = e => {        
        let selected;
        switch (e.target.getAttribute('component')) {
            default:
            case 'Home': selected = <Home />;
                break;
            case 'ContactUs': selected = <ContactUs />;
                break;
            case 'AboutUs': selected = <AboutUs />;
                break;
        }

        this.setState({
            module: selected
        });
    }

    render() {
        return (
            <>                
                <HomeNAV changeView={this.changeView} />
                {this.state.module}
            </> 
        )
    }
}

class HomeNAV extends React.Component {
    render() {
        return (
            <>
                <button onClick={this.props.changeView} component="Home">Home</button>
                <button onClick={this.props.changeView} component="ContactUs">ContactUs</button>
                <button onClick={this.props.changeView} component="AboutUs">AboutUs</button>
            </>
        )
    }
}

class Home extends React.Component {
    render() {
        return <h1>Home</h1>
    }
}

class ContactUs extends React.Component {
    render() {
        return <h1>ContactUs</h1>
    }
}

class AboutUs extends React.Component {
    render() {
        return <h1>AboutUs</h1>
    }
}

-

How to update parent state from child?
pass the function as prop to the child component. 

// sample
class Parent extends React.Component {
    constructor(props) {
        super(props)
        this.state = { name: 'None' }
    }

    setName = e => {
        this.setState({
            name: e.target.getAttribute('data-name')
        })
    }

    render() {
        return (
            <>
                <p>{this.state.name}</p>
                <Child setName={this.setName} />
            </>
        )
    }
}

class Child extends React.Component {
    render() {
        return (
            <>
                <button onClick={this.props.setName} data-name="Roby">Roby</button>
                <button onClick={this.props.setName} data-name="John">John</button>
            </>
        )
    }
}

-

override base state:

class StepBase extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            nextStep: ''            
        }
    }
}

class Step1 extends StepBase {
    constructor(props) {
        super(props);
        this.state.nextStep = 'Step2';        
    }

    render() {
        return <h1>Step1</h1>
    }
}

class Step2 extends StepBase {
    constructor(props) {
        super(props);
        this.state.nextStep = 'Step3';        
    }

    render() {
        return <h1>Step2</h1>
    }
}

-

convert html-form to json payload:

class StepBase extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            nextStep: '',               
        }

        this.form = React.createRef();
    }    

    form2Json = form => {
        let elements = form.current.elements;
        let filtered = [].filter.call(elements, e => e.name && e.name != '');

        return [].reduce.call(filtered, (acc, x) => {
			// handle radio and checkbox - collect only checked
            if (x.tagName.toLowerCase() == 'input' && (x.getAttribute('type') == 'checkbox' || x.getAttribute('type') == 'radio') && x.checked == false)
                return acc;
			// fix checkbox 'ON' value
            if (x.tagName.toLowerCase() == 'input' && x.getAttribute('type') == 'checkbox' && x.value == 'on')
                x.value = true;

            acc[x.name] = x.value;
            return acc;
        }, {});          
    };

    saveForm = async (e) => {
        e.preventDefault();

        let postURI = this.form.current.getAttribute('action');
        if (postURI == '') return;

        let payload = this.form2Json(this.form);        
        let response = await this.props.postChanges(postURI, payload);      
        if (response.Status == 'OK')
            this.props.changeView(this.state.nextStep);
        else
            alert('ERROR');
    }
}

class Step1 extends StepBase {
    constructor(props) {
        super(props);
        this.state.nextStep = 'Step2';              
    }
    
    render() {
        return (
            <>           
                <h1>Step1</h1>
                <p>{this.state.nextStep}</p>

                <form ref={this.form} onSubmit={this.saveForm} action="Forms/RegistrationStep1">
                    <input type="text" name="input1" /><br />
                    <input type="text" name="input2" /><br />
                    <button type="submit"></button>
                </form>
            </>
        )
    }
}

-

passing-on all props:

@Html.React("Parent", new { 
	p1: 'v1', 
	p2: 'v2' 
})

class Parent extends React.Component {
    constructor(props) {
        super(props);        
    }

    render() {
        return (
            <>
                <Child {...this.props} />                
            </>
        )
    }
}

class Child extends React.Component {
    constructor(props) {
        super(props);         
    }

    render() {
        return <h1>{this.props.p1}</h1>
    }
}

-

Reducer:
see 'javascript Reducers'

// example
// reducer of a complex state, preserve the current state and only override a specific property.
// use spread operator '...state' to preserve the current state and only then, override the property 'count'
const counterReducer = (state, action) => {
  switch (action.type) {
    case 'INCREASE':
      return { ...state, count: state.count + 1 };
    case 'DECREASE':
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
};

// example
const personReducer = (state, action) => {
  switch (action.type) {
    case 'INCREASE_AGE':
      return { ...state, age: state.age + 1 };
    case 'CHANGE_LASTNAME':
      return { ...state, lastName: action.payload.lastName };
    default:
      return state;
  }
};

let personState = {
  firstName: 'Roby',
  lastName: 'Cohen',
  age: 40,
};
 
const action1 = {
  type: 'CHANGE_LASTNAME',
  payload: {
    lastName: 'CCC',
  },
};

const action2 = {
  type: 'INCREASE_AGE',
  payload: {},
};

personState = personReducer(personState, action1);
personState = personReducer(personState, action2);

-

// example: module list using selected-index + navigator
class Subscription extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            selectedIndex: 0
        }
    }

    changeView = e => {       
        this.setState({
            selectedIndex: parseInt(e.target.getAttribute('componentIndex'))
        });
    }

    render() {
        const modules = [
            <SubscriptionDetails {...this.props} />,
            <SubscriptionWakeupSettings {...this.props} />,
            <SubscriptionChangePassword {...this.props} />,
            <SubscriptionWakeupCancelation {...this.props} />
        ];

        return (
            <>
                <SubscriptionNAV changeView={this.changeView} selectedIndex={this.state.selectedIndex} />
                {modules[this.state.selectedIndex]}                
            </>
        )
    }
}

class SubscriptionNAV extends React.Component {
    render() {
        return (
            <div class="tabs tabs-alt clearfix" id="tabs-profile">
                <ul class="tab-nav clearfix">                            
                    <li><a onClick={this.props.changeView} componentIndex="0" title=" "><i class="icon-users"></i>  </a></li>
                    <li><a onClick={this.props.changeView} componentIndex="1" title=" "><i class="icon-pencil2"></i>  </a></li>
                    <li><a onClick={this.props.changeView} componentIndex="2" title=" "><i class="icon-user-lock"></i>  </a></li>
                    <li><a onClick={this.props.changeView} componentIndex="3" title=" "><i class="icon-remove"></i>  </a></li>
                    <li><a href="subscription/logOut" title=""><i class="icon-line2-logout"></i> </a></li>
                </ul>
            </div>
        )
    }
}

-

// class library
class Functions {
    fun = () => { console.log('fun'); }
    foo = p1 => { console.log(`foo ${p1}`); }
    bar = (p1, p2) => { console.log(`foo ${p1} ${p2}`); }
} 

class ComponentA extends React.Component {
	constructor(props) {
        super(props);
        this.state = {};
    }

	render() {
        var f = new Functions();
        f.fun();
        f.foo('A');
        f.bar('A', 'B');

        return <h1>ComponentA</h1>
	}
}

-

conditional rendering:
// inline
render() {
	return (
		<div>		
			{diffInDays > 0 ? <>    {diffInDays} </> : <button type="submit" class="btn btn-dark m-0"></button>}
		</div>
	);
}

// variable
render() {
	let tagToRender;
	if (diffInDays > 0)
		tagToRender = <>    {diffInDays} </>;
	else
		tagToRender = <button type="submit" class="btn btn-dark m-0"></button>;

	return (
		<div>		
			{tagToRender}
		</div>
	);
}
-

React Hooks vs Redux:
// TODO

-

BundleConfig - jsx (.NET)
// TODO 

-

comment:
{/* A JSX comment */}
